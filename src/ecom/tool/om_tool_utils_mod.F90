MODULE OM_TOOL_UTILS_MOD

  ! Symbolds imported from intrinsic modules
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64

IMPLICIT NONE

! Default visibility
PRIVATE


REAL(KIND=REAL32), TARGET, DIMENSION(:), ALLOCATABLE :: GVALUES_SP
REAL(KIND=REAL64), TARGET, DIMENSION(:), ALLOCATABLE :: GVALUES_DP

! Whitelist of public symbols
PUBLIC :: OM_ABORT
PUBLIC :: DR_HOOK_DEFAULT8
PUBLIC :: PREPARE_OUTPUT_MANAGER_EC
PUBLIC :: SET_HOOK_VERBOSITY
PUBLIC :: READ_ATM_MESSAGE
PUBLIC :: READ_WAM_MESSAGE
PUBLIC :: READ_VAL_SP
PUBLIC :: READ_VAL_DP

LOGICAL :: HOOK_VERBOSE=.FALSE.

CONTAINS

SUBROUTINE SET_HOOK_VERBOSITY( VERBOSE )
IMPLICIT NONE
LOGICAL :: VERBOSE
HOOK_VERBOSE = VERBOSE
END SUBROUTINE SET_HOOK_VERBOSITY

SUBROUTINE OM_ABORT( CDTEXT )
IMPLICIT NONE
  CHARACTER(LEN=*), INTENT(IN) :: CDTEXT
  WRITE(*,*) 'ERROR: ', TRIM(CDTEXT)
  STOP
END SUBROUTINE OM_ABORT

SUBROUTINE DR_HOOK_DEFAULT8( CDNAME, KSWITCH, PKEY )
  USE :: OM_API_MOD, ONLY: JPIM_K
  USE :: OM_API_MOD, ONLY: JPTR_K
IMPLICIT NONE
  CHARACTER(LEN=*),     INTENT(IN)    :: CDNAME
  INTEGER(KIND=JPIM_K), INTENT(IN)    :: KSWITCH
  REAL(KIND=JPTR_K),    INTENT(INOUT) :: PKEY
  IF ( HOOK_VERBOSE ) THEN
    IF ( KSWITCH .EQ. 0 ) THEN
      WRITE(*,*) 'ENTER: ', TRIM(CDNAME)
    ELSE
      WRITE(*,*) 'EXIT: ', TRIM(CDNAME)
    ENDIF
  ENDIF

END SUBROUTINE DR_HOOK_DEFAULT8

SUBROUTINE PREPARE_OUTPUT_MANAGER_EC( DIRECTORY, PROC_ID, YDTOPO, YDOMP, BIG_ENDIAN_READ, VERBOSE )

  ! Symbols imported from other modules within the project.
  USE :: OM_API_MOD, ONLY: MODEL_PAR_T
  USE :: OM_API_MOD, ONLY: PROC_TOPO_T
  USE :: OM_API_MOD, ONLY: PAR_CREATE_NAME
  USE :: OM_API_MOD, ONLY: PAR_ROPEN
  USE :: OM_API_MOD, ONLY: PAR_READ
  USE :: OM_API_MOD, ONLY: PAR_CLOSE
  USE :: OM_API_MOD, ONLY: JPIB_K

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: DIRECTORY
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: PROC_ID
  TYPE(PROC_TOPO_T),    INTENT(INOUT) :: YDTOPO
  TYPE(MODEL_PAR_T),    INTENT(INOUT) :: YDOMP
  LOGICAL,              INTENT(IN)    :: BIG_ENDIAN_READ
  LOGICAL,              INTENT(IN)    :: VERBOSE

  ! Local variables
  CHARACTER(LEN=1024)  :: LOC_DIR
  CHARACTER(LEN=1024)  :: PARFNAME
  INTEGER(KIND=JPIB_K) :: PARUNIT
  INTEGER(KIND=JPIB_K) :: STAT

  ! Fill the topology object
  YDTOPO%NCOMM_W1IO = 1
  YDTOPO%NCOMM_WR = 1
  YDTOPO%NCOMM_IO = 1
  YDTOPO%MYPROC_WRIO = 1
  YDTOPO%MYPROC_IO = 1
  YDTOPO%MYPROC_WR = 1
  YDTOPO%NPROC_IO = 1
  YDTOPO%LIO_SERVER = .TRUE.
  YDTOPO%LIO_CLIENT = .FALSE.

  ! Read the parameters
  LOC_DIR = REPEAT( ' ', 1024 )
  WRITE(LOC_DIR,'(A,A,I6.6,A)') TRIM(DIRECTORY), '/io_serv.', PROC_ID, '.d'
  CALL PAR_CREATE_NAME( TRIM(LOC_DIR), PROC_ID, PARFNAME )
  CALL PAR_ROPEN( PARFNAME, PARUNIT, BIG_ENDIAN_READ )
  CALL PAR_READ( YDOMP, PARUNIT, VERBOSE )
  CALL PAR_CLOSE( PARUNIT )

  ! Exit point
  RETURN

END SUBROUTINE PREPARE_OUTPUT_MANAGER_EC

SUBROUTINE READ_ATM_MESSAGE( DIRECTORY, PROC_ID, MSG_ID, ADDR, YDMSG, BIG_ENDIAN_READ, VERBOSE )

  ! Symbols imported from other modules within the project.
  USE :: OM_API_MOD, ONLY: JPIB_K
  USE :: OM_API_MOD, ONLY: JPIB_K
  USE :: OM_API_MOD, ONLY: MSG_CREATE_NAME
  USE :: OM_API_MOD, ONLY: MSG_ROPEN
  USE :: OM_API_MOD, ONLY: MSG_READ_ATM
  USE :: OM_API_MOD, ONLY: MSG_CLOSE
  USE :: OM_API_MOD, ONLY: OM_ATM_MSG_T

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)  :: DIRECTORY
  INTEGER(KIND=JPIB_K), INTENT(IN)  :: PROC_ID
  INTEGER(KIND=JPIB_K), INTENT(IN)  :: MSG_ID
  INTEGER(KIND=JPIB_K), INTENT(IN)  :: ADDR
  TYPE(OM_ATM_MSG_T),   INTENT(OUT) :: YDMSG
  LOGICAL,              INTENT(IN)  :: BIG_ENDIAN_READ
  LOGICAL,              INTENT(IN)  :: VERBOSE

  ! Local variables
  CHARACTER(LEN=32)    :: CFMT
  CHARACTER(LEN=32)    :: CINT
  CHARACTER(LEN=1024)  :: LOC_DIR
  CHARACTER(LEN=1024)  :: MSGFNAME
  INTEGER(KIND=JPIB_K) :: MSGUNIT
  INTEGER(KIND=JPIB_K) :: STAT

  ! Read the message
  IF ( VERBOSE ) THEN
    CFMT=REPEAT(' ',32)
    CINT=REPEAT(' ',32)
  ENDIF

  LOC_DIR=REPEAT( ' ', 1024 )
  WRITE(LOC_DIR,'(A,A,I6.6,A)') TRIM(DIRECTORY), '/io_serv.', PROC_ID, '.d'
  CALL MSG_CREATE_NAME( TRIM(LOC_DIR), MSG_ID, PROC_ID, MSGFNAME )

  IF ( VERBOSE ) THEN
    WRITE(CINT,'(I10)') LEN_TRIM(MSGFNAME)
    WRITE(CFMT,'(A)') '(A'//TRIM(ADJUSTL(CINT))//')'
    WRITE(*,CFMT) TRIM(MSGFNAME)
  ENDIF

  CALL MSG_ROPEN( MSGFNAME, MSGUNIT, BIG_ENDIAN_READ )
  CALL MSG_READ_ATM( MSGUNIT, YDMSG, ADDR, VERBOSE )
  CALL MSG_CLOSE( MSGUNIT )

  ! Exit point
  RETURN

END SUBROUTINE READ_ATM_MESSAGE

SUBROUTINE READ_WAM_MESSAGE( DIRECTORY, PROC_ID, MSG_ID, ADDR, YDMSG, BIG_ENDIAN_READ, VERBOSE )

  ! Symbols imported from other modules within the project.
  USE :: OM_API_MOD, ONLY: JPIB_K
  USE :: OM_API_MOD, ONLY: JPIB_K
  USE :: OM_API_MOD, ONLY: MSG_CREATE_NAME
  USE :: OM_API_MOD, ONLY: MSG_ROPEN
  USE :: OM_API_MOD, ONLY: MSG_READ_WAM
  USE :: OM_API_MOD, ONLY: MSG_CLOSE
  USE :: OM_API_MOD, ONLY: OM_WAM_MSG_T

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)  :: DIRECTORY
  INTEGER(KIND=JPIB_K), INTENT(IN)  :: PROC_ID
  INTEGER(KIND=JPIB_K), INTENT(IN)  :: MSG_ID
  INTEGER(KIND=JPIB_K), INTENT(IN)  :: ADDR
  TYPE(OM_WAM_MSG_T),   INTENT(OUT) :: YDMSG
  LOGICAL,              INTENT(IN)  :: BIG_ENDIAN_READ
  LOGICAL,              INTENT(IN)  :: VERBOSE

  ! Local variables
  CHARACTER(LEN=32)    :: CFMT
  CHARACTER(LEN=32)    :: CINT
  CHARACTER(LEN=1024)  :: LOC_DIR
  CHARACTER(LEN=1024)  :: MSGFNAME
  INTEGER(KIND=JPIB_K) :: MSGUNIT
  INTEGER(KIND=JPIB_K) :: STAT

  ! Read the message
  IF ( VERBOSE ) THEN
    CFMT=REPEAT(' ',32)
    CINT=REPEAT(' ',32)
  ENDIF

  LOC_DIR = REPEAT( ' ', 1024 )
  WRITE(LOC_DIR,'(A,A,I6.6,A)') TRIM(DIRECTORY), '/io_serv.', PROC_ID, '.d'
  CALL MSG_CREATE_NAME( TRIM(LOC_DIR), MSG_ID, PROC_ID, MSGFNAME )

  IF ( VERBOSE ) THEN
    WRITE(CINT,'(I10)') LEN_TRIM(MSGFNAME)
    WRITE(CFMT,'(A)') '(A'//TRIM(ADJUSTL(CINT))//')'
    WRITE(*,CFMT) TRIM(MSGFNAME)
  ENDIF

  CALL MSG_ROPEN( MSGFNAME, MSGUNIT, BIG_ENDIAN_READ )
  CALL MSG_READ_WAM( MSGUNIT, YDMSG, ADDR, VERBOSE )
  CALL MSG_CLOSE( MSGUNIT )

  ! Exit point
  RETURN

END SUBROUTINE READ_WAM_MESSAGE




SUBROUTINE READ_VAL_SP( DIRECTORY, PROC_ID, MSG_ID, ADDR, &
& LB, UB, VALUES, BIG_ENDIAN_READ, VERBOSE )

  ! Symbolds imported from intrinsic modules
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64

  ! Symbols imported from other modules within the project.
  USE :: OM_API_MOD, ONLY: JPIB_K
  USE :: OM_API_MOD, ONLY: JPIB_K
  USE :: OM_API_MOD, ONLY: JPRM_K
  USE :: OM_API_MOD, ONLY: OM_WAM_MSG_T
  USE :: OM_API_MOD, ONLY: VAL_CREATE_NAME
  USE :: OM_API_MOD, ONLY: VAL_ROPEN
  USE :: OM_API_MOD, ONLY: VAL_READ_SP
  USE :: OM_API_MOD, ONLY: VAL_GENERATE_SP
  USE :: OM_API_MOD, ONLY: VAL_CLOSE

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*),                         INTENT(IN)    :: DIRECTORY
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: PROC_ID
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: MSG_ID
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: ADDR
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: LB
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: UB
  REAL(KIND=JPRM_K), DIMENSION(:), POINTER, INTENT(INOUT) :: VALUES
  LOGICAL,                                  INTENT(IN)    :: BIG_ENDIAN_READ
  LOGICAL,                                  INTENT(IN)    :: VERBOSE

  ! Local variables
  CHARACTER(LEN=1024)  :: LOC_DIR
  CHARACTER(LEN=1024)  :: VALFNAME
  INTEGER(KIND=JPIB_K) :: SZ
  INTEGER(KIND=JPIB_K) :: VALUNIT
  INTEGER(KIND=JPIB_K) :: STAT
  INTEGER(KIND=JPIB_K) :: N
  INTEGER(KIND=JPIB_K) :: NUNDEF
  REAL(KIND=REAL64) :: MINVAL
  REAL(KIND=REAL64) :: MAXVAL
  REAL(KIND=REAL64) :: AVGVAL
  REAL(KIND=REAL64) :: XUNDEF
  LOGICAL :: VALEX

  N = UB-LB+1
  IF ( .NOT. ALLOCATED(GVALUES_SP) ) THEN
    ALLOCATE( GVALUES_SP(N) )
  ELSE
    IF ( SIZE(GVALUES_SP) .LT. N ) THEN
      DEALLOCATE(GVALUES_SP)
      ALLOCATE( GVALUES_SP(N) )
    ENDIF
  ENDIF
  VALUES(LB:UB) => GVALUES_SP(1:N)

  ! Read the message
  LOC_DIR = REPEAT( ' ', 1024 )
  WRITE(LOC_DIR,'(A,A,I6.6,A)') TRIM(DIRECTORY), '/io_serv.', PROC_ID, '.d'
  CALL VAL_CREATE_NAME( TRIM(LOC_DIR), MSG_ID, PROC_ID, VALFNAME )

  INQUIRE( FILE=TRIM(VALFNAME), EXIST=VALEX )

  IF ( .NOT.VALEX .OR. ADDR.LT.0 ) THEN
    SZ = SIZE(VALUES)
    CALL VAL_GENERATE_SP( SZ, MINVAL, MAXVAL, AVGVAL, NUNDEF, XUNDEF, VALUES )
  ELSE
    CALL VAL_ROPEN( VALFNAME, VALUNIT, BIG_ENDIAN_READ )
    CALL VAL_READ_SP( VALUNIT, ADDR, VALUES )
    CALL VAL_CLOSE( VALUNIT )
  ENDIF

  ! Exit point
  RETURN

END SUBROUTINE READ_VAL_SP

SUBROUTINE READ_VAL_DP( DIRECTORY, PROC_ID, MSG_ID, ADDR, &
& LB, UB, VALUES, BIG_ENDIAN_READ, VERBOSE )

  ! Symbolds imported from intrinsic modules
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64

  ! Symbols imported from other modules within the project.
  USE :: OM_API_MOD, ONLY: JPIB_K
  USE :: OM_API_MOD, ONLY: JPIB_K
  USE :: OM_API_MOD, ONLY: JPRM_K
  USE :: OM_API_MOD, ONLY: JPRD_K
  USE :: OM_API_MOD, ONLY: OM_WAM_MSG_T
  USE :: OM_API_MOD, ONLY: VAL_CREATE_NAME
  USE :: OM_API_MOD, ONLY: VAL_ROPEN
  USE :: OM_API_MOD, ONLY: VAL_READ_DP
  USE :: OM_API_MOD, ONLY: VAL_GENERATE_DP
  USE :: OM_API_MOD, ONLY: VAL_CLOSE

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*),                         INTENT(IN)    :: DIRECTORY
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: PROC_ID
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: MSG_ID
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: ADDR
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: LB
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: UB
  REAL(KIND=JPRD_K), DIMENSION(:), POINTER, INTENT(INOUT) :: VALUES
  LOGICAL,                                  INTENT(IN)    :: BIG_ENDIAN_READ
  LOGICAL,                                  INTENT(IN)    :: VERBOSE

  ! Local variables
  CHARACTER(LEN=1024)  :: LOC_DIR
  CHARACTER(LEN=1024)  :: VALFNAME
  INTEGER(KIND=JPIB_K) :: SZ
  INTEGER(KIND=JPIB_K) :: VALUNIT
  INTEGER(KIND=JPIB_K) :: STAT
  INTEGER(KIND=JPIB_K) :: N
  INTEGER(KIND=JPIB_K) :: NUNDEF
  REAL(KIND=REAL64) :: MINVAL
  REAL(KIND=REAL64) :: MAXVAL
  REAL(KIND=REAL64) :: AVGVAL
  REAL(KIND=REAL64) :: XUNDEF
  LOGICAL :: VALEX

  N = UB-LB+1
  IF ( .NOT. ALLOCATED(GVALUES_DP) ) THEN
    ALLOCATE( GVALUES_DP(N) )
  ELSE
    IF ( SIZE(GVALUES_DP) .LT. N ) THEN
      DEALLOCATE(GVALUES_DP)
      ALLOCATE( GVALUES_DP(N) )
    ENDIF
  ENDIF
  VALUES(LB:UB) => GVALUES_DP(1:N)

  ! Read the message
  LOC_DIR = REPEAT( ' ', 1024 )
  WRITE(LOC_DIR,'(A,A,I6.6,A)') TRIM(DIRECTORY), '/io_serv.', PROC_ID, '.d'
  CALL VAL_CREATE_NAME( TRIM(LOC_DIR), MSG_ID, PROC_ID, VALFNAME )

  INQUIRE( FILE=TRIM(VALFNAME), EXIST=VALEX )

  IF ( .NOT.VALEX .OR. ADDR.LT.0 ) THEN
    SZ = SIZE(VALUES)
    CALL VAL_GENERATE_DP( SZ, MINVAL, MAXVAL, AVGVAL, NUNDEF, XUNDEF, VALUES )
  ELSE
    CALL VAL_ROPEN( VALFNAME, VALUNIT, BIG_ENDIAN_READ )
    CALL VAL_READ_DP( VALUNIT, ADDR, VALUES )
    CALL VAL_CLOSE( VALUNIT )
  ENDIF

  ! Exit point
  RETURN

END SUBROUTINE READ_VAL_DP


END MODULE OM_TOOL_UTILS_MOD