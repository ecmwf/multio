! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"


#define PP_FILE_NAME 'fortran_message_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'FORTRAN_MESSAGE_MOD'
MODULE FORTRAN_MESSAGE_MOD

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: ENUMERATORS_MOD,   ONLY: UNDEF_PARAM_E

IMPLICIT NONE

!> Default visibiliity of the module
PRIVATE

!>
TYPE :: FORTRAN_MESSAGE_T

  ! Default visibility of the type
  ! PRIVATE

  !> General information
  INTEGER(KIND=JPIB_K) :: STREAM   = UNDEF_PARAM_E
  INTEGER(KIND=JPIB_K) :: TYPE     = UNDEF_PARAM_E
  INTEGER(KIND=JPIB_K) :: CLASS    = UNDEF_PARAM_E
  CHARACTER(LEN=4)     :: EXPVER   = REPEAT('*',4)
  INTEGER(KIND=JPIB_K) :: ORIGIN   = UNDEF_PARAM_E  ! Centre
  INTEGER(KIND=JPIB_K) :: ANOFFSET = UNDEF_PARAM_E

  !> Packing information
  INTEGER(KIND=JPIB_K) :: PACKING = UNDEF_PARAM_E  ! packing type

  !> Ensemble information
  INTEGER(KIND=JPIB_K) :: NUMBER = UNDEF_PARAM_E  ! parturbation number

  !> Satellite information
  INTEGER(KIND=JPIB_K) :: IDENT = UNDEF_PARAM_E ! satellite identifier
  INTEGER(KIND=JPIB_K) :: INSTRUMENT = UNDEF_PARAM_E ! instrument identifier
  INTEGER(KIND=JPIB_K) :: CHANNEL = UNDEF_PARAM_E ! satellite channel number

  !> Field information
  INTEGER(KIND=JPIB_K) :: PARAM_TYPE = UNDEF_PARAM_E
  ! INTEGER(KIND=JPIB_K), DIMENSION(2) :: WAVELENGTH = [UNDEF_PARAM_E, UNDEF_PARAM_E]
  CHARACTER(LEN=32)    :: WAVELENGTH = REPEAT('*',32)
  INTEGER(KIND=JPIB_K) :: CHEM = UNDEF_PARAM_E
  INTEGER(KIND=JPIB_K) :: PARAM = UNDEF_PARAM_E
  INTEGER(KIND=JPIB_K) :: MODEL = UNDEF_PARAM_E !! Deprecated

  !> Level information
  INTEGER(KIND=JPIB_K) :: LEVTYPE = UNDEF_PARAM_E
  INTEGER(KIND=JPIB_K) :: LEVELIST = UNDEF_PARAM_E

  !> Frequency and direction information
  INTEGER(KIND=JPIB_K) :: DIRECTION = UNDEF_PARAM_E
  INTEGER(KIND=JPIB_K) :: FREQUENCY = UNDEF_PARAM_E

  !> Time information
  INTEGER(KIND=JPIB_K) :: DATE = UNDEF_PARAM_E
  INTEGER(KIND=JPIB_K) :: TIME = UNDEF_PARAM_E
  INTEGER(KIND=JPIB_K) :: STEP = UNDEF_PARAM_E
  INTEGER(KIND=JPIB_K) :: TIMEPROC = UNDEF_PARAM_E
  INTEGER(KIND=JPIB_K) :: HDATE = UNDEF_PARAM_E

  !> Grid information
  INTEGER(KIND=JPIB_K) :: REPRES = UNDEF_PARAM_E
  CHARACTER(LEN=8)     :: GRID = REPEAT('*',8)
  INTEGER(KIND=JPIB_K) :: TRUNCATION = UNDEF_PARAM_E
  ! INTEGER(KIND=JPIB_K), DIMENSION(2) :: ROTATION = [UNDEF_PARAM_E, UNDEF_PARAM_E]

CONTAINS

  !> Comparison operators
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: INIT           => FORTRAN_MESSAGE_INIT
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: COPY_FROM      => FORTRAN_MESSAGE_COPY_DATA_FROM
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: SWAP_DATA      => FORTRAN_MESSAGE_SWAP_DATA
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: READ_FROM_YAML => FORTRAN_MESSAGE_READ_FROM_YAML
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: IS_EQUAL_TO    => FORTRAN_MESSAGE_EQUAL_TO
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: IS_LOWER_THAN  => FORTRAN_MESSAGE_LOWER_THAN
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: FREE           => FORTRAN_MESSAGE_FREE

  !> Set fields by field ID/Key
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: SET_ENUM_INT    => FORTRAN_MESSAGE_SET_ENUM_INT
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: SET_KEY_INT     => FORTRAN_MESSAGE_SET_KEY_INT
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: SET_ENUM_STRING => FORTRAN_MESSAGE_SET_ENUM_STRING
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: SET_KEY_STRING  => FORTRAN_MESSAGE_SET_KEY_STRING
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: SET_ENUM_FLOAT  => FORTRAN_MESSAGE_SET_ENUM_FLOAT
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: SET_KEY_FLOAT   => FORTRAN_MESSAGE_SET_KEY_FLOAT
  GENERIC :: SET => SET_ENUM_INT
  GENERIC :: SET => SET_KEY_INT
  GENERIC :: SET => SET_ENUM_STRING
  GENERIC :: SET => SET_KEY_STRING
  GENERIC :: SET => SET_ENUM_FLOAT
  GENERIC :: SET => SET_KEY_FLOAT

  !> Get fields by field ID/Key
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: GET_ENUM_INT    => FORTRAN_MESSAGE_GET_ENUM_INT
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: GET_KEY_INT     => FORTRAN_MESSAGE_GET_KEY_INT
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: GET_ENUM_STRING => FORTRAN_MESSAGE_GET_ENUM_STRING
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: GET_KEY_STRING  => FORTRAN_MESSAGE_GET_KEY_STRING
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: GET_ENUM_FLOAT  => FORTRAN_MESSAGE_GET_ENUM_FLOAT
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: GET_KEY_FLOAT   => FORTRAN_MESSAGE_GET_KEY_FLOAT
  GENERIC :: GET => GET_ENUM_INT
  GENERIC :: GET => GET_KEY_INT
  GENERIC :: GET => GET_ENUM_STRING
  GENERIC :: GET => GET_KEY_STRING
  GENERIC :: GET => GET_ENUM_FLOAT
  GENERIC :: GET => GET_KEY_FLOAT

  !> Has fields by field ID/Key
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: HAS_ENUM => FORTRAN_MESSAGE_HAS_ENUM
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: HAS_KEY  => FORTRAN_MESSAGE_HAS_KEY
  GENERIC :: HAS => HAS_ENUM
  GENERIC :: HAS => HAS_KEY

  !> Set fields by field ID
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: PRINT => FORTRAN_MESSAGE_PRINT
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: TO_JSON => FORTRAN_MESSAGE_TO_JSON
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: TO_STRING => FORTRAN_MESSAGE_TO_STRING
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: WRITE_TO_YAML => FORTRAN_MESSAGE_TO_YAML

END TYPE

!> Whitelist of public symbols (types)
PUBLIC :: FORTRAN_MESSAGE_T

CONTAINS


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_INIT'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_INIT( THIS, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T),     INTENT(INOUT) :: THIS
  TYPE(HOOKS_T),                INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Integer members
  THIS%STREAM     = UNDEF_PARAM_E
  THIS%TYPE       = UNDEF_PARAM_E
  THIS%CLASS      = UNDEF_PARAM_E
  THIS%ORIGIN     = UNDEF_PARAM_E
  THIS%ANOFFSET   = UNDEF_PARAM_E
  THIS%PACKING    = UNDEF_PARAM_E
  THIS%NUMBER     = UNDEF_PARAM_E
  THIS%IDENT      = UNDEF_PARAM_E
  THIS%INSTRUMENT = UNDEF_PARAM_E
  THIS%CHANNEL    = UNDEF_PARAM_E
  THIS%PARAM_TYPE = UNDEF_PARAM_E
  THIS%CHEM       = UNDEF_PARAM_E
  THIS%PARAM      = UNDEF_PARAM_E
  THIS%MODEL      = UNDEF_PARAM_E
  THIS%LEVTYPE    = UNDEF_PARAM_E
  THIS%LEVELIST   = UNDEF_PARAM_E
  THIS%DIRECTION  = UNDEF_PARAM_E
  THIS%FREQUENCY  = UNDEF_PARAM_E
  THIS%DATE       = UNDEF_PARAM_E
  THIS%TIME       = UNDEF_PARAM_E
  THIS%STEP       = UNDEF_PARAM_E
  THIS%REPRES     = UNDEF_PARAM_E
  THIS%TRUNCATION = UNDEF_PARAM_E
  THIS%HDATE       = UNDEF_PARAM_E

  !> String members
  THIS%TIMEPROC = UNDEF_PARAM_E
  THIS%EXPVER   = REPEAT('*',4)
  THIS%GRID     = REPEAT('*',8)

  ! THIS%WAVELENGTH(1) = UNDEF_PARAM_E
  ! THIS%WAVELENGTH(2) = UNDEF_PARAM_E
  THIS%WAVELENGTH = REPEAT('*',32)


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_INIT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_FREE'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_FREE( THIS, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T),     INTENT(INOUT) :: THIS
  TYPE(HOOKS_T),                INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Reset to default values
  THIS%STREAM     = UNDEF_PARAM_E
  THIS%TYPE       = UNDEF_PARAM_E
  THIS%CLASS      = UNDEF_PARAM_E
  THIS%ORIGIN     = UNDEF_PARAM_E
  THIS%ANOFFSET   = UNDEF_PARAM_E
  THIS%PACKING    = UNDEF_PARAM_E
  THIS%NUMBER     = UNDEF_PARAM_E
  THIS%IDENT      = UNDEF_PARAM_E
  THIS%INSTRUMENT = UNDEF_PARAM_E
  THIS%CHANNEL    = UNDEF_PARAM_E
  THIS%PARAM_TYPE = UNDEF_PARAM_E
  THIS%CHEM       = UNDEF_PARAM_E
  THIS%PARAM      = UNDEF_PARAM_E
  THIS%MODEL      = UNDEF_PARAM_E
  THIS%LEVTYPE    = UNDEF_PARAM_E
  THIS%LEVELIST   = UNDEF_PARAM_E
  THIS%DIRECTION  = UNDEF_PARAM_E
  THIS%FREQUENCY  = UNDEF_PARAM_E
  THIS%DATE       = UNDEF_PARAM_E
  THIS%TIME       = UNDEF_PARAM_E
  THIS%STEP       = UNDEF_PARAM_E
  THIS%REPRES     = UNDEF_PARAM_E
  THIS%TRUNCATION = UNDEF_PARAM_E
  THIS%TIMEPROC   = UNDEF_PARAM_E
  THIS%HDATE       = UNDEF_PARAM_E

  THIS%EXPVER   = REPEAT('*',4)
  THIS%GRID     = REPEAT('*',8)

  ! THIS%WAVELENGTH(1) = UNDEF_PARAM_E
  ! THIS%WAVELENGTH(2) = UNDEF_PARAM_E
  THIS%WAVELENGTH = REPEAT('*',32)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_FREE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_PRINT'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_PRINT( THIS, UNIT, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPRD_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: ENUMERATORS_MOD,          ONLY: UNDEF_PARAM_E
  USE :: ENUMERATORS_MOD,          ONLY: ISTREAM2CSTREAM
  USE :: ENUMERATORS_MOD,          ONLY: ITYPE2CTYPE
  USE :: ENUMERATORS_MOD,          ONLY: ICLASS2CCLASS
  USE :: ENUMERATORS_MOD,          ONLY: IPACKING2CPACKING
  USE :: ENUMERATORS_MOD,          ONLY: IPARAMTYPE2CPARAMTYPE
  USE :: ENUMERATORS_MOD,          ONLY: ILEVTYPE2CLEVTYPE
  USE :: ENUMERATORS_MOD,          ONLY: IREPRES2CREPRES
  USE :: DATETIME_UTILS_MOD,       ONLY: HHMMSS2STRING
  USE :: DATETIME_UTILS_MOD,       ONLY: YYYYMMDD2STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: UNIT
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local parameters
  CHARACTER(LEN=32)    :: CTMP
  INTEGER(KIND=JPIB_K) :: WRITE_STAT

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IOSTATUS_NOT_ZERO=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ISTREAM2CSTREAM=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ITYPE2CTYPE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ICLASS2CCLASS=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPACKING2CPACKING=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPARAMTYPE2CPARAMTYPE=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ILEVTYPE2CLEVTYPE=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IREPRES2CREPRES=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DATE_TO_STRING=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_TIME_TO_STRING=10_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) '** MESSAGE PRINT'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )

  ! Print Stream
  IF ( THIS%STREAM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ISTREAM2CSTREAM) ISTREAM2CSTREAM( THIS%STREAM, CTMP(1:8), HOOKS )
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - STREAM......: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print Type
  IF ( THIS%TYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ITYPE2CTYPE) ITYPE2CTYPE( THIS%TYPE, CTMP, HOOKS )
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - TYPE........: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print Class
  IF ( THIS%CLASS .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ICLASS2CCLASS) ICLASS2CCLASS( THIS%CLASS, CTMP(1:8), HOOKS )
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - CLASS.......: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print Expver
  IF ( THIS%EXPVER .NE. '****' ) THEN
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - EXPVER......: ', TRIM(ADJUSTL(THIS%EXPVER))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print PACKING
  IF ( THIS%PACKING .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_IPACKING2CPACKING) IPACKING2CPACKING( THIS%PACKING, CTMP(1:16), HOOKS )
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - PACKING.....: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print NUMBER
  IF ( THIS%NUMBER .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%NUMBER
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - NUMBER......: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print IDENT
  IF ( THIS%IDENT .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%IDENT
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - IDENT.......: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print INSTRUMENT
  IF ( THIS%INSTRUMENT .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%INSTRUMENT
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - INSTRUMENT..: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print CHANNEL
  IF ( THIS%CHANNEL .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%CHANNEL
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - CHANNEL.....: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print PARAM_TYPE
  IF ( THIS%PARAM_TYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_IPARAMTYPE2CPARAMTYPE) IPARAMTYPE2CPARAMTYPE( THIS%PARAM_TYPE, CTMP(1:16), HOOKS )
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - PARAM_TYPE..: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print CHEM
  IF ( THIS%CHEM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%CHEM
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - CHEM......: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! ! Print Wavelength
  IF ( THIS%WAVELENGTH .NE. REPEAT('*', 32) ) THEN
    ! CTMP = REPEAT(' ',32)
    ! WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%WAVELENGTH
    ! WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - WAVELENGTH......: ', TRIM(ADJUSTL(CTMP))
    ! PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - WAVELENGTH........: ', TRIM(ADJUSTL(THIS%WAVELENGTH))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print PARAM
  IF ( THIS%PARAM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%PARAM
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - PARAM......: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print LEVTYPE
  IF ( THIS%LEVTYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ILEVTYPE2CLEVTYPE) ILEVTYPE2CLEVTYPE( THIS%LEVTYPE, CTMP(1:16), HOOKS )
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - LEVTYPE.....: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print LEVELIST
  IF ( THIS%LEVELIST .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%LEVELIST
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - LEVELIST....: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print DIRECTION
  IF ( THIS%DIRECTION .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%DIRECTION
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - DIRECTION...: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print FREQUENCY
  IF ( THIS%FREQUENCY .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%FREQUENCY
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - FREQUENCY...: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print DATE
  IF ( THIS%DATE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_DATE_TO_STRING) YYYYMMDD2STRING( THIS%DATE, CTMP(1:10), HOOKS )
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - DATE...: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print TIME
  IF ( THIS%TIME .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_TIME_TO_STRING) HHMMSS2STRING( THIS%TIME, CTMP(1:8), HOOKS )
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - TIME...: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print STEP
  IF ( THIS%STEP .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%STEP
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - STEP...: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print TIMEPROC
  IF ( THIS%TIMEPROC .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%TIMEPROC
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - TIMEPROC....: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print HDATE
  IF ( THIS%HDATE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_DATE_TO_STRING) YYYYMMDD2STRING( THIS%HDATE, CTMP(1:10), HOOKS )
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - HDATE...: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF


  ! Print REPRES
  IF ( THIS%REPRES .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ILEVTYPE2CLEVTYPE) IREPRES2CREPRES( THIS%REPRES, CTMP(1:16), HOOKS )
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - REPRES......: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print GRID
  IF ( THIS%GRID .NE. '********' ) THEN
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - GRID........: ', TRIM(ADJUSTL(THIS%GRID))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print TRUNCATION
  IF ( THIS%TRUNCATION .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%TRUNCATION
    WRITE(UNIT,'(A,A)',IOSTAT=WRITE_STAT) ' - TRUNCATION..: ', TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DATE_TO_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'YYYYMMDD2STRING failed' )
    CASE (ERRFLAG_TIME_TO_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'HHMMSS2STRING failed' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_PRINT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_TO_JSON'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_TO_JSON( THIS, OUT_JSON, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPRD_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: ENUMERATORS_MOD,          ONLY: UNDEF_PARAM_E
  USE :: ENUMERATORS_MOD,          ONLY: ISTREAM2CSTREAM
  USE :: ENUMERATORS_MOD,          ONLY: ITYPE2CTYPE
  USE :: ENUMERATORS_MOD,          ONLY: ICLASS2CCLASS
  USE :: ENUMERATORS_MOD,          ONLY: IPACKING2CPACKING
  USE :: ENUMERATORS_MOD,          ONLY: IPARAMTYPE2CPARAMTYPE
  USE :: ENUMERATORS_MOD,          ONLY: ILEVTYPE2CLEVTYPE
  USE :: ENUMERATORS_MOD,          ONLY: IREPRES2CREPRES
  USE :: DATETIME_UTILS_MOD,       ONLY: HHMMSS2STRING
  USE :: DATETIME_UTILS_MOD,       ONLY: YYYYMMDD2STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T),      INTENT(IN)    :: THIS
  CHARACTER(LEN=:), ALLOCATABLE, INTENT(INOUT) :: OUT_JSON
  TYPE(HOOKS_T),                 INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=32) :: CTMP
  CHARACTER(LEN=128), DIMENSION(32) :: JSON
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: CNT
  INTEGER(KIND=JPIB_K) :: LO
  INTEGER(KIND=JPIB_K) :: HI
  INTEGER(KIND=JPIB_K) :: ALLOC_STAT
  INTEGER(KIND=JPIB_K) :: WRITE_STAT
  INTEGER(KIND=JPIB_K) :: TOTLEN
  CHARACTER(LEN=2) :: SEP
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IOSTATUS_NOT_ZERO=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ISTREAM2CSTREAM=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ITYPE2CTYPE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ICLASS2CCLASS=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPACKING2CPACKING=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPARAMTYPE2CPARAMTYPE=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ILEVTYPE2CLEVTYPE=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IREPRES2CREPRES=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OUT_OF_BOUNDS=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ALLOCATE=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DATE_TO_STRING=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_TIME_TO_STRING=12_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization
  CNT = 0_JPIB_K
  TOTLEN = 8_JPIB_K

  ! Print Stream
  IF ( THIS%STREAM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ISTREAM2CSTREAM) ISTREAM2CSTREAM( THIS%STREAM, CTMP(1:8), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"stream":"'//TRIM(ADJUSTL(CTMP))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print Type
  IF ( THIS%TYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ITYPE2CTYPE) ITYPE2CTYPE( THIS%TYPE, CTMP, HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"type":"'//TRIM(ADJUSTL(CTMP))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print Class
  IF ( THIS%CLASS .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ICLASS2CCLASS) ICLASS2CCLASS( THIS%CLASS, CTMP(1:8), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"class":"'//TRIM(ADJUSTL(CTMP))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print Expver
  IF ( THIS%EXPVER .NE. '****' ) THEN
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"expver":"'//TRIM(ADJUSTL(THIS%EXPVER))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print Anoffset
  IF ( THIS%ANOFFSET .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%ANOFFSET
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"anoffset":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print Origin
  IF ( THIS%ORIGIN .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%ORIGIN
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"origin":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print PACKING
  IF ( THIS%PACKING .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_IPACKING2CPACKING) IPACKING2CPACKING( THIS%PACKING, CTMP(1:16), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"packing":"'//TRIM(ADJUSTL(CTMP))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print NUMBER
  IF ( THIS%NUMBER .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%NUMBER
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"number":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print IDENT
  IF ( THIS%IDENT .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%IDENT
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"ident":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print INSTRUMENT
  IF ( THIS%INSTRUMENT .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%INSTRUMENT
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"instrument":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print CHANNEL
  IF ( THIS%CHANNEL .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%CHANNEL
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"channel":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print PARAM_TYPE
  IF ( THIS%PARAM_TYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_IPARAMTYPE2CPARAMTYPE) IPARAMTYPE2CPARAMTYPE( THIS%PARAM_TYPE, CTMP(1:16), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"paramtype":"'//TRIM(ADJUSTL(CTMP))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print CHEM
  IF ( THIS%CHEM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%CHEM
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"chem":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print WAVELENGTH
  IF ( THIS%WAVELENGTH .NE. REPEAT('*',32) ) THEN
    ! CTMP = REPEAT(' ',32)
    ! WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%WAVELENGTH
    ! CNT = CNT + 1
    ! JSON(CNT) = REPEAT(' ',128)
    ! JSON(CNT) = '"wavelength":'//TRIM(ADJUSTL(CTMP))
    ! TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"wavelength":"'//TRIM(ADJUSTL(THIS%WAVELENGTH))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print PARAM
  IF ( THIS%PARAM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%PARAM
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"param":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print LEVTYPE
  IF ( THIS%LEVTYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ILEVTYPE2CLEVTYPE) ILEVTYPE2CLEVTYPE( THIS%LEVTYPE, CTMP(1:16), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"levtype":"'//TRIM(ADJUSTL(CTMP))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print LEVELIST
  IF ( THIS%LEVELIST .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%LEVELIST
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"levelist":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print DIRECTION
  IF ( THIS%DIRECTION .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%DIRECTION
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"direction":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print FREQUENCY
  IF ( THIS%FREQUENCY .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%FREQUENCY
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"frequency":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print DATE
  IF ( THIS%DATE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_DATE_TO_STRING) YYYYMMDD2STRING( THIS%DATE, CTMP(1:10), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"date":"'//TRIM(ADJUSTL(CTMP))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print TIME
  IF ( THIS%TIME .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_TIME_TO_STRING) HHMMSS2STRING( THIS%TIME, CTMP(1:8), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"time":"'//TRIM(ADJUSTL(CTMP))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print STEP
  IF ( THIS%STEP .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%STEP
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"step":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print TIMEPROC
  IF ( THIS%TIMEPROC .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%TIMEPROC
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"timeproc":"'//TRIM(ADJUSTL(CTMP))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print DATE
  IF ( THIS%HDATE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_DATE_TO_STRING) YYYYMMDD2STRING( THIS%HDATE, CTMP(1:10), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"hdate":"'//TRIM(ADJUSTL(CTMP))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print REPRES
  IF ( THIS%REPRES .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_IREPRES2CREPRES) IREPRES2CREPRES( THIS%REPRES, CTMP(1:16), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"repres":"'//TRIM(ADJUSTL(CTMP))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print GRID
  IF ( THIS%GRID .NE. '********' ) THEN
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"grid":"'//TRIM(ADJUSTL(THIS%GRID))//'"'
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print TRUNCATION
  IF ( THIS%TRUNCATION .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%TRUNCATION
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = '"truncation":'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Add the final parenthesis
  TOTLEN = TOTLEN + 2_JPIB_K

  ! Allocate the output JSON string
  ALLOCATE( CHARACTER(LEN=TOTLEN)::OUT_JSON, STAT=ALLOC_STAT, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STAT .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )

  ! Concatenate the JSON strings to a single string
  LO=1_JPIB_K
  HI=8_JPIB_K
  OUT_JSON = REPEAT( ' ', TOTLEN )
  OUT_JSON(1:8) = 'message:'
  SEP='{ '
  DO I = 1, CNT
    LO=HI+1
    HI=LO+LEN(TRIM(ADJUSTL(JSON(I))))+1
    PP_DEBUG_CRITICAL_COND_THROW( HI.GT.TOTLEN, ERRFLAG_OUT_OF_BOUNDS )
    OUT_JSON(LO:HI) = SEP//TRIM(ADJUSTL(JSON(I)))
    SEP=', '
  ENDDO
  LO=HI+1
  HI=LO+2-1
  OUT_JSON(LO:HI) = ' }'

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_IOSTATUS_NOT_ZERO)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'I/O status not zero' )
    CASE (ERRFLAG_ISTREAM2CSTREAM)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'ISTREAM2CSTREAM failed' )
    CASE (ERRFLAG_ITYPE2CTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'ITYPE2CTYPE failed' )
    CASE (ERRFLAG_ICLASS2CCLASS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'ICLASS2CCLASS failed' )
    CASE (ERRFLAG_IPACKING2CPACKING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'IPACKING2CPACKING failed' )
    CASE (ERRFLAG_IPARAMTYPE2CPARAMTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'IPARAMTYPE2CPARAMTYPE failed' )
    CASE (ERRFLAG_ILEVTYPE2CLEVTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'ILEVTYPE2CLEVTYPE failed' )
    CASE (ERRFLAG_IREPRES2CREPRES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'IREPRES2CREPRES failed' )
    CASE (ERRFLAG_OUT_OF_BOUNDS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Out of bounds' )
    CASE (ERRFLAG_UNABLE_TO_ALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to allocate' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error message: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE( ERRMSG, STAT=ALLOC_STAT )
      END IF
    CASE (ERRFLAG_DATE_TO_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'YYYYMMDD2STRING failed' )
    CASE (ERRFLAG_TIME_TO_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'HHMMSS2STRING failed' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_TO_JSON
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_TO_STRING'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_TO_STRING( THIS, OUT_JSON, HOOKS, PREFIX, EXTENSION ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPRD_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: ENUMERATORS_MOD,          ONLY: UNDEF_PARAM_E
  USE :: ENUMERATORS_MOD,          ONLY: ISTREAM2CSTREAM
  USE :: ENUMERATORS_MOD,          ONLY: ITYPE2CTYPE
  USE :: ENUMERATORS_MOD,          ONLY: ICLASS2CCLASS
  USE :: ENUMERATORS_MOD,          ONLY: IPACKING2CPACKING
  USE :: ENUMERATORS_MOD,          ONLY: IPARAMTYPE2CPARAMTYPE
  USE :: ENUMERATORS_MOD,          ONLY: ILEVTYPE2CLEVTYPE
  USE :: ENUMERATORS_MOD,          ONLY: IREPRES2CREPRES
  USE :: DATETIME_UTILS_MOD,       ONLY: HHMMSS2STRING
  USE :: DATETIME_UTILS_MOD,       ONLY: YYYYMMDD2STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T),      INTENT(IN)    :: THIS
  CHARACTER(LEN=:), ALLOCATABLE, INTENT(INOUT) :: OUT_JSON
  TYPE(HOOKS_T),                 INTENT(INOUT) :: HOOKS
  CHARACTER(LEN=*), OPTIONAL,    INTENT(IN)    :: PREFIX
  CHARACTER(LEN=*), OPTIONAL,    INTENT(IN)    :: EXTENSION

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=32) :: CTMP
  CHARACTER(LEN=128), DIMENSION(32) :: JSON
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: CNT
  INTEGER(KIND=JPIB_K) :: LO
  INTEGER(KIND=JPIB_K) :: HI
  INTEGER(KIND=JPIB_K) :: ALLOC_STAT
  INTEGER(KIND=JPIB_K) :: WRITE_STAT
  INTEGER(KIND=JPIB_K) :: TOTLEN
  CHARACTER(LEN=1) :: SEP
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IOSTATUS_NOT_ZERO=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ISTREAM2CSTREAM=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ITYPE2CTYPE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ICLASS2CCLASS=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPACKING2CPACKING=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPARAMTYPE2CPARAMTYPE=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ILEVTYPE2CLEVTYPE=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IREPRES2CREPRES=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OUT_OF_BOUNDS=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ALLOCATE=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DATE_TO_STRING=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_TIME_TO_STRING=12_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization
  CNT = 0_JPIB_K

  ! Calculate the total length of the prefix
  IF ( PRESENT(PREFIX) ) THEN
    TOTLEN = LEN(TRIM(ADJUSTL(PREFIX))) + 1_JPIB_K
  ELSE
    TOTLEN = 0_JPIB_K
  ENDIF

  ! Print Stream
  IF ( THIS%STREAM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ISTREAM2CSTREAM) ISTREAM2CSTREAM( THIS%STREAM, CTMP(1:8), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'stream-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print Type
  IF ( THIS%TYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ITYPE2CTYPE) ITYPE2CTYPE( THIS%TYPE, CTMP, HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'type-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print Class
  IF ( THIS%CLASS .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ICLASS2CCLASS) ICLASS2CCLASS( THIS%CLASS, CTMP(1:8), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'class-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print Expver
  IF ( THIS%EXPVER .NE. '****' ) THEN
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'expver-'//TRIM(ADJUSTL(THIS%EXPVER))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print Anoffset
  IF ( THIS%ANOFFSET .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%ANOFFSET
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'anoffset-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print Origin
  IF ( THIS%ORIGIN .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%ORIGIN
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'origin-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 2
  ENDIF

  ! Print PACKING
  IF ( THIS%PACKING .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_IPACKING2CPACKING) IPACKING2CPACKING( THIS%PACKING, CTMP(1:16), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'packing-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print NUMBER
  IF ( THIS%NUMBER .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%NUMBER
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'number-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print IDENT
  IF ( THIS%IDENT .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%IDENT
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'ident-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print INSTRUMENT
  IF ( THIS%INSTRUMENT .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%INSTRUMENT
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'instrument-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print CHANNEL
  IF ( THIS%CHANNEL .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%CHANNEL
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'channel-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print PARAM_TYPE
  IF ( THIS%PARAM_TYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_IPARAMTYPE2CPARAMTYPE) IPARAMTYPE2CPARAMTYPE( THIS%PARAM_TYPE, CTMP(1:16), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'paramtype-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print CHEM
  IF ( THIS%CHEM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%CHEM
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'chem-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! ! Print Wavelength
  IF ( THIS%WAVELENGTH .NE. REPEAT('*', 32) ) THEN
    ! CTMP = REPEAT(' ',32)
    ! WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%WAVELENGTH
    ! CNT = CNT + 1
    ! JSON(CNT) = REPEAT(' ',128)
    ! JSON(CNT) = 'wavelength-'//TRIM(ADJUSTL(CTMP))
    ! TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'wavelength-'//TRIM(ADJUSTL(THIS%WAVELENGTH))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print PARAM
  IF ( THIS%PARAM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%PARAM
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'param-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print LEVTYPE
  IF ( THIS%LEVTYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ILEVTYPE2CLEVTYPE) ILEVTYPE2CLEVTYPE( THIS%LEVTYPE, CTMP(1:16), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'levtype-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print LEVELIST
  IF ( THIS%LEVELIST .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%LEVELIST
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'levelist-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print DIRECTION
  IF ( THIS%DIRECTION .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%DIRECTION
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'direction-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print FREQUENCY
  IF ( THIS%FREQUENCY .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%FREQUENCY
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'frequency-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print DATE
  IF ( THIS%DATE .NE. UNDEF_PARAM_E ) THEN
    ! CTMP = REPEAT(' ',32)
    ! PP_TRYCALL(ERRFLAG_DATE_TO_STRING) YYYYMMDD2STRING( THIS%DATE, CTMP(1:10), HOOKS )
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT)  THIS%DATE
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'date-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print TIME
  IF ( THIS%TIME .NE. UNDEF_PARAM_E ) THEN
    ! CTMP = REPEAT(' ',32)
    ! PP_TRYCALL(ERRFLAG_TIME_TO_STRING) HHMMSS2STRING( THIS%TIME, CTMP(1:8), HOOKS )
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT)  THIS%TIME
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'time-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print STEP
  IF ( THIS%STEP .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%STEP
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'step-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print TIMEPROC
  IF ( THIS%TIMEPROC .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%TIMEPROC
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'timeproc-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print HDATE
  IF ( THIS%HDATE .NE. UNDEF_PARAM_E ) THEN
    ! CTMP = REPEAT(' ',32)
    ! PP_TRYCALL(ERRFLAG_DATE_TO_STRING) YYYYMMDD2STRING( THIS%HDATE, CTMP(1:10), HOOKS )
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT)  THIS%HDATE
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'hdate-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print REPRES
  IF ( THIS%REPRES .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_IREPRES2CREPRES) IREPRES2CREPRES( THIS%REPRES, CTMP(1:16), HOOKS )
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'repres-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print GRID
  IF ( THIS%GRID .NE. '********' ) THEN
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'grid-'//TRIM(ADJUSTL(THIS%GRID))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT)))) + 1
  ENDIF

  ! Print TRUNCATION
  IF ( THIS%TRUNCATION .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%TRUNCATION
    CNT = CNT + 1
    JSON(CNT) = REPEAT(' ',128)
    JSON(CNT) = 'truncation-'//TRIM(ADJUSTL(CTMP))
    TOTLEN = TOTLEN + LEN(TRIM(ADJUSTL(JSON(CNT))))
  ENDIF

  ! Add the extension
  IF ( PRESENT(EXTENSION) ) THEN
    TOTLEN = TOTLEN + LEN_TRIM(ADJUSTL(EXTENSION)) + 1
  ENDIF

  ! Allocate the output JSON string
  ALLOCATE( CHARACTER(LEN=TOTLEN)::OUT_JSON, STAT=ALLOC_STAT, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STAT .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )

  ! Concatenate the JSON strings to a single string
  LO=0_JPIB_K
  HI=0_JPIB_K
  OUT_JSON = REPEAT( ' ', TOTLEN )

  IF ( PRESENT(PREFIX) ) THEN
    LO=1_JPIB_K
    HI=LEN_TRIM(ADJUSTL(PREFIX))+1
    PP_DEBUG_CRITICAL_COND_THROW( HI.GT.TOTLEN, ERRFLAG_OUT_OF_BOUNDS )
    OUT_JSON(LO:HI) = TRIM(ADJUSTL(PREFIX))//'/'
  ENDIF

  SEP='_'
  I = 1
  LO=HI+1
  HI=LO+LEN(TRIM(ADJUSTL(JSON(I)))) - 1_JPIB_K
  PP_DEBUG_CRITICAL_COND_THROW( HI.GT.TOTLEN, ERRFLAG_OUT_OF_BOUNDS )
  OUT_JSON(LO:HI) = TRIM(ADJUSTL(JSON(I)))
  IF ( CNT .GT. 1 ) THEN
    DO I = 2, CNT
      LO=HI+1
      HI=LO+LEN(TRIM(ADJUSTL(JSON(I))))
      PP_DEBUG_CRITICAL_COND_THROW( HI.GT.TOTLEN, ERRFLAG_OUT_OF_BOUNDS )
      OUT_JSON(LO:HI) = SEP//TRIM(ADJUSTL(JSON(I)))
    ENDDO
  ENDIF

  IF ( PRESENT(EXTENSION) ) THEN
    LO=HI+1
    HI=LO+LEN_TRIM(ADJUSTL(EXTENSION))
    PP_DEBUG_CRITICAL_COND_THROW( HI.GT.TOTLEN, ERRFLAG_OUT_OF_BOUNDS )
    OUT_JSON(LO:HI) = '.'//TRIM(ADJUSTL(EXTENSION))
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_IOSTATUS_NOT_ZERO)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'I/O status not zero' )
    CASE (ERRFLAG_ISTREAM2CSTREAM)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'ISTREAM2CSTREAM failed' )
    CASE (ERRFLAG_ITYPE2CTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'ITYPE2CTYPE failed' )
    CASE (ERRFLAG_ICLASS2CCLASS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'ICLASS2CCLASS failed' )
    CASE (ERRFLAG_IPACKING2CPACKING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'IPACKING2CPACKING failed' )
    CASE (ERRFLAG_IPARAMTYPE2CPARAMTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'IPARAMTYPE2CPARAMTYPE failed' )
    CASE (ERRFLAG_ILEVTYPE2CLEVTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'ILEVTYPE2CLEVTYPE failed' )
    CASE (ERRFLAG_IREPRES2CREPRES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'IREPRES2CREPRES failed' )
    CASE (ERRFLAG_OUT_OF_BOUNDS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Out of bounds' )
    CASE (ERRFLAG_UNABLE_TO_ALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to allocate' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error message: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE( ERRMSG, STAT=ALLOC_STAT )
      END IF
    CASE (ERRFLAG_DATE_TO_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'YYYYMMDD2STRING failed' )
    CASE (ERRFLAG_TIME_TO_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'HHMMSS2STRING failed' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_TO_STRING
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_COPY_DATA_FROM'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_COPY_DATA_FROM( THIS, OTHER, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T),     INTENT(INOUT) :: THIS
  TYPE(FORTRAN_MESSAGE_T),      INTENT(IN)    :: OTHER
  TYPE(HOOKS_T),                INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Reset to default values
  THIS%STREAM     = OTHER%STREAM
  THIS%TYPE       = OTHER%TYPE
  THIS%CLASS      = OTHER%CLASS
  THIS%EXPVER     = OTHER%EXPVER
  THIS%ORIGIN     = OTHER%ORIGIN
  THIS%ANOFFSET   = OTHER%ANOFFSET

  THIS%PACKING    = OTHER%PACKING

  THIS%NUMBER     = OTHER%NUMBER

  THIS%IDENT      = OTHER%IDENT
  THIS%INSTRUMENT = OTHER%INSTRUMENT
  THIS%CHANNEL    = OTHER%CHANNEL

  THIS%PARAM_TYPE = OTHER%PARAM_TYPE
  THIS%CHEM       = OTHER%CHEM
  ! THIS%WAVELENGTH(1) = OTHER%WAVELENGTH(1)
  ! THIS%WAVELENGTH(2) = OTHER%WAVELENGTH(2)
  THIS%WAVELENGTH = OTHER%WAVELENGTH
  THIS%PARAM      = OTHER%PARAM
  THIS%MODEL      = OTHER%MODEL

  THIS%LEVTYPE    = OTHER%LEVTYPE
  THIS%LEVELIST   = OTHER%LEVELIST

  THIS%DIRECTION  = OTHER%DIRECTION
  THIS%FREQUENCY  = OTHER%FREQUENCY

  THIS%DATE       = OTHER%DATE
  THIS%TIME       = OTHER%TIME
  THIS%STEP       = OTHER%STEP
  THIS%HDATE      = OTHER%HDATE

  THIS%TIMEPROC   = OTHER%TIMEPROC
  THIS%REPRES     = OTHER%REPRES
  THIS%GRID       = OTHER%GRID
  THIS%TRUNCATION = OTHER%TRUNCATION

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_COPY_DATA_FROM
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_SWAP_DATA'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_SWAP_DATA( THIS, OTHER, OPT, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: CACHE_UTILS_MOD,   ONLY: CACHE_OPTIONS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T),     INTENT(INOUT) :: THIS
  TYPE(FORTRAN_MESSAGE_T),      INTENT(INOUT) :: OTHER
  TYPE(CACHE_OPTIONS_T),        INTENT(IN)    :: OPT
  TYPE(HOOKS_T),                INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: ITMP
  CHARACTER(LEN=4)     :: CTMP4
  CHARACTER(LEN=8)     :: CTMP8
  CHARACTER(LEN=32)    :: CTMP32

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Swap data
  ITMP         = THIS%STREAM
  THIS%STREAM  = OTHER%STREAM
  OTHER%STREAM = ITMP

  ITMP       = THIS%TYPE
  THIS%TYPE  = OTHER%TYPE
  OTHER%TYPE = ITMP

  ITMP        = THIS%CLASS
  THIS%CLASS  = OTHER%CLASS
  OTHER%CLASS = ITMP

  CTMP4        = THIS%EXPVER
  THIS%EXPVER  = OTHER%EXPVER
  OTHER%EXPVER = CTMP4

  ITMP         = THIS%ORIGIN
  THIS%ORIGIN  = OTHER%ORIGIN
  OTHER%ORIGIN = ITMP

  ITMP           = THIS%ANOFFSET
  THIS%ANOFFSET  = OTHER%ANOFFSET
  OTHER%ANOFFSET = ITMP



  ITMP          = THIS%PACKING
  THIS%PACKING  = OTHER%PACKING
  OTHER%PACKING = ITMP



  ITMP         = THIS%NUMBER
  THIS%NUMBER  = OTHER%NUMBER
  OTHER%NUMBER = ITMP

  ITMP        = THIS%IDENT
  THIS%IDENT  = OTHER%IDENT
  OTHER%IDENT = ITMP

  ITMP             = THIS%INSTRUMENT
  THIS%INSTRUMENT  = OTHER%INSTRUMENT
  OTHER%INSTRUMENT = ITMP

  ITMP          = THIS%CHANNEL
  THIS%CHANNEL  = OTHER%CHANNEL
  OTHER%CHANNEL = ITMP



  ITMP             = THIS%PARAM_TYPE
  THIS%PARAM_TYPE  = OTHER%PARAM_TYPE
  OTHER%PARAM_TYPE = ITMP

  ITMP       = THIS%CHEM
  THIS%CHEM  = OTHER%CHEM
  OTHER%CHEM = ITMP

  ! ITMP       = THIS%WAVELENGTH(1)
  ! THIS%WAVELENGTH(1)  = OTHER%WAVELENGTH(1)
  ! OTHER%WAVELENGTH(1) = ITMP
  ! ITMP       = THIS%WAVELENGTH(2)
  ! THIS%WAVELENGTH(2)  = OTHER%WAVELENGTH(2)
  ! OTHER%WAVELENGTH(2) = ITMP
  CTMP32      = THIS%WAVELENGTH
  THIS%WAVELENGTH  = OTHER%WAVELENGTH
  OTHER%WAVELENGTH = CTMP32

  ITMP        = THIS%PARAM
  THIS%PARAM  = OTHER%PARAM
  OTHER%PARAM = ITMP

  ITMP        = THIS%MODEL
  THIS%MODEL  = OTHER%MODEL
  OTHER%MODEL =ITMP



  ITMP          = THIS%LEVTYPE
  THIS%LEVTYPE  = OTHER%LEVTYPE
  OTHER%LEVTYPE = ITMP

  ITMP           = THIS%LEVELIST
  THIS%LEVELIST  = OTHER%LEVELIST
  OTHER%LEVELIST = ITMP



  ITMP            = THIS%DIRECTION
  THIS%DIRECTION  = OTHER%DIRECTION
  OTHER%DIRECTION = ITMP

  ITMP            = THIS%FREQUENCY
  THIS%FREQUENCY  = OTHER%FREQUENCY
  OTHER%FREQUENCY = ITMP



  ITMP       = THIS%DATE
  THIS%DATE  = OTHER%DATE
  OTHER%DATE = ITMP

  ITMP       = THIS%HDATE
  THIS%HDATE  = OTHER%HDATE
  OTHER%HDATE = ITMP

  ITMP       = THIS%TIME
  THIS%TIME  = OTHER%TIME
  OTHER%TIME = ITMP

  ITMP       = THIS%STEP
  THIS%STEP  = OTHER%STEP
  OTHER%STEP = ITMP

  ITMP           = THIS%TIMEPROC
  THIS%TIMEPROC  = OTHER%TIMEPROC
  OTHER%TIMEPROC = ITMP




  ITMP         = THIS%REPRES
  THIS%REPRES  = OTHER%REPRES
  OTHER%REPRES = ITMP

  CTMP8      = THIS%GRID
  THIS%GRID  = OTHER%GRID
  OTHER%GRID = CTMP8

  ITMP             = THIS%TRUNCATION
  THIS%TRUNCATION  = OTHER%TRUNCATION
  OTHER%TRUNCATION = ITMP


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_SWAP_DATA
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_EQUAL_TO'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_EQUAL_TO( THIS, OTHER, OPT, IS_EQUAL, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: CACHE_UTILS_MOD,   ONLY: CACHE_OPTIONS_T
  USE :: ENUMERATORS_MOD,   ONLY: LEVTYPE_ML_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(IN)    :: THIS
  TYPE(FORTRAN_MESSAGE_T),  INTENT(IN)    :: OTHER
  TYPE(CACHE_OPTIONS_T),    INTENT(IN)    :: OPT
  LOGICAL,                  INTENT(OUT)   :: IS_EQUAL
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: TMP0
  INTEGER(KIND=JPIB_K) :: TMP1
  LOGICAL, DIMENSION(21) :: CONDITIONS


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Compute the conditions
  CONDITIONS(1)  =  ( THIS%STREAM .EQ. OTHER%STREAM )
  CONDITIONS(2)  =  ( THIS%TYPE .EQ. OTHER%TYPE )
  CONDITIONS(3)  =  ( THIS%CLASS .EQ. OTHER%CLASS )
  CONDITIONS(4)  =  ( THIS%EXPVER .EQ. OTHER%EXPVER )
  CONDITIONS(5)  =  ( THIS%ORIGIN .EQ. OTHER%ORIGIN )
  CONDITIONS(6)  =  ( THIS%ANOFFSET .EQ. OTHER%ANOFFSET )
  CONDITIONS(7)  =  ( THIS%NUMBER .EQ. OTHER%NUMBER )
  CONDITIONS(8)  =  ( THIS%IDENT .EQ. OTHER%IDENT )
  CONDITIONS(9)  =  ( THIS%INSTRUMENT .EQ. OTHER%INSTRUMENT )
  CONDITIONS(10) =  ( THIS%CHANNEL .EQ. OTHER%CHANNEL )
  CONDITIONS(11) =  ( THIS%PARAM_TYPE .EQ. OTHER%PARAM_TYPE )
  CONDITIONS(12) =  ( THIS%CHEM .EQ. OTHER%CHEM )
  CONDITIONS(13) =  ( THIS%PARAM .EQ. OTHER%PARAM )
  CONDITIONS(14) =  ( THIS%LEVTYPE .EQ. OTHER%LEVTYPE )
  CONDITIONS(15) =  ( THIS%MODEL .EQ. OTHER%MODEL )
  ! CONDITIONS(16) =  ( THIS%WAVELENGTH(1) .EQ. OTHER%WAVELENGTH(1) )
  ! CONDITIONS(17) =  ( THIS%WAVELENGTH(2) .EQ. OTHER%WAVELENGTH(2) )
  CONDITIONS(16) =  ( THIS%WAVELENGTH .EQ. OTHER%WAVELENGTH )
  IF (  THIS%LEVTYPE .NE. LEVTYPE_ML_E .AND. OTHER%LEVTYPE .NE. LEVTYPE_ML_E  ) THEN
    ! IF ( THIS%LEVELIST .LT. 100 ) THEN
    !   TMP0 = 0
    ! ELSE
    !   TMP0 = 1
    ! ENDIF
    ! IF ( OTHER%LEVELIST .LT. 100 ) THEN
    !   TMP1 = 0
    ! ELSE
    !   TMP1 = 1
    ! ENDIF
    CONDITIONS(17) =  ( THIS%LEVELIST .EQ. OTHER%LEVELIST )
    ! CONDITIONS(18) =  ( TMP0 .EQ. TMP1 )
  ELSE
    CONDITIONS(17) = .TRUE.
  ENDIF
  ! CONDITIONS(17) =  ( THIS%DIRECTION .EQ. OTHER%DIRECTION )
  ! CONDITIONS(18) =  ( THIS%FREQUENCY .EQ. OTHER%FREQUENCY )
  CONDITIONS(18) =  ( THIS%REPRES .EQ. OTHER%REPRES )
  CONDITIONS(19) =  ( THIS%GRID .EQ. OTHER%GRID )
  CONDITIONS(20) =  ( THIS%TRUNCATION .EQ. OTHER%TRUNCATION )

  ! Check if all conditions are true
  IS_EQUAL = ALL( CONDITIONS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_EQUAL_TO
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_LOWER_THAN'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_LOWER_THAN( THIS, OTHER, OPT, IS_LOWER_THAN, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: CACHE_UTILS_MOD,   ONLY: CACHE_OPTIONS_T
  USE :: ENUMERATORS_MOD,   ONLY: LEVTYPE_ML_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(IN)    :: THIS
  TYPE(FORTRAN_MESSAGE_T),  INTENT(IN)    :: OTHER
  TYPE(CACHE_OPTIONS_T),    INTENT(IN)    :: OPT
  LOGICAL,                  INTENT(OUT)   :: IS_LOWER_THAN
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL, DIMENSION(21,2) :: CONDITIONS
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: TMP0
  INTEGER(KIND=JPIB_K) :: TMP1

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Compare two messages
  IS_LOWER_THAN = .TRUE.

  CONDITIONS(1,1)  =  ( THIS%STREAM .EQ. OTHER%STREAM )
  CONDITIONS(2,1)  =  ( THIS%TYPE .EQ. OTHER%TYPE )
  CONDITIONS(3,1)  =  ( THIS%CLASS .EQ. OTHER%CLASS )
  CONDITIONS(4,1)  =  ( THIS%EXPVER .EQ. OTHER%EXPVER )
  CONDITIONS(5,1)  =  ( THIS%ORIGIN .EQ. OTHER%ORIGIN )
  CONDITIONS(6,1)  =  ( THIS%ANOFFSET .EQ. OTHER%ANOFFSET )
  CONDITIONS(7,1)  =  ( THIS%NUMBER .EQ. OTHER%NUMBER )
  CONDITIONS(8,1)  =  ( THIS%IDENT .EQ. OTHER%IDENT )
  CONDITIONS(9,1)  =  ( THIS%INSTRUMENT .EQ. OTHER%INSTRUMENT )
  CONDITIONS(10,1) =  ( THIS%CHANNEL .EQ. OTHER%CHANNEL )
  CONDITIONS(11,1) =  ( THIS%PARAM_TYPE .EQ. OTHER%PARAM_TYPE )
  CONDITIONS(12,1) =  ( THIS%CHEM .EQ. OTHER%CHEM )
  CONDITIONS(13,1) =  ( THIS%PARAM .EQ. OTHER%PARAM )
  CONDITIONS(14,1) =  ( THIS%LEVTYPE .EQ. OTHER%LEVTYPE )
  CONDITIONS(15,1) =  ( THIS%MODEL .EQ. OTHER%MODEL )
  ! CONDITIONS(16,1) =  ( THIS%WAVELENGTH(1) .EQ. OTHER%WAVELENGTH(1) )
  ! CONDITIONS(17,1) =  ( THIS%WAVELENGTH(2) .EQ. OTHER%WAVELENGTH(2) )
  CONDITIONS(16,1) =  ( THIS%WAVELENGTH .EQ. OTHER%WAVELENGTH )
  IF ( THIS%LEVTYPE .NE. LEVTYPE_ML_E .AND. OTHER%LEVTYPE .NE. LEVTYPE_ML_E ) THEN
    ! IF ( THIS%LEVELIST .LT. 100 ) THEN
    !   TMP0 = 0
    ! ELSE
    !   TMP0 = 1
    ! ENDIF
    ! IF ( OTHER%LEVELIST .LT. 100 ) THEN
    !   TMP1 = 0
    ! ELSE
    !   TMP1 = 1
    ! ENDIF
    CONDITIONS(17,1) =  ( THIS%LEVELIST .EQ. OTHER%LEVELIST )
    ! CONDITIONS(16,1) =  ( TMP0 .EQ. TMP1 )
  ELSE
    CONDITIONS(17,1) = .TRUE.
  ENDIF
  ! CONDITIONS(17,1) =  ( THIS%DIRECTION .EQ. OTHER%DIRECTION )
  ! CONDITIONS(18,1) =  ( THIS%FREQUENCY .EQ. OTHER%FREQUENCY )
  CONDITIONS(18,1) =  ( THIS%REPRES .EQ. OTHER%REPRES )
  CONDITIONS(19,1) =  ( THIS%GRID .EQ. OTHER%GRID )
  CONDITIONS(20,1) =  ( THIS%TRUNCATION .EQ. OTHER%TRUNCATION )

  CONDITIONS(1,2)  = ( THIS%STREAM .LE. OTHER%STREAM )
  CONDITIONS(2,2)  = ( THIS%TYPE .LE. OTHER%TYPE )
  CONDITIONS(3,2)  = ( THIS%CLASS .LE. OTHER%CLASS )
  CONDITIONS(4,2)  = ( THIS%EXPVER .LE. OTHER%EXPVER )
  CONDITIONS(5,2)  = ( THIS%ORIGIN .LE. OTHER%ORIGIN )
  CONDITIONS(6,2)  = ( THIS%NUMBER .LE. OTHER%NUMBER )
  CONDITIONS(7,2)  = ( THIS%ANOFFSET .LE. OTHER%ANOFFSET )
  CONDITIONS(8,2)  = ( THIS%IDENT .LE. OTHER%IDENT )
  CONDITIONS(9,2)  = ( THIS%INSTRUMENT .LE. OTHER%INSTRUMENT )
  CONDITIONS(10,2) = ( THIS%CHANNEL .LE. OTHER%CHANNEL )
  CONDITIONS(11,2) = ( THIS%PARAM_TYPE .LE. OTHER%PARAM_TYPE )
  CONDITIONS(12,2) = ( THIS%CHEM .LE. OTHER%CHEM )
  CONDITIONS(13,2) = ( THIS%PARAM .LE. OTHER%PARAM )
  CONDITIONS(14,2) = ( THIS%LEVTYPE .LE. OTHER%LEVTYPE )
  CONDITIONS(15,2) = ( THIS%MODEL .LE. OTHER%MODEL )
  ! CONDITIONS(16,2) = ( THIS%WAVELENGTH(1) .LE. OTHER%WAVELENGTH(1) )
  ! CONDITIONS(17,2) = ( THIS%WAVELENGTH(2) .LE. OTHER%WAVELENGTH(2) )
  CONDITIONS(16,2) = ( THIS%WAVELENGTH .LE. OTHER%WAVELENGTH )
  IF (  THIS%LEVTYPE .NE. LEVTYPE_ML_E .AND. OTHER%LEVTYPE .NE. LEVTYPE_ML_E ) THEN
    ! IF ( THIS%LEVELIST .LT. 100 ) THEN
    !   TMP0 = 0
    ! ELSE
    !   TMP0 = 1
    ! ENDIF
    ! IF ( OTHER%LEVELIST .LT. 100 ) THEN
    !   TMP1 = 0
    ! ELSE
    !   TMP1 = 1
    ! ENDIF
    CONDITIONS(17,2) = ( THIS%LEVELIST .LE. OTHER%LEVELIST )
    ! CONDITIONS(16,2) = ( TMP0 .LE. TMP1 )
  ELSE
    CONDITIONS(17,2) = .TRUE.
  ENDIF
  ! CONDITIONS(17,2) = ( THIS%DIRECTION .LE. OTHER%DIRECTION )
  ! CONDITIONS(18,2) = ( THIS%FREQUENCY .LE. OTHER%FREQUENCY )
  CONDITIONS(18,2) = ( THIS%REPRES .LE. OTHER%REPRES )
  CONDITIONS(19,2) = ( THIS%GRID .LE. OTHER%GRID )
  CONDITIONS(20,2) = ( THIS%TRUNCATION .LE. OTHER%TRUNCATION )

  ! Check if ti is lower than
  I = 1
  IS_LOWER_THAN = .FALSE.
  DO WHILE ( I .LE. 21 )
    IF ( .NOT.CONDITIONS(I,1) .AND. CONDITIONS(I,2) ) THEN
      IS_LOWER_THAN = .TRUE.
      EXIT
    ELSEIF ( CONDITIONS(I,1) .AND. CONDITIONS(I,2) ) THEN
      I = I + 1_JPIB_K
    ELSE
      IS_LOWER_THAN = .FALSE.
      EXIT
    ENDIF
  ENDDO

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_LOWER_THAN
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_SET_ENUM_INT'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_SET_ENUM_INT( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_STREAM_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_TYPE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_CLASS_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_ORIGIN_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_ANOFFSET_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_NUMBER_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_IDENT_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_INSTRUMENT_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_CHANNEL_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_PARAM_TYPE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_CHEM_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_PARAM_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_LEVTYPE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_LEVELIST_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_DIRECTION_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_FREQUENCY_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_MODEL_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_REPRES_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_DATE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_TIME_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_STEP_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_PACKING_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_TRUNCATION_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_HDATE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_WAVELENGTH_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FIELD_ID=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Set fields by field ID
  SELECT CASE (ID)
  CASE (MSGINTFLD_STREAM_E)
    THIS%STREAM  = VALUE
  CASE (MSGINTFLD_TYPE_E)
    THIS%TYPE = VALUE
  CASE (MSGINTFLD_CLASS_E)
    THIS%CLASS = VALUE
  CASE (MSGINTFLD_ORIGIN_E)
    THIS%ORIGIN = VALUE
  CASE (MSGINTFLD_ANOFFSET_E)
    THIS%ANOFFSET = VALUE
  CASE (MSGINTFLD_NUMBER_E)
    THIS%NUMBER = VALUE
  CASE (MSGINTFLD_IDENT_E)
    THIS%IDENT = VALUE
  CASE (MSGINTFLD_INSTRUMENT_E)
    THIS%INSTRUMENT = VALUE
  CASE (MSGINTFLD_CHANNEL_E)
    THIS%CHANNEL = VALUE
  CASE (MSGINTFLD_PARAM_TYPE_E)
    THIS%PARAM_TYPE = VALUE
  CASE (MSGINTFLD_CHEM_E)
    THIS%CHEM = VALUE
  CASE (MSGINTFLD_PARAM_E)
    THIS%PARAM = VALUE
  CASE (MSGINTFLD_LEVTYPE_E)
    THIS%LEVTYPE = VALUE
  CASE (MSGINTFLD_LEVELIST_E)
    THIS%LEVELIST = VALUE
  CASE (MSGINTFLD_DIRECTION_E)
    THIS%DIRECTION = VALUE
  CASE (MSGINTFLD_FREQUENCY_E)
    THIS%FREQUENCY = VALUE
  CASE (MSGINTFLD_MODEL_E)
    THIS%MODEL = VALUE
  CASE (MSGINTFLD_REPRES_E)
    THIS%REPRES = VALUE
  CASE (MSGINTFLD_DATE_E)
    THIS%DATE = VALUE
  CASE (MSGINTFLD_TIME_E)
    THIS%TIME = VALUE
  CASE (MSGINTFLD_STEP_E)
    THIS%STEP = VALUE
  CASE (MSGINTFLD_PACKING_E)
    THIS%PACKING = VALUE
  CASE (MSGINTFLD_TRUNCATION_E)
    THIS%TRUNCATION = VALUE
  CASE (MSGINTFLD_HDATE_E)
    THIS%HDATE = VALUE
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_FIELD_ID )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid field ID' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_SET_ENUM_INT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_SET_KEY_INT'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_SET_KEY_INT( THIS, KEY, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: CMSGINTFLDS2IMSGINTFLDS

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(INOUT) :: THIS
  CHARACTER(LEN=*),         INTENT(IN)    :: KEY
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: ID

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONVERT_TO_ENUM=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_SET_VALUE=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Set fields by field ID
  PP_TRYCALL(ERRFLAG_CONVERT_TO_ENUM) CMSGINTFLDS2IMSGINTFLDS( KEY, ID, HOOKS )
  PP_TRYCALL(ERRFLAG_SET_VALUE) THIS%SET_ENUM_INT( ID, VALUE, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CONVERT_TO_ENUM)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'convert to enum' )
    CASE (ERRFLAG_SET_VALUE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'set value' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_SET_KEY_INT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_SET_ENUM_STRING'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_SET_ENUM_STRING( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGSTRFLD_GRID_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGSTRFLD_EXPVER_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  CHARACTER(LEN=*),         INTENT(IN)    :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FIELD_ID=1_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Select the prefix
  SELECT CASE ( ID )
  CASE (MSGSTRFLD_GRID_E)
    THIS%GRID = VALUE
  CASE (MSGSTRFLD_EXPVER_E)
    THIS%EXPVER = VALUE
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_FIELD_ID )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid field ID' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_SET_ENUM_STRING
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_SET_KEY_STRING'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_SET_KEY_STRING( THIS, KEY, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: CMSGSTRINGFLDS2IMSGSTRINGFLDS

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(INOUT) :: THIS
  CHARACTER(LEN=*),         INTENT(IN)    :: KEY
  CHARACTER(LEN=*),         INTENT(IN)    :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: ID

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONVERT_TO_ENUM=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_SET_VALUE=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Select the prefix
  PP_TRYCALL(ERRFLAG_CONVERT_TO_ENUM) CMSGSTRINGFLDS2IMSGSTRINGFLDS( KEY, ID, HOOKS )
  PP_TRYCALL(ERRFLAG_SET_VALUE) THIS%SET_ENUM_STRING( ID, VALUE, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CONVERT_TO_ENUM)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'convert to enum' )
    CASE (ERRFLAG_SET_VALUE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'set value' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_SET_KEY_STRING
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_SET_ENUM_FLOAT'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_SET_ENUM_FLOAT( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPRD_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  REAL(KIND=JPRD_K),        INTENT(IN)    :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FIELD_ID=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_FIELD_ID )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid field ID' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_SET_ENUM_FLOAT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_SET_KEY_FLOAT'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_SET_KEY_FLOAT( THIS, KEY, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPRD_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(INOUT) :: THIS
  CHARACTER(LEN=*),         INTENT(IN)    :: KEY
  REAL(KIND=JPRD_K),        INTENT(IN)    :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: ID

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FIELD_ID=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_FIELD_ID )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid field ID' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_SET_KEY_FLOAT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_GET_ENUM_INT'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_GET_ENUM_INT( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_STREAM_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_TYPE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_CLASS_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_ORIGIN_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_ANOFFSET_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_NUMBER_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_IDENT_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_INSTRUMENT_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_CHANNEL_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_PARAM_TYPE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_CHEM_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_PARAM_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_LEVTYPE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_LEVELIST_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_DIRECTION_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_FREQUENCY_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_MODEL_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_REPRES_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_DATE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_TIME_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_STEP_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_PACKING_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_TRUNCATION_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_HDATE_E
  USE :: ENUMERATORS_MOD,                 ONLY: UNDEF_PARAM_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  INTEGER(KIND=JPIB_K),     INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FIELD_ID=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUE=3_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialize the output value
  VALUE = 0_JPIB_K

  ! Set fields by field ID
  SELECT CASE (ID)
  CASE (MSGINTFLD_STREAM_E)
    VALUE = THIS%STREAM
  CASE (MSGINTFLD_TYPE_E)
    VALUE = THIS%TYPE
  CASE (MSGINTFLD_CLASS_E)
    VALUE = THIS%CLASS
  CASE (MSGINTFLD_ORIGIN_E)
    VALUE = THIS%ORIGIN
  CASE (MSGINTFLD_ANOFFSET_E)
    VALUE = THIS%ANOFFSET
  CASE (MSGINTFLD_NUMBER_E)
    VALUE = THIS%NUMBER
  CASE (MSGINTFLD_IDENT_E)
    VALUE = THIS%IDENT
  CASE (MSGINTFLD_INSTRUMENT_E)
    VALUE = THIS%INSTRUMENT
  CASE (MSGINTFLD_CHANNEL_E)
    VALUE = THIS%CHANNEL
  CASE (MSGINTFLD_PARAM_TYPE_E)
    VALUE = THIS%PARAM_TYPE
  CASE (MSGINTFLD_CHEM_E)
    VALUE = THIS%CHEM
  CASE (MSGINTFLD_PARAM_E)
    VALUE = THIS%PARAM
  CASE (MSGINTFLD_LEVTYPE_E)
    VALUE = THIS%LEVTYPE
  CASE (MSGINTFLD_LEVELIST_E)
    VALUE = THIS%LEVELIST
  CASE (MSGINTFLD_DIRECTION_E)
    VALUE = THIS%DIRECTION
  CASE (MSGINTFLD_FREQUENCY_E)
    VALUE = THIS%FREQUENCY
  CASE (MSGINTFLD_MODEL_E)
    VALUE = THIS%MODEL
  CASE (MSGINTFLD_REPRES_E)
    VALUE = THIS%REPRES
  CASE (MSGINTFLD_DATE_E)
    VALUE = THIS%DATE
  CASE (MSGINTFLD_TIME_E)
    VALUE = THIS%TIME
  CASE (MSGINTFLD_STEP_E)
    VALUE = THIS%STEP
  CASE (MSGINTFLD_PACKING_E)
    VALUE = THIS%PACKING
  CASE (MSGINTFLD_TRUNCATION_E)
    VALUE = THIS%TRUNCATION
  CASE (MSGINTFLD_HDATE_E)
    VALUE = THIS%HDATE
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_FIELD_ID )
  END SELECT

  ! Check value
  PP_DEBUG_CRITICAL_COND_THROW( VALUE .EQ. UNDEF_PARAM_E, ERRFLAG_INVALID_VALUE )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid field ID' )
    CASE (ERRFLAG_INVALID_VALUE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid value' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_GET_ENUM_INT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_GET_KEY_INT'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_GET_KEY_INT( THIS, KEY, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: CMSGINTFLDS2IMSGINTFLDS
  USE :: ENUMERATORS_MOD,                 ONLY: UNDEF_PARAM_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(IN)    :: THIS
  CHARACTER(LEN=*),         INTENT(IN)    :: KEY
  INTEGER(KIND=JPIB_K),     INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: ID

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FIELD_ID=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_SET_VALUE=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUE=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialize the output value
  VALUE = 0_JPIB_K

  ! Get field by ID
  PP_TRYCALL(ERRFLAG_INVALID_FIELD_ID) CMSGINTFLDS2IMSGINTFLDS( KEY, ID, HOOKS )
  PP_TRYCALL(ERRFLAG_SET_VALUE) THIS%GET_ENUM_INT( ID, VALUE, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( VALUE .EQ. UNDEF_PARAM_E, ERRFLAG_INVALID_VALUE )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid field ID' )
    CASE (ERRFLAG_SET_VALUE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'get value' )
    CASE (ERRFLAG_INVALID_VALUE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid value' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_GET_KEY_INT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_HAS_ENUM'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_HAS_ENUM( THIS, ID, HAS_FIELD, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: ENUMERATORS_MOD,   ONLY: UNDEF_PARAM_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_STREAM_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_TYPE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_CLASS_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_ORIGIN_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_ANOFFSET_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_NUMBER_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_IDENT_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_INSTRUMENT_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_CHANNEL_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_PARAM_TYPE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_CHEM_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_PARAM_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_LEVTYPE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_LEVELIST_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_DIRECTION_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_FREQUENCY_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_MODEL_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_REPRES_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_DATE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_TIME_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_STEP_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_PACKING_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_HDATE_E

  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGSTRFLD_GRID_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGSTRFLD_EXPVER_E

  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: HAS_IMSGINTFLDS
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: HAS_IMSGSTRINGFLDS
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: HAS_IMSGFLOATFLDS

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  LOGICAL,                  INTENT(OUT)   :: HAS_FIELD
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: HAS_FIELD_INT
  LOGICAL :: HAS_FIELD_STRING
  LOGICAL :: HAS_FIELD_FLOAT
  INTEGER(KIND=JPIB_K) :: VALUE

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CHECK_FIELD_ID=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FIELD_ID=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialize the output value
  HAS_FIELD = .FALSE.

  ! Check if the field is valid
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_FIELD_ID) HAS_IMSGINTFLDS( ID, HAS_FIELD_INT, HOOKS )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_FIELD_ID) HAS_IMSGSTRINGFLDS( ID, HAS_FIELD_STRING, HOOKS )

  ! If field is present then check the value
  IF ( HAS_FIELD_INT ) THEN
    SELECT CASE (ID)
    CASE (MSGINTFLD_STREAM_E)
      VALUE = THIS%STREAM
    CASE (MSGINTFLD_TYPE_E)
      VALUE = THIS%TYPE
    CASE (MSGINTFLD_CLASS_E)
      VALUE = THIS%CLASS
    CASE (MSGINTFLD_ORIGIN_E)
      VALUE = THIS%ORIGIN
    CASE (MSGINTFLD_ANOFFSET_E)
      VALUE = THIS%ANOFFSET
    CASE (MSGINTFLD_NUMBER_E)
      VALUE = THIS%NUMBER
    CASE (MSGINTFLD_IDENT_E)
      VALUE = THIS%IDENT
    CASE (MSGINTFLD_INSTRUMENT_E)
      VALUE = THIS%INSTRUMENT
    CASE (MSGINTFLD_CHANNEL_E)
      VALUE = THIS%CHANNEL
    CASE (MSGINTFLD_PARAM_TYPE_E)
      VALUE = THIS%PARAM_TYPE
    CASE (MSGINTFLD_CHEM_E)
      VALUE = THIS%CHEM
    CASE (MSGINTFLD_PARAM_E)
      VALUE = THIS%PARAM
    CASE (MSGINTFLD_LEVTYPE_E)
      VALUE = THIS%LEVTYPE
    CASE (MSGINTFLD_LEVELIST_E)
      VALUE = THIS%LEVELIST
    CASE (MSGINTFLD_DIRECTION_E)
      VALUE = THIS%DIRECTION
    CASE (MSGINTFLD_FREQUENCY_E)
      VALUE = THIS%FREQUENCY
    CASE (MSGINTFLD_MODEL_E)
      VALUE = THIS%MODEL
    CASE (MSGINTFLD_REPRES_E)
      VALUE = THIS%REPRES
    CASE (MSGINTFLD_DATE_E)
      VALUE = THIS%DATE
    CASE (MSGINTFLD_TIME_E)
      VALUE = THIS%TIME
    CASE (MSGINTFLD_STEP_E)
      VALUE = THIS%STEP
    CASE (MSGINTFLD_PACKING_E)
      VALUE = THIS%PACKING
    CASE (MSGINTFLD_HDATE_E)
      VALUE = THIS%HDATE
    CASE DEFAULT
      PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_FIELD_ID )
    END SELECT
    ! Check if the value is undefined
    IF ( VALUE .EQ. UNDEF_PARAM_E ) THEN
      ! WRITE(*,*) 'VALUE = ', VALUE, 'UNDEF_PARAM_E = ', UNDEF_PARAM_E, 'ID = ', ID
      HAS_FIELD = .FALSE.
    ELSE
      HAS_FIELD = .TRUE.
    ENDIF
  ENDIF



  ! If field is present then check the value
  IF ( HAS_FIELD_STRING ) THEN
    SELECT CASE (ID)
    CASE (MSGSTRFLD_GRID_E)
      IF ( THIS%GRID .EQ. '********' ) THEN
        HAS_FIELD = .FALSE.
      ELSE
        HAS_FIELD = .TRUE.
      END IF
    CASE (MSGSTRFLD_EXPVER_E)
      IF ( THIS%EXPVER .EQ. '****' ) THEN
        HAS_FIELD = .FALSE.
      ELSE
        HAS_FIELD = .TRUE.
      END IF
    CASE DEFAULT
      PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_FIELD_ID )
    END SELECT
  ENDIF

  ! Check if the field is valid
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_FIELD_ID) HAS_IMSGFLOATFLDS( ID, HAS_FIELD_FLOAT, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid field ID' )
    CASE (ERRFLAG_UNABLE_TO_CHECK_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to check field ID' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_HAS_ENUM
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_HAS_KEY'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_HAS_KEY( THIS, KEY, HAS_FIELD, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: HAS_CMSGINTFLDS
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: CMSGINTFLDS2IMSGINTFLDS

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(IN)    :: THIS
  CHARACTER(LEN=*),         INTENT(IN)    :: KEY
  LOGICAL,                  INTENT(OUT)   :: HAS_FIELD
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: ID

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CHECK_KEY=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CHECK_ID=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Check if the field is valid
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_KEY) HAS_CMSGINTFLDS( KEY, HAS_FIELD, HOOKS )

  ! Get field by ID
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT) CMSGINTFLDS2IMSGINTFLDS( KEY, ID, HOOKS )

  ! verifiy if field is present
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_ID) THIS%HAS_ENUM( ID, HAS_FIELD, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CHECK_KEY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to check key' )
    CASE (ERRFLAG_UNABLE_TO_CONVERT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert' )
    CASE (ERRFLAG_UNABLE_TO_CHECK_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to check ID' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_HAS_KEY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_GET_ENUM_STRING'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_GET_ENUM_STRING( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGSTRFLD_GRID_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGSTRFLD_EXPVER_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  CHARACTER(LEN=8),         INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FIELD_ID=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUE=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Select the prefix
  SELECT CASE ( ID )
  CASE (MSGSTRFLD_GRID_E)
    VALUE = THIS%GRID
    PP_DEBUG_CRITICAL_COND_THROW( VALUE .EQ. '********', ERRFLAG_INVALID_VALUE )
  CASE (MSGSTRFLD_EXPVER_E)
    VALUE = THIS%EXPVER
    PP_DEBUG_CRITICAL_COND_THROW( VALUE .EQ. '****', ERRFLAG_INVALID_VALUE )
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_FIELD_ID )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid field ID' )
    CASE (ERRFLAG_INVALID_VALUE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid value' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_GET_ENUM_STRING
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_GET_KEY_STRING'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_GET_KEY_STRING( THIS, KEY, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: CMSGSTRINGFLDS2IMSGSTRINGFLDS

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(IN)    :: THIS
  CHARACTER(LEN=*),         INTENT(IN)    :: KEY
  CHARACTER(LEN=8),         INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: ID

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FIELD_ID=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_SET_VALUE=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUE=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Select the prefix
  PP_TRYCALL(ERRFLAG_INVALID_FIELD_ID) CMSGSTRINGFLDS2IMSGSTRINGFLDS( KEY, ID, HOOKS )
  PP_TRYCALL(ERRFLAG_SET_VALUE) THIS%GET_ENUM_STRING( ID, VALUE, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( VALUE .EQ. '********', ERRFLAG_INVALID_VALUE )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid field ID' )
    CASE (ERRFLAG_SET_VALUE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'set value' )
    CASE (ERRFLAG_INVALID_VALUE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid value' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_GET_KEY_STRING
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_GET_ENUM_FLOAT'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_GET_ENUM_FLOAT( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPRD_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  REAL(KIND=JPRD_K),        INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FIELD_ID=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  VALUE = 0.0_JPRD_K

  PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_FIELD_ID )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid field ID' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_GET_ENUM_FLOAT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_GET_KEY_FLOAT'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_GET_KEY_FLOAT( THIS, KEY, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPRD_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(IN)    :: THIS
  CHARACTER(LEN=*),         INTENT(IN)    :: KEY
  REAL(KIND=JPRD_K),        INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FIELD_ID=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  VALUE = 0.0_JPRD_K

  PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_FIELD_ID )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_FIELD_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid field ID' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_GET_KEY_FLOAT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_READ_FROM_YAML'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_READ_FROM_YAML( MSG, CONFIG, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: FUN_C2I_IF
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_INTEGER_WITH_FILTER
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_STRING
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_INTEGER
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATION
  USE :: ENUMERATORS_MOD,     ONLY: UNDEF_PARAM_E

  USE :: ENUMERATORS_MOD, ONLY: CSTREAM2ISTREAM
  USE :: ENUMERATORS_MOD, ONLY: CTYPE2ITYPE
  USE :: ENUMERATORS_MOD, ONLY: CCLASS2ICLASS
  USE :: ENUMERATORS_MOD, ONLY: CPACKING2IPACKING
  USE :: ENUMERATORS_MOD, ONLY: CLEVTYPE2ILEVTYPE
  USE :: ENUMERATORS_MOD, ONLY: CREPRES2IREPRES

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T),   INTENT(INOUT) :: MSG
  TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CONFIG
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  TYPE(YAML_CONFIGURATION_T) :: MSG_CONFIG
  LOGICAL :: HAS_MESSAGE
  LOGICAL :: HAS_KEY
  PROCEDURE(FUN_C2I_IF), POINTER :: P_FILTER
  CHARACTER(LEN=:), ALLOCATABLE :: CTMP
  INTEGER(KIND=JPIB_K) :: DEALLOC_STAT
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_EXPVER=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_GRID=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DEALLOCATE=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_SUBCFG=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DELETE_CONFIGURATION=6_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Read the encoder configuration
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'message', HAS_MESSAGE, HOOKS )


  !> Read representations
  IF ( HAS_MESSAGE  ) THEN

    !> Read all the subconfigurations
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_SUBCFG) YAML_GET_SUBCONFIGURATION( CONFIG, 'message', MSG_CONFIG, HOOKS )

    !> Read the "stream"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'stream', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      P_FILTER => CSTREAM2ISTREAM
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER_WITH_FILTER( MSG_CONFIG, 'stream', MSG%STREAM, P_FILTER, HOOKS )
    ELSE
      MSG%STREAM = UNDEF_PARAM_E
    ENDIF

    !> Read the "type"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'type', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      P_FILTER => CTYPE2ITYPE
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER_WITH_FILTER( MSG_CONFIG, 'type', MSG%TYPE, P_FILTER, HOOKS )
    ELSE
      MSG%TYPE = UNDEF_PARAM_E
    ENDIF

    !> Read the "class"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'class', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      P_FILTER => CCLASS2ICLASS
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER_WITH_FILTER( MSG_CONFIG, 'class', MSG%CLASS, P_FILTER, HOOKS )
    ELSE
      MSG%CLASS = UNDEF_PARAM_E
    ENDIF

    !> Read the "expver"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'expver', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      IF ( ALLOCATED(CTMP) ) THEN
        DEALLOCATE(CTMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
        PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
      ENDIF
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_STRING( MSG_CONFIG, 'expver', CTMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(CTMP), ERRFLAG_UNABLE_TO_READ_CFG )
      PP_DEBUG_CRITICAL_COND_THROW( LEN(CTMP).GT.4, ERRFLAG_INVALID_EXPVER )
      MSG%EXPVER = CTMP
      IF ( ALLOCATED(CTMP) ) THEN
        DEALLOCATE(CTMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
        PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
      ENDIF
    ELSE
      MSG%EXPVER = REPEAT('*',4)
    ENDIF

    !> Read the "origin"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'origin', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'origin', MSG%ORIGIN, HOOKS )
    ELSE
      MSG%ORIGIN = UNDEF_PARAM_E
    ENDIF

    !> Read the "anoffset"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'anoffset', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'anoffset', MSG%ANOFFSET, HOOKS )
    ELSE
      MSG%ANOFFSET = UNDEF_PARAM_E
    ENDIF

    !> Read the "packing"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'packing', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      P_FILTER => CPACKING2IPACKING
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER_WITH_FILTER( MSG_CONFIG, 'packing', MSG%PACKING, P_FILTER, HOOKS )
    ELSE
      MSG%PACKING = UNDEF_PARAM_E
    ENDIF

    !> Read the "number"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'number', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'number', MSG%NUMBER, HOOKS )
    ELSE
      MSG%NUMBER = UNDEF_PARAM_E
    ENDIF

    !> Read the "ident"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'ident', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'ident', MSG%IDENT, HOOKS )
    ELSE
      MSG%IDENT = UNDEF_PARAM_E
    ENDIF

    !> Read the "instrument"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'instrument', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'instrument', MSG%INSTRUMENT, HOOKS )
    ELSE
      MSG%INSTRUMENT = UNDEF_PARAM_E
    ENDIF

    !> Read the "channel"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'channel', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'channel', MSG%CHANNEL, HOOKS )
    ELSE
      MSG%CHANNEL = UNDEF_PARAM_E
    ENDIF

    !> Read the "param"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'param', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'param', MSG%PARAM, HOOKS )
    ELSE
      MSG%PARAM = UNDEF_PARAM_E
    ENDIF

    !> Read the "levtype"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'levtype', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      P_FILTER => CLEVTYPE2ILEVTYPE
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER_WITH_FILTER( MSG_CONFIG, 'levtype', MSG%LEVTYPE, P_FILTER, HOOKS )
    ELSE
      MSG%LEVTYPE = UNDEF_PARAM_E
    ENDIF

    !> Read the "levelist"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'levelist', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'levelist', MSG%LEVELIST, HOOKS )
    ELSE
      MSG%LEVELIST = UNDEF_PARAM_E
    ENDIF

    !> Read the "direction"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'direction', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'direction', MSG%DIRECTION, HOOKS )
    ELSE
      MSG%DIRECTION = UNDEF_PARAM_E
    ENDIF

    !> Read the "frequency"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'direction', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'direction', MSG%FREQUENCY, HOOKS )
    ELSE
      MSG%FREQUENCY = UNDEF_PARAM_E
    ENDIF

    !> Read the "repres"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'repres', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      P_FILTER => CREPRES2IREPRES
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER_WITH_FILTER( MSG_CONFIG, 'repres', MSG%REPRES, P_FILTER, HOOKS )
    ELSE
      MSG%REPRES = UNDEF_PARAM_E
    ENDIF

    !> Read the "date"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'date', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'date', MSG%DATE, HOOKS )
    ELSE
      MSG%DATE = UNDEF_PARAM_E
    ENDIF

    !> Read the "time"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'time', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'time', MSG%TIME, HOOKS )
    ELSE
      MSG%TIME = UNDEF_PARAM_E
    ENDIF

    !> Read the "step"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'step', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'step', MSG%STEP, HOOKS )
    ELSE
      MSG%STEP = UNDEF_PARAM_E
    ENDIF

    !> Read the "hdate"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'hdate', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( MSG_CONFIG, 'hdate', MSG%HDATE, HOOKS )
    ELSE
      MSG%HDATE = UNDEF_PARAM_E
    ENDIF

    !> Read the "grid"
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( MSG_CONFIG, 'grid', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      IF ( ALLOCATED(CTMP) ) THEN
        DEALLOCATE(CTMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
        PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
      ENDIF
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_STRING( MSG_CONFIG, 'grid', CTMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(CTMP), ERRFLAG_UNABLE_TO_READ_CFG )
      PP_DEBUG_CRITICAL_COND_THROW( LEN(CTMP).GT.8, ERRFLAG_INVALID_GRID )
      MSG%GRID = CTMP
      IF ( ALLOCATED(CTMP) ) THEN
        DEALLOCATE(CTMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
        PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
      ENDIF
    ELSE
      MSG%GRID = REPEAT('*',8)
    ENDIF

    !> Destroy the configuration object
    PP_TRYCALL(ERRFLAG_UNABLE_TO_DELETE_CONFIGURATION) YAML_DELETE_CONFIGURATION( MSG_CONFIG, HOOKS )

  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read configuration' )
    CASE (ERRFLAG_INVALID_EXPVER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid expver' )
    CASE (ERRFLAG_INVALID_GRID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid grid' )
    CASE (ERRFLAG_UNABLE_TO_DEALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to deallocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        DEALLOCATE( ERRMSG, STAT=DEALLOC_STAT )
      ENDIF
    CASE (ERRFLAG_UNABLE_TO_READ_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read subconfiguration' )
    CASE (ERRFLAG_UNABLE_TO_DELETE_CONFIGURATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to delete configuration' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_READ_FROM_YAML
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FORTRAN_MESSAGE_TO_YAML'
PP_THREAD_SAFE FUNCTION FORTRAN_MESSAGE_TO_YAML( THIS, UNIT, OFFSET, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPRD_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: ENUMERATORS_MOD,          ONLY: UNDEF_PARAM_E
  USE :: ENUMERATORS_MOD,          ONLY: ISTREAM2CSTREAM
  USE :: ENUMERATORS_MOD,          ONLY: ITYPE2CTYPE
  USE :: ENUMERATORS_MOD,          ONLY: ICLASS2CCLASS
  USE :: ENUMERATORS_MOD,          ONLY: IPACKING2CPACKING
  USE :: ENUMERATORS_MOD,          ONLY: IPARAMTYPE2CPARAMTYPE
  USE :: ENUMERATORS_MOD,          ONLY: ILEVTYPE2CLEVTYPE
  USE :: ENUMERATORS_MOD,          ONLY: IREPRES2CREPRES
  USE :: ENUMERATORS_MOD,          ONLY: IINT2CINT
  ! USE :: DATETIME_UTILS_MOD,       ONLY: HHMMSS2STRING
  ! USE :: DATETIME_UTILS_MOD,       ONLY: YYYYMMDD2STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(FORTRAN_MESSAGE_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: UNIT
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: OFFSET
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local parameters
  CHARACTER(LEN=32)    :: CTMP
  INTEGER(KIND=JPIB_K) :: WRITE_STAT
  LOGICAL              :: UNIT_OPENED

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNIT_NOT_OPENED=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IOSTATUS_NOT_ZERO=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ISTREAM2CSTREAM=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ITYPE2CTYPE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ICLASS2CCLASS=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPACKING2CPACKING=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPARAMTYPE2CPARAMTYPE=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ILEVTYPE2CLEVTYPE=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IREPRES2CREPRES=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DATE_TO_STRING=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_TIME_TO_STRING=10_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Erro handling
  INQUIRE(UNIT=UNIT, OPENED=UNIT_OPENED)
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.UNIT_OPENED, ERRFLAG_UNIT_NOT_OPENED )

  WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET)//'message:'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )

  ! Print Stream
  IF ( THIS%STREAM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ISTREAM2CSTREAM) ISTREAM2CSTREAM( THIS%STREAM, CTMP(1:8), HOOKS )
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'stream: "'//TRIM(ADJUSTL(CTMP))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print Type
  IF ( THIS%TYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ITYPE2CTYPE) ITYPE2CTYPE( THIS%TYPE, CTMP, HOOKS )
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'type: "'//TRIM(ADJUSTL(CTMP))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print Class
  IF ( THIS%CLASS .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ICLASS2CCLASS) ICLASS2CCLASS( THIS%CLASS, CTMP(1:8), HOOKS )
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'class: "'//TRIM(ADJUSTL(CTMP))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print Expver
  IF ( THIS%EXPVER .NE. '****' ) THEN
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'expver: "'//TRIM(ADJUSTL(THIS%EXPVER))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print PACKING
  IF ( THIS%PACKING .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_IPACKING2CPACKING) IPACKING2CPACKING( THIS%PACKING, CTMP(1:16), HOOKS )
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'packing: "'//TRIM(ADJUSTL(CTMP))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print NUMBER
  IF ( THIS%NUMBER .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%NUMBER
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'number: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print IDENT
  IF ( THIS%IDENT .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%IDENT
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'ident: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print INSTRUMENT
  IF ( THIS%INSTRUMENT .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%INSTRUMENT
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'instrument: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print CHANNEL
  IF ( THIS%CHANNEL .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%CHANNEL
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'channel: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print PARAM_TYPE
  IF ( THIS%PARAM_TYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_IPARAMTYPE2CPARAMTYPE) IPARAMTYPE2CPARAMTYPE( THIS%PARAM_TYPE, CTMP(1:16), HOOKS )
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'paramtype: "'//TRIM(ADJUSTL(CTMP))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print CHEM
  IF ( THIS%CHEM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%CHEM
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'chem: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print PARAM
  IF ( THIS%PARAM .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%PARAM
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'param: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print LEVTYPE
  IF ( THIS%LEVTYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ILEVTYPE2CLEVTYPE) ILEVTYPE2CLEVTYPE( THIS%LEVTYPE, CTMP(1:16), HOOKS )
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'levtype: "'//TRIM(ADJUSTL(CTMP))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print LEVELIST
  IF ( THIS%LEVELIST .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%LEVELIST
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'levelist: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print DIRECTION
  IF ( THIS%DIRECTION .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%DIRECTION
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'direction: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print FREQUENCY
  IF ( THIS%FREQUENCY .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%FREQUENCY
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'frequency: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print DATE
  IF ( THIS%DATE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    ! PP_TRYCALL(ERRFLAG_DATE_TO_STRING) YYYYMMDD2STRING( THIS%DATE, CTMP(1:10), HOOKS )
    ! PP_TRYCALL(ERRFLAG_ILEVTYPE2CLEVTYPE) IINT2CINT( THIS%DATE, CTMP(1:10), HOOKS )
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%DATE
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'date: "'//TRIM(ADJUSTL(CTMP))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print TIME
  IF ( THIS%TIME .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    ! PP_TRYCALL(ERRFLAG_TIME_TO_STRING) HHMMSS2STRING( THIS%TIME, CTMP(1:8), HOOKS )
    ! PP_TRYCALL(ERRFLAG_ILEVTYPE2CLEVTYPE) IINT2CINT( THIS%TIME, CTMP(1:8), HOOKS )
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%TIME
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'time: "'//TRIM(ADJUSTL(CTMP))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print STEP
  IF ( THIS%STEP .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%STEP
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'step: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print TIMEPROC
  IF ( THIS%TIMEPROC .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%TIMEPROC
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'timeproc: "'//TRIM(ADJUSTL(CTMP))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print HDATE
  IF ( THIS%HDATE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    ! PP_TRYCALL(ERRFLAG_DATE_TO_STRING) YYYYMMDD2STRING( THIS%HDATE, CTMP(1:10), HOOKS )
    ! PP_TRYCALL(ERRFLAG_ILEVTYPE2CLEVTYPE) IINT2CINT( THIS%HDATE, CTMP(1:10), HOOKS )
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%HDATE
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'hdate: "'//TRIM(ADJUSTL(CTMP))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print REPRES
  IF ( THIS%REPRES .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    PP_TRYCALL(ERRFLAG_ILEVTYPE2CLEVTYPE) IREPRES2CREPRES( THIS%REPRES, CTMP(1:16), HOOKS )
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'repres: "'//TRIM(ADJUSTL(CTMP))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print GRID
  IF ( THIS%GRID .NE. '********' ) THEN
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'grid: "'//TRIM(ADJUSTL(THIS%GRID))//'"'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print TRUNCATION
  IF ( THIS%TRUNCATION .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%TRUNCATION
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'truncation: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNIT_NOT_OPENED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unit not opened' )
    CASE (ERRFLAG_DATE_TO_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'YYYYMMDD2STRING failed' )
    CASE (ERRFLAG_TIME_TO_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'HHMMSS2STRING failed' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FORTRAN_MESSAGE_TO_YAML
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



END MODULE FORTRAN_MESSAGE_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME
