! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"

! Definition of the module
#define PP_FILE_NAME 'command_arguments_parser_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'COMMAND_ARGUMENTS_PARSER_MOD'
MODULE COMMAND_ARGUMENTS_PARSER_MOD

  ! Symbols imported from the main library of the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: KEYSET_INT64_MOD,                ONLY: KEYSET_INT64_T

IMPLICIT NONE

! Default visibility
PRIVATE

! Local enumerators
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_VERBOSE_E = 1_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_DUMP_PATH_E = 2_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_SKIP_VALUES_E = 3_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_SKIP_FLUSH_LAST_STEP_E = 4_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_OUTPUT_MANAGER_E = 5_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_CONFIGURATION_FILE_E = 6_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_SEED_E = 7_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_READ_BIG_ENDIAN_E = 8_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_PROCESSORS_E = 9_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_PARAM_E = 10_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_REPRES_E = 11_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_LEVTYPE_E = 12_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_LEVEL_E = 13_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_STEP_E = 14_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_FREQUENCY_E = 15_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_DIRCTION_E = 16_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_FILTER_FILE_E = 17_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_USAGE_E = 18_JPIB_K
INTEGER(KIND=JPIB_K), PARAMETER :: ARG_LAST_E = 18_JPIB_K

! Calls used to handle command line arguments
TYPE :: COMMAND_LINE_ARGS_T

  ! General behaviour
  LOGICAL :: VERBOSE=.FALSE.
  LOGICAL :: BIG_ENDIAN_READ=.FALSE.
  LOGICAL :: SKIP_VALUES=.FALSE.
  LOGICAL :: SKIP_FLUSH_LAST_STEP=.FALSE.
  INTEGER(KIND=JPIB_K) :: SEED=0_JPIB_K

  ! Main configuration switches
  CHARACTER(LEN=CMDARG_STRLEN) :: OUTPUT_MANAGER_TYPE=REPEAT(' ',CMDARG_STRLEN)
  CHARACTER(LEN=CMDARG_STRLEN) :: INPUT_DIR=REPEAT(' ',CMDARG_STRLEN)
  CHARACTER(LEN=CMDARG_STRLEN) :: YAML_CONFIGURATION=REPEAT(' ',CMDARG_STRLEN)
  CHARACTER(LEN=CMDARG_STRLEN) :: FILTERS_FILE=REPEAT(' ',CMDARG_STRLEN)


  ! Which data to be loaded
  LOGICAL :: MATCH_PROCESSORS=.TRUE.
  TYPE(KEYSET_INT64_T) :: PROCESSORS_SET

  ! Filters to be applied to the fields to be processed
  LOGICAL :: MATCH_PARAM=.TRUE.
  TYPE(KEYSET_INT64_T) :: PARAM_SET

  LOGICAL :: MATCH_LEVTYPE=.TRUE.
  TYPE(KEYSET_INT64_T) :: LEVTYPE_SET

  LOGICAL :: MATCH_REPRES=.TRUE.
  TYPE(KEYSET_INT64_T) :: REPRES_SET

  LOGICAL :: MATCH_STEP=.TRUE.
  TYPE(KEYSET_INT64_T) :: STEP_SET

  LOGICAL :: MATCH_LEVEL=.TRUE.
  TYPE(KEYSET_INT64_T) :: LEVEL_SET

  LOGICAL :: MATCH_FREQUENCY=.TRUE.
  TYPE(KEYSET_INT64_T) :: FREQUENCY_SET

  LOGICAL :: MATCH_DIRECTION=.TRUE.
  TYPE(KEYSET_INT64_T) :: DIRECTION_SET

CONTAINS


  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: INIT => INIT_COMMAND_LINE_ARGS
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: INIT_DEFAULT => DEFAULT_COMMAND_LINE_ARGS
  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: GET_CONFIGURATION_FILE => COMMAND_LINE_ARGS_GET_CONFIGURATION_FILE
  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: GET_VERBOSE => COMMAND_LINE_ARGS_GET_VERBOSE
  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: GET_SKIP_VALUES => COMMAND_LINE_ARGS_GET_SKIP_VALUES
  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: GET_SKIP_FLUSH_LAST_STEP => COMMAND_LINE_ARGS_GET_SKIP_FLUSH_LAST_STEP
  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: GET_READ_BIG_ENDIAN => COMMAND_LINE_ARGS_GET_READ_BIG_ENDIAN
  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: GET_TYPE => COMMAND_LINE_ARGS_GET_TYPE
  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: GET_PROCESSOR_LIST => COMMAND_LINE_ARGS_GET_PROCESSOR_LIST
  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: GET_DUMP_PATH => COMMAND_LINE_ARGS_GET_DUMP_PATH
  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: USAGE => COMMAND_LINE_ARGS_PRINT_USAGE
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: MATCH_ATM => COMMAND_LINE_ARGS_MATCH_ATM
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: MATCH_WAM => COMMAND_LINE_ARGS_MATCH_WAM
  GENERIC, PUBLIC :: MATCH => MATCH_ATM, MATCH_WAM
  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: PRINT => PRINT_COMMAND_LINE_ARGS
  PROCEDURE, PUBLIC,  PASS, NON_OVERRIDABLE :: FREE => FREE_COMMAND_LINE_ARGS


  ! Convert command line arguments to internal arguments
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: CARG2IARG_SHORT => CMDARG_CARG2IARG_SHORT
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: CARG2IARG_LONG => CMDARG_CARG2IARG_LONG
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: CHECK_ARGS_CONSISTENCY => CMDARG_CHECK_ARGS_CONSISTENCY


  ! Private methods to read command arguments
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_VERBOSE => CMDARG_PARSE_VERBOSE
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_BIG_ENDIAN => CMDARG_PARSE_BIG_ENDIAN
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_DUMP_PATH => CMDARG_PARSE_DUMP_PATH
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_SKIP_VALUES => CMDARG_PARSE_SKIP_VALUES
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_SKIP_FLUSH_LAST_STEP => CMDARG_PARSE_SKIP_FLUSH_LAST_STEP
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_OUTPUT_MANAGER_TYPE => CMDARG_PARSE_OUTPUT_MANAGER_TYPE
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_CONFIGURATION_FILE => CMDARG_PARSE_CONFIGURATION_FILE
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_PROCESSORS_LIST => CMDARG_PARSE_PROCESSORS_LIST
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_PARAM => CMDARG_PARSE_PARAM
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_REPRES => CMDARG_PARSE_REPRES
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_LEVTYPE => CMDARG_PARSE_LEVTYPE
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_LEVEL => CMDARG_PARSE_LEVEL
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_STEP => CMDARG_PARSE_STEP
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_FREQUENCY => CMDARG_PARSE_FREQUENCY
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_DIRECTION => CMDARG_PARSE_DIRECTION
  PROCEDURE, PRIVATE, PASS, NON_OVERRIDABLE :: PARSE_FILTER_FILE => CMDARG_PARSE_FILTER_FILE


END TYPE

! Whitelist of public symbols
PUBLIC :: COMMAND_LINE_ARGS_T

CONTAINS



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'INIT_COMMAND_LINE_ARGS'
PP_THREAD_SAFE FUNCTION INIT_COMMAND_LINE_ARGS( THIS, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(INOUT) :: THIS
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  TYPE(COMMAND_ARGUMENTS_TOKENIZER_T) :: CMDARGS
  INTEGER(KIND=JPIB_K) :: ARGID
  INTEGER(KIND=JPIB_K) :: ARGSCOUNT
  CHARACTER(LEN=CMDARG_STRLEN) :: ARG_NAME
  INTEGER(KIND=JPIB_K) :: MODIFIER_COUNT
  INTEGER(KIND=JPIB_K) :: ARG_ENUM
  INTEGER(KIND=JPIB_K), DIMENSION(ARG_LAST_E) :: ARGS_CHECKER
  LOGICAL :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER :: VALUES


  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INIT_CMDARGS = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_SIZE_CMDARGS = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NORMALISE_MODIFIER = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_MODIFIER = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CHECK_ARGS_CONSISTENCY = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_ARGUMENT = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_VERBOSE = 7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_BIG_ENDIAN = 8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_DUMP_PATH = 9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_SKIP_VALUES = 10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_SKIP_FLUSH_LAST_STEP = 11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_OUTPUT_MANAGER_TYPE = 12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_CONFIGURATION_FILE = 13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_PROCESSORS = 14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_PARAM = 15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_REPRES = 16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_LEVTYPE = 17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_LEVEL = 18_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_FREQUENCY = 20_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_DIRECTION = 21_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_STEP = 22_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_FILTER_FILE = 23_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_CMDARGS = 24_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INIT_DEFAULT_CMDARGS = 25_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PRINT_CMDARGS = 26_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PRINT_USAGE_FILE = 27_JPIB_K

  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET_MODIFIER = 28_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET_NAME = 29_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET_MATCH = 30_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET_VALUES = 31_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialize to the defaults
  PP_TRYCALL(ERRFLAG_INIT_DEFAULT_CMDARGS) THIS%INIT_DEFAULT( HOOKS )

  ! Initialize the command arguments tokenizer
  PP_TRYCALL(ERRFLAG_INIT_CMDARGS) CMDARGS%INIT( HOOKS )

  ! Print tokenized command line arguments
  ! PP_TRYCALL(ERRFLAG_PRINT_CMDARGS) CMDARGS%PRINT( 6_JPIB_K, HOOKS )

  ! Consume the command line arguments
  PP_TRYCALL(ERRFLAG_SIZE_CMDARGS) CMDARGS%SIZE( ARGSCOUNT, HOOKS )

  ! Initialize the args checker
  ARGS_CHECKER = 0_JPIB_K

  ! Consume the command line arguments
  DO ARGID = 1, ARGSCOUNT

    ! Initialize the values
    ARG_NAME = REPEAT(' ',CMDARG_STRLEN)

    ! Get the name of the flag and the modifier
    PP_TRYCALL(ERRFLAG_GET_MODIFIER) CMDARGS%GET_MODIFIER( ARGID, MODIFIER_COUNT, HOOKS )
    PP_TRYCALL(ERRFLAG_GET_NAME) CMDARGS%GET_NAME( ARGID, ARG_NAME, HOOKS )

    ! Normalize arguments name. Modifier cound is the number of '-' in the name of the argument
    ! This part of the code is used to parse the names and convert them to enum values
    SELECT CASE(MODIFIER_COUNT)
    CASE (1)
      PP_TRYCALL(ERRFLAG_NORMALISE_MODIFIER) THIS%CARG2IARG_SHORT( ARG_NAME, ARG_ENUM, HOOKS )
    CASE (2)
      PP_TRYCALL(ERRFLAG_NORMALISE_MODIFIER) THIS%CARG2IARG_LONG( ARG_NAME, ARG_ENUM, HOOKS )
    CASE DEFAULT
      PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_MODIFIER )
    END SELECT

    ! Update arguments checker
    ARGS_CHECKER(ARG_ENUM) = ARGS_CHECKER(ARG_ENUM) + 1_JPIB_K

    !
    ! Parse the command line arguments
    SELECT CASE(ARG_ENUM)

    CASE ( ARG_USAGE_E )
      PP_TRYCALL(ERRFLAG_PRINT_USAGE_FILE) THIS%USAGE( HOOKS )

    END SELECT

  END DO

  ! Check for consistency of the input flags (some flags can not be used together)
  PP_TRYCALL(ERRFLAG_CHECK_ARGS_CONSISTENCY) THIS%CHECK_ARGS_CONSISTENCY( ARGS_CHECKER, HOOKS )

  ! Initialize the args checker
  ARGS_CHECKER = 0_JPIB_K

  ! Consume the command line arguments
  DO ARGID = 1, ARGSCOUNT

    ! Initialize the values
    MODIFIER_COUNT = -1_JPIB_K
    ARG_NAME = REPEAT(' ',CMDARG_STRLEN)
    MATCH = .TRUE.
    VALUES => NULL()

    ! Get the name of the flag and the modifier
    PP_TRYCALL(ERRFLAG_GET_MODIFIER) CMDARGS%GET_MODIFIER( ARGID, MODIFIER_COUNT, HOOKS )
    PP_TRYCALL(ERRFLAG_GET_NAME) CMDARGS%GET_NAME( ARGID, ARG_NAME, HOOKS )
    PP_TRYCALL(ERRFLAG_GET_MATCH) CMDARGS%GET_MATCH( ARGID, MATCH, HOOKS )
    PP_TRYCALL(ERRFLAG_GET_VALUES) CMDARGS%GET_VALUES( ARGID, VALUES, HOOKS )

    ! Normalize arguments name. Modifier cound is the number of '-' in the name of the argument
    ! This part of the code is used to parse the names and convert them to enum values
    SELECT CASE(MODIFIER_COUNT)
    CASE (1)
      PP_TRYCALL(ERRFLAG_NORMALISE_MODIFIER) THIS%CARG2IARG_SHORT( ARG_NAME, ARG_ENUM, HOOKS )
    CASE (2)
      PP_TRYCALL(ERRFLAG_NORMALISE_MODIFIER) THIS%CARG2IARG_LONG( ARG_NAME, ARG_ENUM, HOOKS )
    CASE DEFAULT
      PP_DEBUG_CRITICAL_THROW( ERRFLAG_INVALID_MODIFIER )
    END SELECT

    ! Update arguments checker
    ARGS_CHECKER(ARG_ENUM) = ARGS_CHECKER(ARG_ENUM) + 1_JPIB_K

    !
    ! Parse the command line arguments
    SELECT CASE(ARG_ENUM)

    ! Management of the general behaviour
    CASE ( ARG_VERBOSE_E )
      PP_TRYCALL(ERRFLAG_PARSE_VERBOSE) THIS%PARSE_VERBOSE( MATCH, VALUES, HOOKS )

    CASE ( ARG_READ_BIG_ENDIAN_E )
      PP_TRYCALL(ERRFLAG_PARSE_BIG_ENDIAN) THIS%PARSE_BIG_ENDIAN( MATCH, VALUES, HOOKS )

    CASE ( ARG_DUMP_PATH_E )
      PP_TRYCALL(ERRFLAG_PARSE_DUMP_PATH) THIS%PARSE_DUMP_PATH( MATCH, VALUES, HOOKS )

    CASE ( ARG_SKIP_VALUES_E )
      PP_TRYCALL(ERRFLAG_PARSE_SKIP_VALUES) THIS%PARSE_SKIP_VALUES( MATCH, VALUES, HOOKS )

    CASE ( ARG_SKIP_FLUSH_LAST_STEP_E )
      PP_TRYCALL(ERRFLAG_PARSE_SKIP_FLUSH_LAST_STEP) THIS%PARSE_SKIP_FLUSH_LAST_STEP( MATCH, VALUES, HOOKS )

    CASE ( ARG_OUTPUT_MANAGER_E )
      PP_TRYCALL(ERRFLAG_PARSE_OUTPUT_MANAGER_TYPE) THIS%PARSE_OUTPUT_MANAGER_TYPE( MATCH, VALUES, HOOKS )

    CASE ( ARG_CONFIGURATION_FILE_E )
      PP_TRYCALL(ERRFLAG_PARSE_CONFIGURATION_FILE) THIS%PARSE_CONFIGURATION_FILE( MATCH, VALUES, HOOKS )

    CASE ( ARG_PROCESSORS_E )
      PP_TRYCALL(ERRFLAG_PARSE_PROCESSORS) THIS%PARSE_PROCESSORS_LIST( MATCH, VALUES, HOOKS )

    ! Filters (from command line)
    CASE ( ARG_PARAM_E )
      PP_TRYCALL(ERRFLAG_PARSE_PARAM) THIS%PARSE_PARAM( MATCH, VALUES, HOOKS )

    CASE ( ARG_REPRES_E )
      PP_TRYCALL(ERRFLAG_PARSE_REPRES) THIS%PARSE_REPRES( MATCH, VALUES, HOOKS )

    CASE ( ARG_LEVTYPE_E )
      PP_TRYCALL(ERRFLAG_PARSE_LEVTYPE) THIS%PARSE_LEVTYPE( MATCH, VALUES, HOOKS )

    CASE ( ARG_LEVEL_E )
      PP_TRYCALL(ERRFLAG_PARSE_LEVEL) THIS%PARSE_LEVEL( MATCH, VALUES, HOOKS )

    CASE ( ARG_FREQUENCY_E )
      PP_TRYCALL(ERRFLAG_PARSE_FREQUENCY) THIS%PARSE_FREQUENCY( MATCH, VALUES, HOOKS )

    CASE ( ARG_DIRCTION_E )
      PP_TRYCALL(ERRFLAG_PARSE_DIRECTION) THIS%PARSE_DIRECTION( MATCH, VALUES, HOOKS )

    CASE ( ARG_STEP_E )
      PP_TRYCALL(ERRFLAG_PARSE_STEP) THIS%PARSE_STEP( MATCH, VALUES, HOOKS )

    ! Filters (file)
    CASE ( ARG_FILTER_FILE_E )
      PP_TRYCALL(ERRFLAG_PARSE_FILTER_FILE) THIS%PARSE_FILTER_FILE( MATCH, VALUES, HOOKS )

    CASE DEFAULT
        PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_ARGUMENT )

    END SELECT

  END DO

  ! Initialize the command arguments tokenizer
  PP_TRYCALL(ERRFLAG_FREE_CMDARGS) CMDARGS%FREE( HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INIT_CMDARGS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error initializing the command arguments tokenizer' )
    CASE (ERRFLAG_SIZE_CMDARGS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error getting the size of the command arguments' )
    CASE (ERRFLAG_NORMALISE_MODIFIER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error normalising the modifier' )
    CASE (ERRFLAG_INVALID_MODIFIER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid modifier' )
    CASE (ERRFLAG_CHECK_ARGS_CONSISTENCY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking the consistency of the command line arguments' )
    CASE (ERRFLAG_UNKNOWN_ARGUMENT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown argument' )
    CASE (ERRFLAG_PARSE_VERBOSE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the verbose flag' )
    CASE (ERRFLAG_PARSE_BIG_ENDIAN)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the big endian flag' )
    CASE (ERRFLAG_PARSE_DUMP_PATH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the dump path flag' )
    CASE (ERRFLAG_PARSE_SKIP_VALUES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the use values flag' )
    CASE (ERRFLAG_PARSE_SKIP_FLUSH_LAST_STEP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the skip flush last step flag' )
    CASE (ERRFLAG_PARSE_OUTPUT_MANAGER_TYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the output manager type flag' )
    CASE (ERRFLAG_PARSE_CONFIGURATION_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the configuration file flag' )
    CASE (ERRFLAG_PARSE_PROCESSORS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the processors flag' )
    CASE (ERRFLAG_PARSE_PARAM)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the param flag' )
    CASE (ERRFLAG_PARSE_REPRES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the repres flag' )
    CASE (ERRFLAG_PARSE_LEVTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the levtype flag' )
    CASE (ERRFLAG_PARSE_LEVEL)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the level flag' )
    CASE (ERRFLAG_PARSE_STEP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the step flag' )
    CASE (ERRFLAG_PARSE_FREQUENCY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the frequency flag' )
    CASE (ERRFLAG_PARSE_DIRECTION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the direction flag' )
    CASE (ERRFLAG_PARSE_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing the filter file flag' )
    CASE (ERRFLAG_FREE_CMDARGS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error freeing the command arguments tokenizer' )
    CASE (ERRFLAG_INIT_DEFAULT_CMDARGS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error initializing the default command line arguments' )
    CASE (ERRFLAG_PRINT_CMDARGS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error printing command line arguments' )
    CASE (ERRFLAG_PRINT_USAGE_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Usage requested' )
    CASE (ERRFLAG_GET_MODIFIER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error getting the modifier' )
    CASE (ERRFLAG_GET_NAME)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error getting the name' )
    CASE (ERRFLAG_GET_MATCH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error getting the match' )
    CASE (ERRFLAG_GET_VALUES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error getting the values' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION INIT_COMMAND_LINE_ARGS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PRINT_COMMAND_LINE_ARGS'
PP_THREAD_SAFE FUNCTION PRINT_COMMAND_LINE_ARGS( THIS, UNIT, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: ENUMERATORS_MOD,                 ONLY: FUN_I2C_IF
  USE :: ENUMERATORS_MOD,                 ONLY: IREPRES2CREPRES
  ! USE :: ENUMERATORS_MOD,                 ONLY: IPREFIX2CPREFIX
  USE :: ENUMERATORS_MOD,                 ONLY: ILEVTYPE2CLEVTYPE

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: UNIT
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  PROCEDURE(FUN_I2C_IF), POINTER :: RFILTER
  INTEGER(KIND=JPIB_K) :: WRITE_STAT
  LOGICAL :: PROCESSOR_SET_IS_INITIALIZED
  LOGICAL :: PARAM_SET_IS_INITIALIZED
  LOGICAL :: LEVTYPE_SET_IS_INITIALIZED
  LOGICAL :: REPRES_SET_IS_INITIALIZED
  LOGICAL :: STEP_SET_IS_INITIALIZED
  LOGICAL :: LEVEL_SET_IS_INITIALIZED
  LOGICAL :: FREQUENCY_SET_IS_INITIALIZED
  LOGICAL :: DIRECTION_SET_IS_INITIALIZED

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZED_PROCESSORS_SET = 0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZED_PARAM_SET = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZED_LEVTYPE_SET = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZED_REPRES_SET = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZED_STEP_SET = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZED_LEVEL_SET = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZED_FREQUENCY_SET = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZED_DIRECTION_SET = 7_JPIB_K

  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PRINT_PROCESSORS_SET = 10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PRINT_PARAM_SET = 11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PRINT_LEVTYPE_SET = 12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PRINT_REPRES_SET = 13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PRINT_STEP_SET = 14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PRINT_LEVEL_SET = 15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PRINT_FREQUENCY_SET = 16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PRINT_DIRECTION_SET = 17_JPIB_K

  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRITE_ERROR = 20_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )


  ! Check initialization status
  PP_TRYCALL(ERRFLAG_INITIALIZED_PROCESSORS_SET) THIS%PROCESSORS_SET%INITIALIZED( PROCESSOR_SET_IS_INITIALIZED, HOOKS )
  PP_TRYCALL(ERRFLAG_INITIALIZED_PARAM_SET) THIS%PARAM_SET%INITIALIZED( PARAM_SET_IS_INITIALIZED, HOOKS )
  PP_TRYCALL(ERRFLAG_INITIALIZED_LEVTYPE_SET) THIS%LEVTYPE_SET%INITIALIZED( LEVTYPE_SET_IS_INITIALIZED, HOOKS )
  PP_TRYCALL(ERRFLAG_INITIALIZED_REPRES_SET) THIS%REPRES_SET%INITIALIZED( REPRES_SET_IS_INITIALIZED, HOOKS )
  PP_TRYCALL(ERRFLAG_INITIALIZED_STEP_SET) THIS%STEP_SET%INITIALIZED( STEP_SET_IS_INITIALIZED, HOOKS )
  PP_TRYCALL(ERRFLAG_INITIALIZED_LEVEL_SET) THIS%LEVEL_SET%INITIALIZED( LEVEL_SET_IS_INITIALIZED, HOOKS )
  PP_TRYCALL(ERRFLAG_INITIALIZED_FREQUENCY_SET) THIS%FREQUENCY_SET%INITIALIZED( FREQUENCY_SET_IS_INITIALIZED, HOOKS )
  PP_TRYCALL(ERRFLAG_INITIALIZED_DIRECTION_SET) THIS%DIRECTION_SET%INITIALIZED( DIRECTION_SET_IS_INITIALIZED, HOOKS )

  ! Header
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' SUMMARY OF COMMAND LINE ARGUMENTS'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )

  ! Print Verbose
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A,L1)', IOSTAT=WRITE_STAT ) 'VERBOSE: ', THIS%VERBOSE
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )

  ! Print Read big endian
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A,L1)', IOSTAT=WRITE_STAT ) 'READ-BIG-ENDIAN: ', THIS%BIG_ENDIAN_READ
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )

  ! Print Use Values
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A,L1)', IOSTAT=WRITE_STAT ) 'SKIP VALUES: ', THIS%SKIP_VALUES
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )

  ! Print Skip flush last step
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A,L1)', IOSTAT=WRITE_STAT ) 'SKIP FLUSH LAST STEP: ', THIS%SKIP_FLUSH_LAST_STEP
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )

  ! Print Output Manager Type
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'OUTPUT MANAGER TYPE: "'//TRIM(ADJUSTL(THIS%OUTPUT_MANAGER_TYPE))//'"'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )

  ! Print Configuration File
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'CONFIGURATION FILE: "'//TRIM(ADJUSTL(THIS%YAML_CONFIGURATION))//'"'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )

  ! Print Dump Path
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'DUMP PATH: "'//TRIM(ADJUSTL(THIS%INPUT_DIR))//'"'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )

  ! Print the sets
  IF ( PROCESSOR_SET_IS_INITIALIZED ) THEN
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    IF ( THIS%MATCH_PROCESSORS ) THEN
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'MATCH PROCESSORS: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ELSE
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'IGNORE PROCESSORS: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ENDIF
    PP_TRYCALL(ERRFLAG_PRINT_PROCESSORS_SET) THIS%PROCESSORS_SET%LIST( UNIT, ' - processors: ', HOOKS )
  ENDIF

  IF ( PARAM_SET_IS_INITIALIZED ) THEN
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    IF ( THIS%MATCH_PARAM ) THEN
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'MATCH PARAM: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ELSE
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'IGNORE PARAM: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ENDIF
    PP_TRYCALL(ERRFLAG_PRINT_PARAM_SET) THIS%PARAM_SET%LIST( UNIT, ' - param: ', HOOKS )
  ENDIF

  IF ( LEVTYPE_SET_IS_INITIALIZED ) THEN
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    IF ( THIS%MATCH_LEVTYPE ) THEN
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'MATCH LEVTYPE: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ELSE
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'IGNORE LEVTYPE: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ENDIF
    ! RFILTER => IPREFIX2CPREFIX
    RFILTER => ILEVTYPE2CLEVTYPE
    PP_TRYCALL(ERRFLAG_PRINT_LEVTYPE_SET) THIS%LEVTYPE_SET%LIST_WITH_FILTER( UNIT, ' - levtype: ', RFILTER, HOOKS )
  ENDIF

  IF ( REPRES_SET_IS_INITIALIZED ) THEN
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    IF ( THIS%MATCH_REPRES ) THEN
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'MATCH REPRES: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ELSE
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'IGNORE REPRES: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ENDIF
    RFILTER => IREPRES2CREPRES
    PP_TRYCALL(ERRFLAG_PRINT_REPRES_SET) THIS%REPRES_SET%LIST_WITH_FILTER( UNIT, ' - repres: ', RFILTER, HOOKS )
  ENDIF

  IF ( STEP_SET_IS_INITIALIZED ) THEN
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    IF ( THIS%MATCH_STEP ) THEN
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'MATCH STEP: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ELSE
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'IGNORE STEP: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ENDIF
    PP_TRYCALL(ERRFLAG_PRINT_STEP_SET) THIS%STEP_SET%LIST( UNIT, ' - step: ', HOOKS )
  ENDIF

  IF ( LEVEL_SET_IS_INITIALIZED ) THEN
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    IF ( THIS%MATCH_LEVEL ) THEN
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'MATCH LEVEL: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ELSE
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'IGNORE LEVEL: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ENDIF
    PP_TRYCALL(ERRFLAG_PRINT_LEVEL_SET) THIS%LEVEL_SET%LIST( UNIT, ' - level: ', HOOKS )
  ENDIF

  IF ( FREQUENCY_SET_IS_INITIALIZED ) THEN
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    IF ( THIS%MATCH_FREQUENCY ) THEN
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'MATCH FREQUENCY: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ELSE
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'IGNORE FREQUENCY: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ENDIF
    PP_TRYCALL(ERRFLAG_PRINT_FREQUENCY_SET) THIS%FREQUENCY_SET%LIST( UNIT, ' - frequency: ', HOOKS )
  ENDIF

  IF ( DIRECTION_SET_IS_INITIALIZED ) THEN
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    IF ( THIS%MATCH_DIRECTION ) THEN
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'MATCH DIRECTION: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ELSE
      WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) 'IGNORE DIRECTION: '
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
    ENDIF
    PP_TRYCALL(ERRFLAG_PRINT_DIRECTION_SET) THIS%DIRECTION_SET%LIST( UNIT, ' - direction: ', HOOKS )
  ENDIF

  ! Footer of command line arguments
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) ' '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )
  WRITE(UNIT, '(A)', IOSTAT=WRITE_STAT ) '----------------------------------------------'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_WRITE_ERROR )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_PRINT_PROCESSORS_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error print the processors set' )
    CASE (ERRFLAG_PRINT_PARAM_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error print the param set' )
    CASE (ERRFLAG_PRINT_LEVTYPE_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error print the levtype set' )
    CASE (ERRFLAG_PRINT_REPRES_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error print the repres set' )
    CASE (ERRFLAG_PRINT_STEP_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error print the step set' )
    CASE (ERRFLAG_PRINT_LEVEL_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error print the level set' )
    CASE (ERRFLAG_PRINT_FREQUENCY_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error print the frequency set' )
    CASE (ERRFLAG_PRINT_DIRECTION_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error print the direction set' )
    CASE (ERRFLAG_INITIALIZED_PROCESSORS_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking the initialization of the processors set' )
    CASE (ERRFLAG_INITIALIZED_PARAM_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking the initialization of the param set' )
    CASE (ERRFLAG_INITIALIZED_LEVTYPE_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking the initialization of the levtype set' )
    CASE (ERRFLAG_INITIALIZED_REPRES_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking the initialization of the repres set' )
    CASE (ERRFLAG_INITIALIZED_STEP_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking the initialization of the step set' )
    CASE (ERRFLAG_INITIALIZED_LEVEL_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking the initialization of the level set' )
    CASE (ERRFLAG_INITIALIZED_FREQUENCY_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking the initialization of the frequency set' )
    CASE (ERRFLAG_INITIALIZED_DIRECTION_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking the initialization of the direction set' )
    CASE (ERRFLAG_WRITE_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error writing to the output unit' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PRINT_COMMAND_LINE_ARGS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FREE_COMMAND_LINE_ARGS'
PP_THREAD_SAFE FUNCTION FREE_COMMAND_LINE_ARGS( THIS, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(INOUT) :: THIS
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_PROCESSORS_SET = 0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_PARAM_SET = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_LEVTYPE_SET = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_REPRES_SET = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_STEP_SET = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_LEVEL_SET = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_FREQUENCY_SET = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_DIRECTION_SET = 7_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Free the sets
  PP_TRYCALL(ERRFLAG_FREE_PROCESSORS_SET) THIS%PROCESSORS_SET%FREE( HOOKS )
  PP_TRYCALL(ERRFLAG_FREE_PARAM_SET) THIS%PARAM_SET%FREE( HOOKS )
  PP_TRYCALL(ERRFLAG_FREE_LEVTYPE_SET) THIS%LEVTYPE_SET%FREE( HOOKS )
  PP_TRYCALL(ERRFLAG_FREE_REPRES_SET) THIS%REPRES_SET%FREE( HOOKS )
  PP_TRYCALL(ERRFLAG_FREE_STEP_SET) THIS%STEP_SET%FREE( HOOKS )
  PP_TRYCALL(ERRFLAG_FREE_LEVEL_SET) THIS%LEVEL_SET%FREE( HOOKS )
  PP_TRYCALL(ERRFLAG_FREE_FREQUENCY_SET) THIS%FREQUENCY_SET%FREE( HOOKS )
  PP_TRYCALL(ERRFLAG_FREE_DIRECTION_SET) THIS%DIRECTION_SET%FREE( HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_FREE_PROCESSORS_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error freeing the processors set' )
    CASE (ERRFLAG_FREE_PARAM_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error freeing the param set' )
    CASE (ERRFLAG_FREE_LEVTYPE_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error freeing the levtype set' )
    CASE (ERRFLAG_FREE_REPRES_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error freeing the repres set' )
    CASE (ERRFLAG_FREE_STEP_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error freeing the step set' )
    CASE (ERRFLAG_FREE_LEVEL_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error freeing the level set' )
    CASE (ERRFLAG_FREE_FREQUENCY_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error freeing the frequency set' )
    CASE (ERRFLAG_FREE_DIRECTION_SET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error freeing the direction set' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FREE_COMMAND_LINE_ARGS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'COMMAND_LINE_ARGS_PRINT_USAGE'
PP_THREAD_SAFE FUNCTION COMMAND_LINE_ARGS_PRINT_USAGE( THIS, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD, ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(IN)    :: THIS
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: WRITE_STAT
  CHARACTER(LEN=1024) :: CTMP

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PRINT_USAGE_FILE = 0_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Print the usage
  CTMP = REPEAT( ' ', 1024)
  CALL GET_COMMAND_ARGUMENT( 0, CTMP )

  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )

  WRITE( *, '(A)', IOSTAT=WRITE_STAT) 'Usage: '//TRIM(ADJUSTL(CTMP))//' [options]'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) 'This tool is used to navigate through the dump files and send the data to the output manager'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) 'according to some filter configuration that allows to select the fields to be processed'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) 'The filters can be defined through the command line or through a filter file'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) 'On the command line a filter is defined as: <modifier><flag> <operation?><[list]value>'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '  - <modifier> used to define the kind of flag, it can be: "-" or "--"'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '  - <flag> name of the flag'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '  - <operation> can be missing or "^"; when missing the filter correspond to a "match" operation, when "^" the filter correspond to an "ignore" operation'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '  - <[list]value> can be in different format depending on the flag name and it is described below'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) 'Options can be:'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -v, --verbose'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      Flag only'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: Enable verbose mode'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -u, --skip-values, without-values, metadata-only'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      Flag only'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: Skip the values (values are not readed if present in order to speed up the process)'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -e, --skip-flush-last-step'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      Flag only'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: Skip the last-step flushes'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -t, --type, --output-manager-type'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      scalar string'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: Output manager type, possible values currently supported are: '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '        - GRIB-HEADER-TO-MULTIO: send grib header to multio in order to be encoded'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -i, --input-path, --dump-path, --dump-dir, --dump-directory, --input-dir, --input-directory'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      scalar string'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: Input path where the files of the dump are located'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -y, --output-manager-yaml, --yaml, --configuration-file'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      scalar string'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: Main configuration file for the output manager in yaml format'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -c, --processors-list, --task-list, --cpu-list'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      array of integers'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: List of processors info (IOserver tasks) to be matched/ignored from the dump by the output manager'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                   If missing all processors are considered'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -p, --param, --paramId'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      array of integers'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: List of paramIds to be matched/ignored from the dump by the output manager'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                   If missing all parameters are considered'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -r, --repres'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      array of strings'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: List of representations to be matched/ignored from the dump by the output manager'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                   If missing all representations are considered'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      supported values: '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                     - sh (spectral harmonics)'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                     - gg (gaussian grid)'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -m, --levtype'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      array of strings'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: List of levtypes to be matched/ignored from the dump by the output manager'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                   If missing all levtype are considered'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      supported values: '
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                     - ml (model level)'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                     - pl (pressure level)'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                     - pv (potential vorticity)'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                     - pt (potential temperature)'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                     - th (theta level)'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                     - sfc (surface)'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                     - al (abstract layer)'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                     - hl (height level)'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -l, --level, --levelist'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      array of integers'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: List of levels to be matched/ignored from the dump by the output manager'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                   If missing all levels are considered'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -f, --frequency'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      array of integers'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: List of wave frequencies to be matched/ignored from the dump by the output manager'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                   If missing all frequencies are considered'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -d, --direction'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      array of integers'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: List of wave directions to be matched/ignored from the dump by the output manager'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -s, --step'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      array of integers'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: List of steps to be matched/ignored from the dump by the output manager'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '                   If missing all directions are considered'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -h, --help, --usage'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      Flag only'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: Print this help message'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) ''
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '*  -f, --filter-file, --test-file'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      format:      scalar string'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )
  WRITE( *, '(A)', IOSTAT=WRITE_STAT) '      description: Filter file in yaml format to be used instead of the command line options'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0_JPIB_K, ERRFLAG_PRINT_USAGE_FILE )




  ! After print usage need to stop
  STOP 0

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION COMMAND_LINE_ARGS_PRINT_USAGE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'COMMAND_LINE_ARGS_GET_CONFIGURATION_FILE'
PP_THREAD_SAFE FUNCTION COMMAND_LINE_ARGS_GET_CONFIGURATION_FILE( THIS, CONFIGURATION_FILE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(IN)    :: THIS
  CHARACTER(LEN=*),           INTENT(OUT)   :: CONFIGURATION_FILE
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_LEN = 1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Wrong length
  PP_DEBUG_CRITICAL_COND_THROW( LEN_TRIM(THIS%YAML_CONFIGURATION).GT.LEN(CONFIGURATION_FILE), ERRFLAG_WRONG_LEN )

  ! Copy the configuration file
  CONFIGURATION_FILE = REPEAT( ' ', LEN(CONFIGURATION_FILE) )
  CONFIGURATION_FILE = TRIM(ADJUSTL(THIS%YAML_CONFIGURATION))


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_WRONG_LEN)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong length of the configuration file' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION COMMAND_LINE_ARGS_GET_CONFIGURATION_FILE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'COMMAND_LINE_ARGS_GET_DUMP_PATH'
PP_THREAD_SAFE FUNCTION COMMAND_LINE_ARGS_GET_DUMP_PATH( THIS, DUMP_PATH, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(IN)    :: THIS
  CHARACTER(LEN=*),           INTENT(OUT)   :: DUMP_PATH
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_LEN = 1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Wrong length
  PP_DEBUG_CRITICAL_COND_THROW( LEN(DUMP_PATH).LE.LEN_TRIM(THIS%INPUT_DIR), ERRFLAG_WRONG_LEN )

  ! Copy the configuration file
  DUMP_PATH = REPEAT( ' ', LEN(DUMP_PATH) )
  DUMP_PATH = TRIM(ADJUSTL(THIS%INPUT_DIR))


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_WRONG_LEN)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong length of the dump direcotry: "'//TRIM(ADJUSTL(THIS%INPUT_DIR))//'"' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION COMMAND_LINE_ARGS_GET_DUMP_PATH
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'COMMAND_LINE_ARGS_GET_TYPE'
PP_THREAD_SAFE FUNCTION COMMAND_LINE_ARGS_GET_TYPE( THIS, TYPE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(IN)    :: THIS
  CHARACTER(LEN=*),           INTENT(OUT)   :: TYPE
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_LEN = 1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Wrong length
  PP_DEBUG_CRITICAL_COND_THROW( LEN_TRIM(THIS%OUTPUT_MANAGER_TYPE).GT.LEN(TYPE), ERRFLAG_WRONG_LEN )

  ! Copy the configuration file
  TYPE = REPEAT( ' ', LEN(TYPE) )
  TYPE = TRIM(ADJUSTL(THIS%OUTPUT_MANAGER_TYPE))


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_WRONG_LEN)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong length of the configuration file' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION COMMAND_LINE_ARGS_GET_TYPE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'COMMAND_LINE_ARGS_GET_VERBOSE'
PP_THREAD_SAFE FUNCTION COMMAND_LINE_ARGS_GET_VERBOSE( THIS, VERBOSE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(IN)    :: THIS
  LOGICAL,                    INTENT(OUT)   :: VERBOSE
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Copy the configuration file
  VERBOSE = THIS%VERBOSE

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION COMMAND_LINE_ARGS_GET_VERBOSE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'COMMAND_LINE_ARGS_GET_SKIP_VALUES'
PP_THREAD_SAFE FUNCTION COMMAND_LINE_ARGS_GET_SKIP_VALUES( THIS, SKIP_VALUES, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(IN)    :: THIS
  LOGICAL,                    INTENT(OUT)   :: SKIP_VALUES
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Copy the configuration file
  SKIP_VALUES = THIS%SKIP_VALUES

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION COMMAND_LINE_ARGS_GET_SKIP_VALUES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'COMMAND_LINE_ARGS_GET_SKIP_FLUSH_LAST_STEP'
PP_THREAD_SAFE FUNCTION COMMAND_LINE_ARGS_GET_SKIP_FLUSH_LAST_STEP( THIS, SKIP_FLUSH_LAST_STEP, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(IN)    :: THIS
  LOGICAL,                    INTENT(OUT)   :: SKIP_FLUSH_LAST_STEP
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Copy the configuration file
  SKIP_FLUSH_LAST_STEP = THIS%SKIP_FLUSH_LAST_STEP

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION COMMAND_LINE_ARGS_GET_SKIP_FLUSH_LAST_STEP
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'COMMAND_LINE_ARGS_GET_READ_BIG_ENDIAN'
PP_THREAD_SAFE FUNCTION COMMAND_LINE_ARGS_GET_READ_BIG_ENDIAN( THIS, READ_BIG_ENDIAN, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(IN)    :: THIS
  LOGICAL,                    INTENT(OUT)   :: READ_BIG_ENDIAN
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Copy the configuration file
  READ_BIG_ENDIAN = THIS%BIG_ENDIAN_READ

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION COMMAND_LINE_ARGS_GET_READ_BIG_ENDIAN
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'COMMAND_LINE_ARGS_MATCH_ATM'
PP_THREAD_SAFE FUNCTION COMMAND_LINE_ARGS_MATCH_ATM( THIS, PARAM, REPRES, PREFIX, LEVEL, STEP, MATCH, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: ENUMERATORS_MOD,                 ONLY: IPREFIX2ILEVTYPE
  USE :: ENUMERATORS_MOD,                 ONLY: UNDEF_PARAM_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: PARAM
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: REPRES
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: PREFIX
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: LEVEL
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: STEP
  LOGICAL,                    INTENT(OUT)   :: MATCH
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: LEVTYPE
  LOGICAL :: INITIALIZED
  LOGICAL :: FOUND

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PREFIX_TO_LEVTYPE = 3_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Copy the configuration file
  MATCH = .TRUE.

  ! Match param
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%PARAM_SET%INITIALIZED( INITIALIZED, HOOKS )
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_MATCH) THIS%PARAM_SET%MATCH( PARAM, FOUND, HOOKS )
    IF ( THIS%MATCH_PARAM ) THEN
      MATCH = MATCH .AND.FOUND
    ELSE
      MATCH = MATCH .AND. .NOT.FOUND
    ENDIF
  ENDIF

  ! Match repres
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%REPRES_SET%INITIALIZED( INITIALIZED, HOOKS )
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_MATCH) THIS%REPRES_SET%MATCH( REPRES, FOUND, HOOKS )
    IF ( THIS%MATCH_REPRES ) THEN
      MATCH = MATCH .AND. FOUND
    ELSE
      MATCH = MATCH .AND. .NOT.FOUND
    ENDIF
  ENDIF

  ! Match levtype
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%LEVTYPE_SET%INITIALIZED( INITIALIZED, HOOKS )
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_PREFIX_TO_LEVTYPE) IPREFIX2ILEVTYPE( PREFIX, PARAM, LEVEL, REPRES, LEVTYPE, HOOKS )
    PP_TRYCALL(ERRFLAG_MATCH) THIS%LEVTYPE_SET%MATCH( LEVTYPE, FOUND, HOOKS )
    IF ( THIS%MATCH_LEVTYPE ) THEN
      MATCH = MATCH .AND. FOUND
    ELSE
      MATCH = MATCH .AND. .NOT.FOUND
    ENDIF
  ENDIF

  ! Match level
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%LEVEL_SET%INITIALIZED( INITIALIZED, HOOKS )
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_MATCH) THIS%LEVEL_SET%MATCH( LEVEL, FOUND, HOOKS )
    IF ( THIS%MATCH_LEVEL ) THEN
      MATCH = MATCH .AND. FOUND
    ELSE
      MATCH = MATCH .AND. .NOT.FOUND
    ENDIF
  ENDIF

  ! Match step
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%STEP_SET%INITIALIZED( INITIALIZED, HOOKS )
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_MATCH) THIS%STEP_SET%MATCH( STEP, FOUND, HOOKS )
    IF ( THIS%MATCH_STEP ) THEN
      MATCH = MATCH .AND. FOUND
    ELSE
      MATCH = MATCH .AND. .NOT.FOUND
    ENDIF
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_MATCH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check if set match' )
    CASE (ERRFLAG_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check if set is initialized' )
    CASE (ERRFLAG_PREFIX_TO_LEVTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert prefix to levtype' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION COMMAND_LINE_ARGS_MATCH_ATM
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'COMMAND_LINE_ARGS_MATCH_WAM'
PP_THREAD_SAFE FUNCTION COMMAND_LINE_ARGS_MATCH_WAM( THIS, PARAM, REPRES, PREFIX, FREQUENCY, DIRECTION, STEP, MATCH, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: ENUMERATORS_MOD,                 ONLY: IPREFIX2ILEVTYPE
  USE :: ENUMERATORS_MOD,                 ONLY: UNDEF_PARAM_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: PARAM
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: REPRES
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: PREFIX
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: FREQUENCY
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: DIRECTION
  INTEGER(KIND=JPIB_K),       INTENT(IN)    :: STEP
  LOGICAL,                    INTENT(OUT)   :: MATCH
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: LEVTYPE
  LOGICAL :: INITIALIZED
  LOGICAL :: FOUND

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PREFIX_TO_LEVTYPE = 3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Copy the configuration file
  MATCH = .TRUE.

  ! Match param
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%PARAM_SET%INITIALIZED( INITIALIZED, HOOKS )
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_MATCH) THIS%PARAM_SET%MATCH( PARAM, FOUND, HOOKS )
    IF ( THIS%MATCH_PARAM ) THEN
      MATCH = MATCH .AND.FOUND
    ELSE
      MATCH = MATCH .AND. .NOT.FOUND
    ENDIF
  ENDIF

  ! Match repres
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%REPRES_SET%INITIALIZED( INITIALIZED, HOOKS )
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_MATCH) THIS%REPRES_SET%MATCH( REPRES, FOUND, HOOKS )
    IF ( THIS%MATCH_REPRES ) THEN
      MATCH = MATCH .AND. FOUND
    ELSE
      MATCH = MATCH .AND. .NOT.FOUND
    ENDIF
  ENDIF

  ! Match levtype
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%LEVTYPE_SET%INITIALIZED( INITIALIZED, HOOKS )
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_PREFIX_TO_LEVTYPE) IPREFIX2ILEVTYPE( PREFIX, PARAM, UNDEF_PARAM_E, REPRES, LEVTYPE, HOOKS )
    PP_TRYCALL(ERRFLAG_MATCH) THIS%LEVTYPE_SET%MATCH( LEVTYPE, FOUND, HOOKS )
    IF ( THIS%MATCH_LEVTYPE ) THEN
      MATCH = MATCH .AND. FOUND
    ELSE
      MATCH = MATCH .AND. .NOT.FOUND
    ENDIF
  ENDIF

  ! Match frequency
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%FREQUENCY_SET%INITIALIZED( INITIALIZED, HOOKS )
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_MATCH) THIS%FREQUENCY_SET%MATCH( FREQUENCY, FOUND, HOOKS )
    IF ( THIS%MATCH_FREQUENCY ) THEN
      MATCH = MATCH .AND. FOUND
    ELSE
      MATCH = MATCH .AND. .NOT.FOUND
    ENDIF
  ENDIF

  ! Match direction
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%DIRECTION_SET%INITIALIZED( INITIALIZED, HOOKS )
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_MATCH) THIS%DIRECTION_SET%MATCH( DIRECTION, FOUND, HOOKS )
    IF ( THIS%MATCH_DIRECTION ) THEN
      MATCH = MATCH .AND. FOUND
    ELSE
      MATCH = MATCH .AND. .NOT.FOUND
    ENDIF
  ENDIF

  ! Match step
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%STEP_SET%INITIALIZED( INITIALIZED, HOOKS )
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_MATCH) THIS%STEP_SET%MATCH( STEP, FOUND, HOOKS )
    IF ( THIS%MATCH_STEP ) THEN
      MATCH = MATCH .AND. FOUND
    ELSE
      MATCH = MATCH .AND. .NOT.FOUND
    ENDIF
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_MATCH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check if set match' )
    CASE (ERRFLAG_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check if set is initialized' )
    CASE (ERRFLAG_PREFIX_TO_LEVTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert prefix to levtype' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION COMMAND_LINE_ARGS_MATCH_WAM
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'COMMAND_LINE_ARGS_GET_PROCESSOR_LIST'
PP_THREAD_SAFE FUNCTION COMMAND_LINE_ARGS_GET_PROCESSOR_LIST( THIS, PROCESSOR_LIST, NPROCS, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                      INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K), DIMENSION(:), ALLOCATABLE, INTENT(OUT)   :: PROCESSOR_LIST
  INTEGER(KIND=JPIB_K),                            INTENT(IN)    :: NPROCS
  TYPE(HOOKS_T),                                   INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: INITIALIZED
  INTEGER(KIND=JPIB_K) :: SZ
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: STAT
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALREADY_ALLOCATED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOCATE_PROCESSOR_LIST =2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZED = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_SIZE = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_SIZE = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OUT_OF_BOUNDS = 7_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Check if the processor list is already allocated
  PP_DEBUG_CRITICAL_COND_THROW( ALLOCATED(PROCESSOR_LIST), ERRFLAG_ALREADY_ALLOCATED )
  PP_DEBUG_CRITICAL_COND_THROW( NPROCS.LT.1, ERRFLAG_WRONG_SIZE )

  ! Check initialization status of processor list
  PP_TRYCALL(ERRFLAG_INITIALIZED) THIS%PROCESSORS_SET%INITIALIZED( INITIALIZED, HOOKS )

  ! GEt and check processor list
  IF ( INITIALIZED ) THEN
    PP_TRYCALL(ERRFLAG_SIZE) THIS%PROCESSORS_SET%GET_SIZE( SZ, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( SZ.LT.1, ERRFLAG_WRONG_SIZE )
    ALLOCATE( PROCESSOR_LIST(SZ), STAT=STAT, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( STAT.NE.0, ERRFLAG_ALLOCATE_PROCESSOR_LIST )
    PP_TRYCALL(ERRFLAG_GET) THIS%PROCESSORS_SET%GET_SORTED_KEYS( PROCESSOR_LIST, HOOKS )
    DO I = 1, SZ
      PP_DEBUG_CRITICAL_COND_THROW( PROCESSOR_LIST(I).LT.1, ERRFLAG_OUT_OF_BOUNDS )
      PP_DEBUG_CRITICAL_COND_THROW( PROCESSOR_LIST(I).GT.NPROCS, ERRFLAG_OUT_OF_BOUNDS )
    END DO
  ELSE
    ALLOCATE( PROCESSOR_LIST(NPROCS), STAT=STAT, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( STAT.NE.0, ERRFLAG_ALLOCATE_PROCESSOR_LIST )
    DO I = 1, NPROCS
      PROCESSOR_LIST(I) = I
    END DO
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_ALREADY_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Processor list already allocated' )
    CASE (ERRFLAG_ALLOCATE_PROCESSOR_LIST)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error allocating the processor list' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error message: ' // TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(  ERRMSG, STAT=STAT )
      ENDIF
    CASE (ERRFLAG_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check if set is initialized' )
    CASE (ERRFLAG_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get the size of the processor list' )
    CASE (ERRFLAG_GET)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get the processor list' )
    CASE (ERRFLAG_WRONG_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong size of the processor list' )
    CASE (ERRFLAG_OUT_OF_BOUNDS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Processor list out of bounds' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION COMMAND_LINE_ARGS_GET_PROCESSOR_LIST
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'DEFAULT_COMMAND_LINE_ARGS'
PP_THREAD_SAFE FUNCTION DEFAULT_COMMAND_LINE_ARGS( THIS, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: COMMAND_ARGUMENTS_TOKENIZER_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T), INTENT(INOUT) :: THIS
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Default initialization
  THIS%VERBOSE = .FALSE.
  THIS%INPUT_DIR = './'
  THIS%YAML_CONFIGURATION = './output-manager-cfg.yaml'
  THIS%OUTPUT_MANAGER_TYPE = 'GRIB-HEADER-TO-MULTIO'

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point on success
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()


    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION DEFAULT_COMMAND_LINE_ARGS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_CARG2IARG_SHORT'
PP_THREAD_SAFE FUNCTION CMDARG_CARG2IARG_SHORT( THIS, CARG, IARG, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),   INTENT(INOUT) :: THIS
  CHARACTER(LEN=CMDARG_STRLEN), INTENT(IN)    :: CARG
  INTEGER(KIND=JPIB_K),         INTENT(OUT)   :: IARG
  TYPE(HOOKS_T),                INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_ARGUMENT = 1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! select the proper command line argument
  SELECT CASE(TRIM(ADJUSTL(CARG)))

  CASE ( 'v' )
    IARG = ARG_VERBOSE_E

  CASE ( 'i' )
    IARG = ARG_DUMP_PATH_E

  CASE ( 'u' )
    IARG = ARG_SKIP_VALUES_E

  CASE ( 'e' )
    IARG = ARG_SKIP_FLUSH_LAST_STEP_E

  CASE ( 't' )
    IARG = ARG_OUTPUT_MANAGER_E

  CASE ( 'y' )
    IARG = ARG_CONFIGURATION_FILE_E

  CASE ( 'c' )
    IARG = ARG_PROCESSORS_E

  CASE ( 'p' )
    IARG = ARG_PARAM_E

  CASE ( 'r' )
    IARG = ARG_REPRES_E

  CASE ( 'm' )
    IARG = ARG_LEVTYPE_E

  CASE ( 'l' )
    IARG = ARG_LEVEL_E

  CASE ( 'f' )
    IARG = ARG_FREQUENCY_E

  CASE ( 'd' )
    IARG = ARG_DIRCTION_E

  CASE ( 'q' )
    IARG = ARG_FILTER_FILE_E

  CASE ( 's' )
    IARG = ARG_STEP_E

  CASE ( 'b' )
    IARG = ARG_READ_BIG_ENDIAN_E

  CASE ( 'h' )
    IARG = ARG_USAGE_E

  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_ARGUMENT )

  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_ARGUMENT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown command line argument argument' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'flag: '//TRIM(ADJUSTL(CARG)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_CARG2IARG_SHORT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_CARG2IARG_LONG'
PP_THREAD_SAFE FUNCTION CMDARG_CARG2IARG_LONG( THIS, CARG, IARG, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),   INTENT(INOUT) :: THIS
  CHARACTER(LEN=CMDARG_STRLEN), INTENT(IN)    :: CARG
  INTEGER(KIND=JPIB_K),         INTENT(OUT)   :: IARG
  TYPE(HOOKS_T),                INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_ARGUMENT = 1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )



  ! select the proper command line argument
  SELECT CASE(TRIM(ADJUSTL(CARG)))

  CASE ( 'verbose' )
    IARG = ARG_VERBOSE_E

  CASE ( 'input-path', 'dump-path', 'dump-dir', 'dump-directory', 'input-dir', 'input-directory' )
    IARG = ARG_DUMP_PATH_E

  CASE ( 'skip-values', 'without-values', 'metadata-only' )
    IARG = ARG_SKIP_VALUES_E

  CASE ( 'skip-flush-last-step' )
    IARG = ARG_SKIP_FLUSH_LAST_STEP_E

  CASE ( 'output-manager-type', 'type' )
    IARG = ARG_OUTPUT_MANAGER_E

  CASE ( 'output-manager-yaml', 'yaml', 'configuration-file' )
    IARG = ARG_CONFIGURATION_FILE_E

  CASE ( 'processors-list', 'task-list', 'cpu-list' )
    IARG = ARG_PROCESSORS_E

  CASE ( 'param', 'paramId' )
    IARG = ARG_PARAM_E

  CASE ( 'repres' )
    IARG = ARG_REPRES_E

  CASE ( 'levtype', 'prefix' )
    IARG = ARG_LEVTYPE_E

  CASE ( 'level', 'levelist' )
    IARG = ARG_LEVEL_E

  CASE ( 'frequency' )
    IARG = ARG_FREQUENCY_E

  CASE ( 'direction' )
    IARG = ARG_DIRCTION_E

  CASE ( 'filter-file', 'test-file' )
    IARG = ARG_FILTER_FILE_E

  CASE ( 'step' )
    IARG = ARG_STEP_E

  CASE ( 'big-endian-read' )
    IARG = ARG_READ_BIG_ENDIAN_E

  CASE ( 'help', 'usage' )
    IARG = ARG_USAGE_E

  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_ARGUMENT )

  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_ARGUMENT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown command line argument argument' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'flag: '//TRIM(ADJUSTL(CARG)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_CARG2IARG_LONG
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_CHECK_ARGS_CONSISTENCY'
PP_THREAD_SAFE FUNCTION CMDARG_CHECK_ARGS_CONSISTENCY( THIS, ARGS_CHACKER, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                  INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K), DIMENSION(ARG_LAST_E), INTENT(IN)    :: ARGS_CHACKER
  TYPE(HOOKS_T),                               INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: I

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MULTIPLE_ARGS_WITH_SAME_FLAG = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_DUMP_PATH_ARG = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_OUTPUT_MANAGER_ARG = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_CONFIGURATION_FILE_ARG = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DUMP_PATH_WITH_FILTER_FILE = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OUTPUT_MANAGER_WITH_FILTER_FILE = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONFIGURATION_FILE_WITH_FILTER_FILE = 7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PROCESSORS_WITH_FILTER_FILE = 8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARAM_WITH_FILTER_FILE = 9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_REPRES_WITH_FILTER_FILE = 10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_LEVTYPE_WITH_FILTER_FILE = 11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_LEVEL_WITH_FILTER_FILE = 12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREQUENCY_WITH_FILTER_FILE = 13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DIRCTION_WITH_FILTER_FILE = 14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_SKIP_VALUES_WITH_FILTER_FILE = 15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_SKIP_FLUSH_LAST_STEP_WITH_FILTER_FILE = 16_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Most trivial check
  DO I = 1, SIZE(ARGS_CHACKER)
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(I) .GT. 1, ERRFLAG_MULTIPLE_ARGS_WITH_SAME_FLAG )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(I) .LT. 0, ERRFLAG_MULTIPLE_ARGS_WITH_SAME_FLAG )
  END DO

  ! Main distinction is through filter file
  IF ( ARGS_CHACKER(ARG_FILTER_FILE_E) .EQ.0 ) THEN
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_DUMP_PATH_E).EQ.0, ERRFLAG_NO_DUMP_PATH_ARG )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_OUTPUT_MANAGER_E).EQ.0, ERRFLAG_NO_OUTPUT_MANAGER_ARG )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_CONFIGURATION_FILE_E).EQ.0, ERRFLAG_NO_CONFIGURATION_FILE_ARG )
  ELSE
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_DUMP_PATH_E).NE.0, ERRFLAG_DUMP_PATH_WITH_FILTER_FILE )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_OUTPUT_MANAGER_E).NE.0, ERRFLAG_OUTPUT_MANAGER_WITH_FILTER_FILE )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_CONFIGURATION_FILE_E).NE.0, ERRFLAG_CONFIGURATION_FILE_WITH_FILTER_FILE )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_PROCESSORS_E).NE.0, ERRFLAG_PROCESSORS_WITH_FILTER_FILE )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_PARAM_E).NE.0, ERRFLAG_PARAM_WITH_FILTER_FILE )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_REPRES_E).NE.0, ERRFLAG_REPRES_WITH_FILTER_FILE )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_LEVTYPE_E).NE.0, ERRFLAG_LEVTYPE_WITH_FILTER_FILE )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_LEVEL_E).NE.0, ERRFLAG_LEVEL_WITH_FILTER_FILE )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_FREQUENCY_E).NE.0, ERRFLAG_FREQUENCY_WITH_FILTER_FILE )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_DIRCTION_E).NE.0, ERRFLAG_DIRCTION_WITH_FILTER_FILE )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_SKIP_VALUES_E).NE.0, ERRFLAG_SKIP_VALUES_WITH_FILTER_FILE )
    PP_DEBUG_CRITICAL_COND_THROW( ARGS_CHACKER(ARG_SKIP_FLUSH_LAST_STEP_E).NE.0, ERRFLAG_SKIP_FLUSH_LAST_STEP_WITH_FILTER_FILE )
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_MULTIPLE_ARGS_WITH_SAME_FLAG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Multiple arguments with the same flag' )
    CASE (ERRFLAG_NO_DUMP_PATH_ARG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'No dump path argument' )
    CASE (ERRFLAG_NO_OUTPUT_MANAGER_ARG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'No output manager argument' )
    CASE (ERRFLAG_NO_CONFIGURATION_FILE_ARG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'No configuration file argument' )
    CASE (ERRFLAG_DUMP_PATH_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dump path argument with filter file' )
    CASE (ERRFLAG_OUTPUT_MANAGER_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Output manager argument with filter file' )
    CASE (ERRFLAG_CONFIGURATION_FILE_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Configuration file argument with filter file' )
    CASE (ERRFLAG_PROCESSORS_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Processors argument with filter file' )
    CASE (ERRFLAG_PARAM_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Param argument with filter file' )
    CASE (ERRFLAG_REPRES_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Repres argument with filter file' )
    CASE (ERRFLAG_LEVTYPE_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Levtype argument with filter file' )
    CASE (ERRFLAG_LEVEL_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Level argument with filter file' )
    CASE (ERRFLAG_FREQUENCY_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Frequency argument with filter file' )
    CASE (ERRFLAG_DIRCTION_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Direction argument with filter file' )
    CASE (ERRFLAG_SKIP_VALUES_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Skip Values argument with filter file' )
    CASE (ERRFLAG_SKIP_FLUSH_LAST_STEP_WITH_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Skip flush last step with filter file' )

    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_CHECK_ARGS_CONSISTENCY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_VERBOSE'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_VERBOSE( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_NOT_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_NOT_EXPECTED = 2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. MATCH, ERRFLAG_MATCH_NOT_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( ASSOCIATED(VALUES), ERRFLAG_VALUES_NOT_EXPECTED )

  ! Parse the verbosity flag
  THIS%VERBOSE = .TRUE.

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_MATCH_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Match not expected' )
    CASE (ERRFLAG_VALUES_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values not expected' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_VERBOSE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_BIG_ENDIAN'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_BIG_ENDIAN( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_NOT_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_NOT_EXPECTED = 2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. MATCH, ERRFLAG_MATCH_NOT_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( ASSOCIATED(VALUES), ERRFLAG_VALUES_NOT_EXPECTED )

  ! Parse the verbosity flag
  THIS%BIG_ENDIAN_READ = .TRUE.

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_MATCH_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Match not expected' )
    CASE (ERRFLAG_VALUES_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values not expected' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_BIG_ENDIAN
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_DUMP_PATH'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_DUMP_PATH( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: GENERAL_UTILS_MOD,               ONLY: REPLACE_ENVVAR_IN_STRING
  USE :: GENERAL_UTILS_MOD,               ONLY: IS_DIRECTORY

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL :: EXISTS
  CHARACTER(LEN=CMDARG_STRLEN) :: DUMP_PATH

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_NOT_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUES_COUNT = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CHECK_DUMP_PATH = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_DUMP_PATH = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_EXPAND_ENVVAR = 6_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Parse the dump path flag
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. MATCH, ERRFLAG_MATCH_NOT_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(VALUES) .NE. 1, ERRFLAG_INVALID_VALUES_COUNT )

  ! Copy input value to local variable
  DUMP_PATH = REPEAT( ' ', CMDARG_STRLEN )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_EXPAND_ENVVAR) REPLACE_ENVVAR_IN_STRING( VALUES(1), DUMP_PATH, HOOKS )

  ! Set the dump path
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_DUMP_PATH) IS_DIRECTORY( TRIM(ADJUSTL(DUMP_PATH)), EXISTS, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. EXISTS, ERRFLAG_INVALID_DUMP_PATH )

  ! Set the dump path
  THIS%INPUT_DIR = REPEAT( ' ', CMDARG_STRLEN )
  THIS%INPUT_DIR = TRIM(ADJUSTL(DUMP_PATH))

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Debug variables
    CHARACTER(LEN=32) :: TMP
    INTEGER(KIND=JPIB_K) :: STATUS

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_MATCH_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Match not expected' )
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected' )
    CASE (ERRFLAG_INVALID_VALUES_COUNT)
      TMP = REPEAT(' ',32)
      WRITE(TMP, '(I32)', IOSTAT=STATUS) SIZE(VALUES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid values count' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'expected: 1' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'got: '//TRIM(ADJUSTL(TMP)) )
    CASE (ERRFLAG_UNABLE_TO_CHECK_DUMP_PATH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check dump path' )
    CASE (ERRFLAG_INVALID_DUMP_PATH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dump path does not exist' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'current path: "'//TRIM(ADJUSTL(DUMP_PATH))//'"' )
    CASE (ERRFLAG_UNABLE_TO_EXPAND_ENVVAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to expand environment variable' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'variable: "'//TRIM(ADJUSTL(VALUES(1)))//'"' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_DUMP_PATH
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_SKIP_VALUES'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_SKIP_VALUES( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_NOT_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_NOT_EXPECTED = 2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. MATCH, ERRFLAG_MATCH_NOT_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( ASSOCIATED(VALUES), ERRFLAG_VALUES_NOT_EXPECTED )

  ! Parse the use values flag
  THIS%SKIP_VALUES = .TRUE.

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_MATCH_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Match not expected' )
    CASE (ERRFLAG_VALUES_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values not expected' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_SKIP_VALUES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_SKIP_FLUSH_LAST_STEP'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_SKIP_FLUSH_LAST_STEP( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_NOT_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_NOT_EXPECTED = 2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. MATCH, ERRFLAG_MATCH_NOT_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( ASSOCIATED(VALUES), ERRFLAG_VALUES_NOT_EXPECTED )

  ! Parse the use values flag
  THIS%SKIP_FLUSH_LAST_STEP = .TRUE.

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_MATCH_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Match not expected' )
    CASE (ERRFLAG_VALUES_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values not expected' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_SKIP_FLUSH_LAST_STEP
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_OUTPUT_MANAGER_TYPE'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_OUTPUT_MANAGER_TYPE( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: GENERAL_UTILS_MOD,               ONLY: REPLACE_ENVVAR_IN_STRING
  USE :: OUTPUT_MANAGER_FACTORY_MOD,      ONLY: IS_VALID_OUTPUT_MANAGER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=CMDARG_STRLEN) :: OUTPUT_MANAGER_TYPE
  LOGICAL :: IS_VALID

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_NOT_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_OUTPUT_MANAGER_TYPE = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_EXPAND_ENVVAR = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CHECK_OUTPUT_MANAGER_TYPE = 5_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. MATCH, ERRFLAG_MATCH_NOT_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )

  ! Copy input value to local variable
  OUTPUT_MANAGER_TYPE = REPEAT( ' ', CMDARG_STRLEN )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_EXPAND_ENVVAR) REPLACE_ENVVAR_IN_STRING( VALUES(1), OUTPUT_MANAGER_TYPE, HOOKS )

  ! Check the output manager type
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_OUTPUT_MANAGER_TYPE) IS_VALID_OUTPUT_MANAGER( TRIM(ADJUSTL(OUTPUT_MANAGER_TYPE)), IS_VALID, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. IS_VALID, ERRFLAG_INVALID_OUTPUT_MANAGER_TYPE )

  ! Set the output manager type
  THIS%OUTPUT_MANAGER_TYPE = REPEAT( ' ', CMDARG_STRLEN )
  THIS%OUTPUT_MANAGER_TYPE = TRIM(ADJUSTL(OUTPUT_MANAGER_TYPE))

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_MATCH_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Match not expected' )
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected' )
    CASE (ERRFLAG_INVALID_OUTPUT_MANAGER_TYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid output manager type' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'type: '//TRIM(ADJUSTL(OUTPUT_MANAGER_TYPE)) )
    CASE (ERRFLAG_UNABLE_TO_EXPAND_ENVVAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to expand environment variable' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'variable: '//TRIM(ADJUSTL(VALUES(1))) )
    CASE (ERRFLAG_UNABLE_TO_CHECK_OUTPUT_MANAGER_TYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check output manager type' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_OUTPUT_MANAGER_TYPE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_CONFIGURATION_FILE'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_CONFIGURATION_FILE( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: GENERAL_UTILS_MOD,               ONLY: REPLACE_ENVVAR_IN_STRING


  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL :: EXISTS
  INTEGER(KIND=JPIB_K) :: STATUS
  CHARACTER(LEN=CMDARG_STRLEN) :: CONFIGURATION_FILE

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_NOT_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUES_COUNT = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_CONFIGURATION_FILE = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_EXPAND_ENVVAR = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CHECK_CONFIGURATION_FILE = 6_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Parse the dump path flag
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. MATCH, ERRFLAG_MATCH_NOT_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(VALUES) .NE. 1, ERRFLAG_INVALID_VALUES_COUNT )

  ! Copy input value to local variable
  CONFIGURATION_FILE = REPEAT( ' ', CMDARG_STRLEN )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_EXPAND_ENVVAR) REPLACE_ENVVAR_IN_STRING( VALUES(1), CONFIGURATION_FILE, HOOKS )

  ! Set the dump path
  INQUIRE( FILE=TRIM(ADJUSTL(CONFIGURATION_FILE)), EXIST=EXISTS, IOSTAT=STATUS )
  PP_DEBUG_CRITICAL_COND_THROW( STATUS .NE. 0, ERRFLAG_UNABLE_TO_CHECK_CONFIGURATION_FILE )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. EXISTS, ERRFLAG_INVALID_CONFIGURATION_FILE )

  ! Set the dump path
  THIS%YAML_CONFIGURATION = REPEAT( ' ', CMDARG_STRLEN )
  THIS%YAML_CONFIGURATION = TRIM(ADJUSTL(CONFIGURATION_FILE))

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_MATCH_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Match not expected' )
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected' )
    CASE (ERRFLAG_INVALID_VALUES_COUNT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid values count' )
    CASE (ERRFLAG_INVALID_CONFIGURATION_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid configuration file' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'file: '//TRIM(ADJUSTL(CONFIGURATION_FILE)) )
    CASE (ERRFLAG_UNABLE_TO_EXPAND_ENVVAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to expand environment variable' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'variable: '//TRIM(ADJUSTL(VALUES(1))) )
    CASE (ERRFLAG_UNABLE_TO_CHECK_CONFIGURATION_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check configuration file' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'file: '//TRIM(ADJUSTL(CONFIGURATION_FILE)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_CONFIGURATION_FILE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_PROCESSORS_LIST'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_PROCESSORS_LIST( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: INITIALIZED

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUES_COUNT = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_INTEGER_ARRAY = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CHECK_INITIALIZED = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALREADY_INITIALIZED = 5_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Check initialization status
  PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%PROCESSORS_SET%INITIALIZED( INITIALIZED, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( INITIALIZED, ERRFLAG_ALREADY_INITIALIZED )

  ! Parse the dump path flag
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(VALUES) .LT. 1, ERRFLAG_INVALID_VALUES_COUNT )

  ! Read integer array with ranges
  THIS%MATCH_PROCESSORS = MATCH
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%PROCESSORS_SET%INIT( HOOKS )
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) READ_INTEGER_KEYSET_WITH_RANGES( VALUES, THIS%PROCESSORS_SET, HOOKS )
  !PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%PROCESSORS_SET%LIST( 6_JPIB_K, ' - processors: ', HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected for "processors" flag' )
    CASE (ERRFLAG_INVALID_VALUES_COUNT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid values count for "processors" flag' )
    CASE (ERRFLAG_READ_INTEGER_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading integer array' )

    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_PROCESSORS_LIST
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_PARAM'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_PARAM( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: INITIALIZED

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUES_COUNT = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_INTEGER_ARRAY = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CHECK_INITIALIZED = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALREADY_INITIALIZED = 5_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Check initialization status
  PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%PARAM_SET%INITIALIZED( INITIALIZED, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( INITIALIZED, ERRFLAG_ALREADY_INITIALIZED )

  ! Parse the dump path flag
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(VALUES) .LT. 1, ERRFLAG_INVALID_VALUES_COUNT )

  ! Read integer array with ranges
  THIS%MATCH_PARAM = MATCH
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%PARAM_SET%INIT( HOOKS )
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) READ_INTEGER_KEYSET_WITH_RANGES( VALUES, THIS%PARAM_SET, HOOKS )
  !PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%PARAM_SET%LIST( 6_JPIB_K, ' - param: ', HOOKS )



  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected for "param" flag' )
    CASE (ERRFLAG_INVALID_VALUES_COUNT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid values count for "param" flag' )
    CASE (ERRFLAG_READ_INTEGER_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading integer array' )
    CASE (ERRFLAG_CHECK_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking initialization status' )
    CASE (ERRFLAG_ALREADY_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Already initialized' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_PARAM
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_REPRES'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_REPRES( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: ENUMERATORS_MOD,                 ONLY: CREPRES2IREPRES
  USE :: ENUMERATORS_MOD,                 ONLY: IREPRES2CREPRES
  USE :: YAML_CORE_UTILS_MOD,             ONLY: FUN_C2I_IF
  USE :: ENUMERATORS_MOD,                 ONLY: FUN_I2C_IF

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: INITIALIZED
  PROCEDURE(FUN_C2I_IF), POINTER :: FILTER
  PROCEDURE(FUN_I2C_IF), POINTER :: RFILTER

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUES_COUNT = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_INTEGER_ARRAY = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CHECK_INITIALIZED = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALREADY_INITIALIZED = 5_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Check initialization status
  PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%REPRES_SET%INITIALIZED( INITIALIZED, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( INITIALIZED, ERRFLAG_ALREADY_INITIALIZED )

  ! Parse the dump path flag
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(VALUES) .LT. 1, ERRFLAG_INVALID_VALUES_COUNT )

  ! Read integer array with ranges
  THIS%MATCH_REPRES = MATCH
  FILTER => CREPRES2IREPRES
  RFILTER => IREPRES2CREPRES

  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%REPRES_SET%INIT( HOOKS )
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) READ_INTEGER_KEYSET_WITH_FILTER( VALUES, THIS%REPRES_SET, FILTER, HOOKS )
  !PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%REPRES_SET%LIST_WITH_FILTER( 6_JPIB_K, ' - repres: ', RFILTER, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected' )
    CASE (ERRFLAG_INVALID_VALUES_COUNT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid values count' )
    CASE (ERRFLAG_READ_INTEGER_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading integer array' )
    CASE (ERRFLAG_CHECK_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking initialization status' )
    CASE (ERRFLAG_ALREADY_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Already initialized' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_REPRES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_LEVTYPE'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_LEVTYPE( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  ! USE :: ENUMERATORS_MOD,                 ONLY: CPREFIX2IPREFIX
  ! USE :: ENUMERATORS_MOD,                 ONLY: IPREFIX2CPREFIX
  USE :: ENUMERATORS_MOD,                 ONLY: CLEVTYPE2ILEVTYPE
  USE :: YAML_CORE_UTILS_MOD,             ONLY: FUN_C2I_IF
  USE :: ENUMERATORS_MOD,                 ONLY: FUN_I2C_IF

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: INITIALIZED
  PROCEDURE(FUN_C2I_IF), POINTER :: FILTER
  ! PROCEDURE(FUN_I2C_IF), POINTER :: RFILTER

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUES_COUNT = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_INTEGER_ARRAY = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CHECK_INITIALIZED = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALREADY_INITIALIZED = 5_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Check initialization status
  PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%LEVTYPE_SET%INITIALIZED( INITIALIZED, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( INITIALIZED, ERRFLAG_ALREADY_INITIALIZED )

  ! Parse the dump path flag
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(VALUES) .LT. 1, ERRFLAG_INVALID_VALUES_COUNT )

  ! Read integer array with ranges
  THIS%MATCH_LEVTYPE = MATCH
  ! FILTER => CPREFIX2IPREFIX
  FILTER => CLEVTYPE2ILEVTYPE

  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%LEVTYPE_SET%INIT( HOOKS )
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) READ_INTEGER_KEYSET_WITH_FILTER( VALUES, THIS%LEVTYPE_SET, FILTER, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected for "levtype" flag' )
    CASE (ERRFLAG_INVALID_VALUES_COUNT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid values count for "levtype" flag' )
    CASE (ERRFLAG_READ_INTEGER_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading integer array' )
    CASE (ERRFLAG_CHECK_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking initialization status' )
    CASE (ERRFLAG_ALREADY_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Already initialized' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_LEVTYPE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_LEVEL'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_LEVEL( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: INITIALIZED

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUES_COUNT = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_INTEGER_ARRAY = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CHECK_INITIALIZED = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALREADY_INITIALIZED = 5_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Check initialization status
  PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%LEVEL_SET%INITIALIZED( INITIALIZED, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( INITIALIZED, ERRFLAG_ALREADY_INITIALIZED )

  ! Parse the dump path flag
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(VALUES) .LT. 1, ERRFLAG_INVALID_VALUES_COUNT )

  ! Read integer array with ranges
  THIS%MATCH_LEVEL = MATCH
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%LEVEL_SET%INIT( HOOKS )
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) READ_INTEGER_KEYSET_WITH_RANGES( VALUES, THIS%LEVEL_SET, HOOKS )
  !PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%LEVEL_SET%LIST( 6_JPIB_K, ' - levelist: ', HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected for "level" flag' )
    CASE (ERRFLAG_INVALID_VALUES_COUNT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid values count for "level" flag' )
    CASE (ERRFLAG_READ_INTEGER_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading integer array' )
    CASE (ERRFLAG_CHECK_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking initialization status' )
    CASE (ERRFLAG_ALREADY_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Already initialized' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_LEVEL
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_STEP'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_STEP( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: INITIALIZED

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUES_COUNT = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_INTEGER_ARRAY = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CHECK_INITIALIZED = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALREADY_INITIALIZED = 5_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Check initialization status
  PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%STEP_SET%INITIALIZED( INITIALIZED, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( INITIALIZED, ERRFLAG_ALREADY_INITIALIZED )

  ! Parse the dump path flag
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(VALUES) .LT. 1, ERRFLAG_INVALID_VALUES_COUNT )

  ! Read integer array with ranges
  THIS%MATCH_STEP = MATCH
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%STEP_SET%INIT( HOOKS )
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) READ_INTEGER_KEYSET_WITH_RANGES( VALUES, THIS%STEP_SET, HOOKS )
  !PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%STEP_SET%LIST( 6_JPIB_K, ' - step: ', HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected for "step" flag' )
    CASE (ERRFLAG_INVALID_VALUES_COUNT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid values count for "step" flag' )
    CASE (ERRFLAG_READ_INTEGER_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading integer array' )
    CASE (ERRFLAG_CHECK_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking initialization status' )
    CASE (ERRFLAG_ALREADY_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Already initialized' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_STEP
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_FREQUENCY'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_FREQUENCY( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: INITIALIZED

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUES_COUNT = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_INTEGER_ARRAY = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CHECK_INITIALIZED = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALREADY_INITIALIZED = 5_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Check initialization status
  PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%FREQUENCY_SET%INITIALIZED( INITIALIZED, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( INITIALIZED, ERRFLAG_ALREADY_INITIALIZED )

  ! Parse the dump path flag
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(VALUES) .LT. 1, ERRFLAG_INVALID_VALUES_COUNT )

  ! Read integer array with ranges
  THIS%MATCH_FREQUENCY = MATCH
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%FREQUENCY_SET%INIT( HOOKS )
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) READ_INTEGER_KEYSET_WITH_RANGES( VALUES, THIS%FREQUENCY_SET, HOOKS )
  !PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%FREQUENCY_SET%LIST( 6_JPIB_K, ' - frequency: ', HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected for "frequency" flag' )
    CASE (ERRFLAG_INVALID_VALUES_COUNT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid values count for "frequency" flag' )
    CASE (ERRFLAG_READ_INTEGER_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading integer array' )
    CASE (ERRFLAG_CHECK_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking initialization status' )
    CASE (ERRFLAG_ALREADY_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Already initialized' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_FREQUENCY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_DIRECTION'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_DIRECTION( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: INITIALIZED

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUES_COUNT = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_INTEGER_ARRAY = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CHECK_INITIALIZED = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALREADY_INITIALIZED = 5_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Check initialization status
  PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%DIRECTION_SET%INITIALIZED( INITIALIZED, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( INITIALIZED, ERRFLAG_ALREADY_INITIALIZED )

  ! Parse the dump path flag
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(VALUES) .LT. 1, ERRFLAG_INVALID_VALUES_COUNT )

  ! Read integer array with ranges
  THIS%MATCH_DIRECTION = MATCH
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%DIRECTION_SET%INIT( HOOKS )
  PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) READ_INTEGER_KEYSET_WITH_RANGES( VALUES, THIS%DIRECTION_SET, HOOKS )
  !PP_TRYCALL(ERRFLAG_READ_INTEGER_ARRAY) THIS%DIRECTION_SET%LIST( 6_JPIB_K, ' - direction: ', HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected' )
    CASE (ERRFLAG_INVALID_VALUES_COUNT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid values count' )
    CASE (ERRFLAG_READ_INTEGER_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading integer array' )
    CASE (ERRFLAG_CHECK_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error checking initialization status' )
    CASE (ERRFLAG_ALREADY_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Already initialized' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_DIRECTION
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMDARG_PARSE_FILTER_FILE'
PP_THREAD_SAFE FUNCTION CMDARG_PARSE_FILTER_FILE( THIS, MATCH, VALUES, HOOKS )  RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: GENERAL_UTILS_MOD,               ONLY: REPLACE_ENVVAR_IN_STRING
  USE :: YAML_CORE_UTILS_MOD,             ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD,             ONLY: YAML_NEW_CONFIGURATION_FROM_FILE
  USE :: YAML_CORE_UTILS_MOD,             ONLY: YAML_DELETE_CONFIGURATION
  USE :: YAML_CORE_UTILS_MOD,             ONLY: YAML_GET_SUBCONFIGURATION
  USE :: YAML_CORE_UTILS_MOD,             ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD,             ONLY: YAML_READ_STRING
  USE :: YAML_CORE_UTILS_MOD,             ONLY: YAML_READ_STRING_WITH_ENV_EXPANSION
  USE :: YAML_CORE_UTILS_MOD,             ONLY: YAML_READ_INTEGER_KEYSET_WITH_RANGES
  USE :: YAML_CORE_UTILS_MOD,             ONLY: YAML_READ_INTEGER_KEYSET_WITH_FILTER
  USE :: ENUMERATORS_MOD,                 ONLY: CREPRES2IREPRES
  USE :: ENUMERATORS_MOD,                 ONLY: CPREFIX2IPREFIX
  USE :: ENUMERATORS_MOD,                 ONLY: CLEVTYPE2ILEVTYPE
  USE :: YAML_CORE_UTILS_MOD,             ONLY: FUN_C2I_IF

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(COMMAND_LINE_ARGS_T),                          INTENT(INOUT) :: THIS
  LOGICAL,                                             INTENT(IN)    :: MATCH
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: VALUES
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL :: EXISTS
  INTEGER(KIND=JPIB_K) :: CNT
  INTEGER(KIND=JPIB_K) :: STATUS
  INTEGER(KIND=JPIB_K) :: ALLOC_STAT
  INTEGER(KIND=JPIB_K) :: DEALLOC_STAT
  INTEGER(KIND=JPIB_K) :: READ_STAT
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  CHARACTER(LEN=CMDARG_STRLEN) :: FILTER_FILE
  CHARACTER(LEN=CMDARG_STRLEN), POINTER, DIMENSION(:) :: CTMP
  CHARACTER(LEN=:), ALLOCATABLE :: ATMP
  TYPE(YAML_CONFIGURATION_T) :: MAIN_CFG
  TYPE(YAML_CONFIGURATION_T) :: OPTIONS_CFG
  TYPE(YAML_CONFIGURATION_T) :: FILTERS_CFG
  TYPE(YAML_CONFIGURATION_T) :: FILTER_CFG
  LOGICAL :: HAS_KEY
  LOGICAL :: HAS_OPTIONS
  LOGICAL :: HAS_FILTERS
  LOGICAL :: HAS_FILTER
  LOGICAL :: FILTER_INITIALIZED
  PROCEDURE(FUN_C2I_IF), POINTER :: FILTER

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_NOT_EXPECTED = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUES_EXPECTED = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_VALUES_COUNT = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_FILTER_FILE = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_EXPAND_ENVVAR = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CHECK_FILTER_FILE = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_OPEN_CFG_FILE = 7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_HAS_KEY = 8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DESTROY_CFG = 9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ALLOCATE_STRING = 10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DEALLOCATE_STRING = 11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_CONFIGURATION_FILE = 12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_TYPE = 13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_DUMP_PATH = 14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_STRING = 15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_TOO_LONG = 16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET_SUBCFG = 17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_BOOL = 18_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_VALUES = 19_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_FILTERS = 20_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CHECK_INITIALIZED = 21_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZE_FILTER = 22_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Parse the dump path flag
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. MATCH, ERRFLAG_MATCH_NOT_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. ASSOCIATED(VALUES), ERRFLAG_VALUES_EXPECTED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(VALUES) .NE. 1, ERRFLAG_INVALID_VALUES_COUNT )

  ! Copy input value to local variable
  FILTER_FILE = REPEAT( ' ', CMDARG_STRLEN )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_EXPAND_ENVVAR) REPLACE_ENVVAR_IN_STRING( VALUES(1), FILTER_FILE, HOOKS )

  ! Set the dump path
  INQUIRE( FILE=TRIM(ADJUSTL(FILTER_FILE)), EXIST=EXISTS, IOSTAT=STATUS )
  PP_DEBUG_CRITICAL_COND_THROW( STATUS .NE. 0, ERRFLAG_UNABLE_TO_CHECK_FILTER_FILE )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. EXISTS, ERRFLAG_INVALID_FILTER_FILE )

  ! Set the dump path
  THIS%FILTERS_FILE = REPEAT( ' ', CMDARG_STRLEN )
  THIS%FILTERS_FILE = TRIM(ADJUSTL(FILTER_FILE))

  ! Allocate the values array
  CTMP => NULL()
  ALLOCATE( CTMP(1), STAT=ALLOC_STAT, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_ALLOCATE_STRING )

  IF ( ALLOCATED(ATMP) ) THEN
    DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )
  ENDIF

  ! Open the filename
  PP_TRYCALL(ERRFLAG_UNABLE_TO_OPEN_CFG_FILE) YAML_NEW_CONFIGURATION_FROM_FILE( TRIM(THIS%FILTERS_FILE), MAIN_CFG, HOOKS )

  !
  ! Read output manager yaml
  PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( MAIN_CFG, 'multio-output-manager-yaml', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )

  ! Read output manager yaml
  CTMP(1) = REPEAT( ' ', CMDARG_STRLEN )
  PP_TRYCALL(ERRFLAG_READ_STRING) YAML_READ_STRING_WITH_ENV_EXPANSION( MAIN_CFG, 'multio-output-manager-yaml', ATMP, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
  PP_DEBUG_CRITICAL_COND_THROW( LEN(ATMP).GT.CMDARG_STRLEN, ERRFLAG_TOO_LONG )
  CTMP(1) = TRIM(ADJUSTL(ATMP))
  DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
  PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )
  PP_TRYCALL(ERRFLAG_READ_CONFIGURATION_FILE) THIS%PARSE_CONFIGURATION_FILE( .TRUE., CTMP, HOOKS )


  !
  ! Read output manager type
  PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( MAIN_CFG, 'multio-output-manager-type', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )

  ! Read output manager type
  CTMP(1) = REPEAT( ' ', CMDARG_STRLEN )
  PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING( MAIN_CFG, 'multio-output-manager-type', ATMP, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
  PP_DEBUG_CRITICAL_COND_THROW( LEN(ATMP).GT.CMDARG_STRLEN, ERRFLAG_TOO_LONG )
  CTMP(1) = TRIM(ADJUSTL(ATMP))
  DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
  PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )
  PP_TRYCALL(ERRFLAG_READ_TYPE) THIS%PARSE_OUTPUT_MANAGER_TYPE( .TRUE., CTMP, HOOKS )


  !
  ! Read output manager type
  PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( MAIN_CFG, 'dump-path', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )

  ! Read output manager type
  CTMP(1) = REPEAT( ' ', CMDARG_STRLEN )
  PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING_WITH_ENV_EXPANSION( MAIN_CFG, 'dump-path', ATMP, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
  PP_DEBUG_CRITICAL_COND_THROW( LEN(ATMP).GT.CMDARG_STRLEN, ERRFLAG_TOO_LONG )
  CTMP(1) = TRIM(ADJUSTL(ATMP))
  DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
  PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )
  PP_TRYCALL(ERRFLAG_READ_DUMP_PATH) THIS%PARSE_DUMP_PATH( .TRUE., CTMP, HOOKS )


  !
  ! Get sub-configuration from input file
  PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( MAIN_CFG, 'options', HAS_OPTIONS, HOOKS )
  !
  ! Read options

  ! Options counter
  CNT = 0_JPIB_K
  IF (HAS_OPTIONS) THEN

    ! Get the specific sub-configuration
    PP_TRYCALL(ERRFLAG_GET_SUBCFG) YAML_GET_SUBCONFIGURATION( MAIN_CFG, 'options', OPTIONS_CFG, HOOKS )

    !
    ! Read output manager type
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( OPTIONS_CFG, 'verbose', HAS_KEY, HOOKS )

    IF ( HAS_KEY ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Read output manager verbose
      CTMP(1) = REPEAT( ' ', CMDARG_STRLEN )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING_WITH_ENV_EXPANSION( OPTIONS_CFG, 'verbose', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      READ(ATMP,*,IOSTAT=READ_STAT) THIS%VERBOSE
      PP_DEBUG_CRITICAL_COND_THROW( READ_STAT.NE.0, ERRFLAG_READ_BOOL )
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
    ENDIF

    !
    ! Read output manager read-big-endian
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( OPTIONS_CFG, 'read-big-endian', HAS_KEY, HOOKS )

    IF ( HAS_KEY ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Read output manager type
      CTMP(1) = REPEAT( ' ', CMDARG_STRLEN )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING_WITH_ENV_EXPANSION( OPTIONS_CFG, 'read-big-endian', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      READ(ATMP,*,IOSTAT=READ_STAT) THIS%BIG_ENDIAN_READ
      PP_DEBUG_CRITICAL_COND_THROW( READ_STAT.NE.0, ERRFLAG_READ_BOOL )
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
    ENDIF

    !
    ! Read output manager type
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( OPTIONS_CFG, 'skip-values', HAS_KEY, HOOKS )

    IF ( HAS_KEY ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Read output manager type
      CTMP(1) = REPEAT( ' ', CMDARG_STRLEN )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING_WITH_ENV_EXPANSION( OPTIONS_CFG, 'skip-values', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      READ(ATMP,*,IOSTAT=READ_STAT) THIS%SKIP_VALUES
      PP_DEBUG_CRITICAL_COND_THROW( READ_STAT.NE.0, ERRFLAG_READ_BOOL )
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
    ENDIF

    !
    ! Read output manager type
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( OPTIONS_CFG, 'skip-flush-last-step', HAS_KEY, HOOKS )

    IF ( HAS_KEY ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Read output manager type
      CTMP(1) = REPEAT( ' ', CMDARG_STRLEN )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING_WITH_ENV_EXPANSION( OPTIONS_CFG, 'skip-flush-last-step', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      READ(ATMP,*,IOSTAT=READ_STAT) THIS%SKIP_FLUSH_LAST_STEP
      PP_DEBUG_CRITICAL_COND_THROW( READ_STAT.NE.0, ERRFLAG_READ_BOOL )
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
    ENDIF

    ! Deallocate the dump-output-manager object
    PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_CFG) YAML_DELETE_CONFIGURATION( OPTIONS_CFG, HOOKS )

    ! Check if there are filters
    PP_DEBUG_CRITICAL_COND_THROW( CNT.EQ.0_JPIB_K, ERRFLAG_NO_FILTERS )

  ENDIF

  !
  ! Get sub-configuration from input file
  PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( MAIN_CFG, 'filters', HAS_FILTERS, HOOKS )

  !
  ! Read options
  IF (HAS_FILTERS) THEN

    ! Filters counter
    CNT = 0_JPIB_K

    ! Get the specific sub-configuration
    PP_TRYCALL(ERRFLAG_GET_SUBCFG) YAML_GET_SUBCONFIGURATION( MAIN_CFG, 'filters', FILTERS_CFG, HOOKS )

    ! BEGIN PROCESSOR LIST FILTER
    ! ==============================================================================================
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTERS_CFG, 'processors-list', HAS_FILTER, HOOKS )
    ! Read processor list filter
    IF ( HAS_FILTER ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Get the specific sub-configuration
      PP_TRYCALL(ERRFLAG_GET_SUBCFG) YAML_GET_SUBCONFIGURATION( FILTERS_CFG, 'processors-list', FILTER_CFG, HOOKS )

      ! Read operation
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'operation', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING( FILTER_CFG, 'operation', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      SELECT CASE(TRIM(ADJUSTL(ATMP)))
      CASE ('match')
        THIS%MATCH_PROCESSORS = .TRUE.
      CASE ('ignore')
        THIS%MATCH_PROCESSORS = .FALSE.
      CASE DEFAULT
        PP_DEBUG_CRITICAL_THROW( ERRFLAG_READ_STRING )
      END SELECT
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )

      ! Read filter
      PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%PROCESSORS_SET%INITIALIZED( FILTER_INITIALIZED, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( FILTER_INITIALIZED, ERRFLAG_CHECK_INITIALIZED )
      PP_TRYCALL(ERRFLAG_INITIALIZE_FILTER) THIS%PROCESSORS_SET%INIT( HOOKS )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'values', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VALUES) YAML_READ_INTEGER_KEYSET_WITH_RANGES( FILTER_CFG, 'values', THIS%PROCESSORS_SET, HOOKS )

      ! Deallocate the dump-output-manager object
      PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_CFG) YAML_DELETE_CONFIGURATION( FILTER_CFG, HOOKS )

    ENDIF
    ! ==============================================================================================
    ! END PROCESSOR LIST FILTER



    ! BEGIN PARAM FILTER
    ! ==============================================================================================
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTERS_CFG, 'param', HAS_FILTER, HOOKS )
    ! Read processor list filter
    IF ( HAS_FILTER ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Get the specific sub-configuration
      PP_TRYCALL(ERRFLAG_GET_SUBCFG) YAML_GET_SUBCONFIGURATION( FILTERS_CFG, 'param', FILTER_CFG, HOOKS )

      ! Read operation
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'operation', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING( FILTER_CFG, 'operation', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      SELECT CASE(TRIM(ADJUSTL(ATMP)))
      CASE ('match')
        THIS%MATCH_PARAM = .TRUE.
      CASE ('ignore')
        THIS%MATCH_PARAM = .FALSE.
      CASE DEFAULT
        PP_DEBUG_CRITICAL_THROW( ERRFLAG_READ_STRING )
      END SELECT
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )

      ! Read filter
      PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%PARAM_SET%INITIALIZED( FILTER_INITIALIZED, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( FILTER_INITIALIZED, ERRFLAG_CHECK_INITIALIZED )
      PP_TRYCALL(ERRFLAG_INITIALIZE_FILTER) THIS%PARAM_SET%INIT( HOOKS )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'values', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VALUES) YAML_READ_INTEGER_KEYSET_WITH_RANGES( FILTER_CFG, 'values', THIS%PARAM_SET, HOOKS )

      ! Deallocate the dump-output-manager object
      PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_CFG) YAML_DELETE_CONFIGURATION( FILTER_CFG, HOOKS )

    ENDIF
    ! ==============================================================================================
    ! END PARAM FILTER



    ! BEGIN LEVTYPE FILTER
    ! ==============================================================================================
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTERS_CFG, 'levtype', HAS_FILTER, HOOKS )
    ! Read processor list filter
    IF ( HAS_FILTER ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Get the specific sub-configuration
      PP_TRYCALL(ERRFLAG_GET_SUBCFG) YAML_GET_SUBCONFIGURATION( FILTERS_CFG, 'levtype', FILTER_CFG, HOOKS )

      ! Read operation
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'operation', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING( FILTER_CFG, 'operation', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      SELECT CASE(TRIM(ADJUSTL(ATMP)))
      CASE ('match')
        THIS%MATCH_LEVTYPE = .TRUE.
      CASE ('ignore')
        THIS%MATCH_LEVTYPE = .FALSE.
      CASE DEFAULT
        PP_DEBUG_CRITICAL_THROW( ERRFLAG_READ_STRING )
      END SELECT
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )

      ! Read filter
      PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%LEVTYPE_SET%INITIALIZED( FILTER_INITIALIZED, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( FILTER_INITIALIZED, ERRFLAG_CHECK_INITIALIZED )
      PP_TRYCALL(ERRFLAG_INITIALIZE_FILTER) THIS%LEVTYPE_SET%INIT( HOOKS )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'values', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      ! FILTER => CPREFIX2IPREFIX
      FILTER => CLEVTYPE2ILEVTYPE
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VALUES) YAML_READ_INTEGER_KEYSET_WITH_FILTER( FILTER_CFG, 'values', THIS%LEVTYPE_SET, FILTER, HOOKS )

      ! Deallocate the dump-output-manager object
      PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_CFG) YAML_DELETE_CONFIGURATION( FILTER_CFG, HOOKS )

    ENDIF
    ! ==============================================================================================
    ! END LEVTYPE FILTER



    ! BEGIN REPRES FILTER
    ! ==============================================================================================
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTERS_CFG, 'repres', HAS_FILTER, HOOKS )
    ! Read processor list filter
    IF ( HAS_FILTER ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Get the specific sub-configuration
      PP_TRYCALL(ERRFLAG_GET_SUBCFG) YAML_GET_SUBCONFIGURATION( FILTERS_CFG, 'repres', FILTER_CFG, HOOKS )

      ! Read operation
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'operation', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING( FILTER_CFG, 'operation', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      SELECT CASE(TRIM(ADJUSTL(ATMP)))
      CASE ('match')
        THIS%MATCH_REPRES = .TRUE.
      CASE ('ignore')
        THIS%MATCH_REPRES = .FALSE.
      CASE DEFAULT
        PP_DEBUG_CRITICAL_THROW( ERRFLAG_READ_STRING )
      END SELECT
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )

      ! Read filter
      PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%REPRES_SET%INITIALIZED( FILTER_INITIALIZED, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( FILTER_INITIALIZED, ERRFLAG_CHECK_INITIALIZED )
      PP_TRYCALL(ERRFLAG_INITIALIZE_FILTER) THIS%REPRES_SET%INIT( HOOKS )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'values', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      FILTER => CREPRES2IREPRES
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VALUES) YAML_READ_INTEGER_KEYSET_WITH_FILTER( FILTER_CFG, 'values', THIS%REPRES_SET, FILTER, HOOKS )

      ! Deallocate the dump-output-manager object
      PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_CFG) YAML_DELETE_CONFIGURATION( FILTER_CFG, HOOKS )

    ENDIF
    ! ==============================================================================================
    ! END REPRES FILTER



    ! BEGIN STEP FILTER
    ! ==============================================================================================
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTERS_CFG, 'step', HAS_FILTER, HOOKS )
    ! Read processor list filter
    IF ( HAS_FILTER ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Get the specific sub-configuration
      PP_TRYCALL(ERRFLAG_GET_SUBCFG) YAML_GET_SUBCONFIGURATION( FILTERS_CFG, 'step', FILTER_CFG, HOOKS )

      ! Read operation
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'operation', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING( FILTER_CFG, 'operation', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      SELECT CASE(TRIM(ADJUSTL(ATMP)))
      CASE ('match')
        THIS%MATCH_STEP = .TRUE.
      CASE ('ignore')
        THIS%MATCH_STEP = .FALSE.
      CASE DEFAULT
        PP_DEBUG_CRITICAL_THROW( ERRFLAG_READ_STRING )
      END SELECT
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )

      ! Read filter
      PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%STEP_SET%INITIALIZED( FILTER_INITIALIZED, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( FILTER_INITIALIZED, ERRFLAG_CHECK_INITIALIZED )
      PP_TRYCALL(ERRFLAG_INITIALIZE_FILTER) THIS%STEP_SET%INIT( HOOKS )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'values', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VALUES) YAML_READ_INTEGER_KEYSET_WITH_RANGES( FILTER_CFG, 'values', THIS%STEP_SET, HOOKS )

      ! Deallocate the dump-output-manager object
      PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_CFG) YAML_DELETE_CONFIGURATION( FILTER_CFG, HOOKS )

    ENDIF
    ! ==============================================================================================
    ! END STEP FILTER



    ! BEGIN LEVEL FILTER
    ! ==============================================================================================
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTERS_CFG, 'levelist', HAS_FILTER, HOOKS )
    ! Read processor list filter
    IF ( HAS_FILTER ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Get the specific sub-configuration
      PP_TRYCALL(ERRFLAG_GET_SUBCFG) YAML_GET_SUBCONFIGURATION( FILTERS_CFG, 'levelist', FILTER_CFG, HOOKS )

      ! Read operation
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'operation', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING( FILTER_CFG, 'operation', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      SELECT CASE(TRIM(ADJUSTL(ATMP)))
      CASE ('match')
        THIS%MATCH_LEVEL = .TRUE.
      CASE ('ignore')
        THIS%MATCH_LEVEL = .FALSE.
      CASE DEFAULT
        PP_DEBUG_CRITICAL_THROW( ERRFLAG_READ_STRING )
      END SELECT
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )

      ! Read filter
      PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%LEVEL_SET%INITIALIZED( FILTER_INITIALIZED, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( FILTER_INITIALIZED, ERRFLAG_CHECK_INITIALIZED )
      PP_TRYCALL(ERRFLAG_INITIALIZE_FILTER) THIS%LEVEL_SET%INIT( HOOKS )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'values', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VALUES) YAML_READ_INTEGER_KEYSET_WITH_RANGES( FILTER_CFG, 'values', THIS%LEVEL_SET, HOOKS )

      ! Deallocate the dump-output-manager object
      PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_CFG) YAML_DELETE_CONFIGURATION( FILTER_CFG, HOOKS )

    ENDIF
    ! ==============================================================================================
    ! END LEVEL FILTER



    ! BEGIN FREQUENCY FILTER
    ! ==============================================================================================
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTERS_CFG, 'frequency', HAS_FILTER, HOOKS )
    ! Read processor list filter
    IF ( HAS_FILTER ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Get the specific sub-configuration
      PP_TRYCALL(ERRFLAG_GET_SUBCFG) YAML_GET_SUBCONFIGURATION( FILTERS_CFG, 'frequency', FILTER_CFG, HOOKS )

      ! Read operation
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'operation', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING( FILTER_CFG, 'operation', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      SELECT CASE(TRIM(ADJUSTL(ATMP)))
      CASE ('match')
        THIS%MATCH_FREQUENCY = .TRUE.
      CASE ('ignore')
        THIS%MATCH_FREQUENCY = .FALSE.
      CASE DEFAULT
        PP_DEBUG_CRITICAL_THROW( ERRFLAG_READ_STRING )
      END SELECT
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )

      ! Read filter
      PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%FREQUENCY_SET%INITIALIZED( FILTER_INITIALIZED, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( FILTER_INITIALIZED, ERRFLAG_CHECK_INITIALIZED )
      PP_TRYCALL(ERRFLAG_INITIALIZE_FILTER) THIS%FREQUENCY_SET%INIT( HOOKS )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'values', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VALUES) YAML_READ_INTEGER_KEYSET_WITH_RANGES( FILTER_CFG, 'values', THIS%FREQUENCY_SET, HOOKS )

      ! Deallocate the dump-output-manager object
      PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_CFG) YAML_DELETE_CONFIGURATION( FILTER_CFG, HOOKS )

    ENDIF
    ! ==============================================================================================
    ! END FREQUENCY FILTER



    ! BEGIN DIRECTION FILTER
    ! ==============================================================================================
    PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTERS_CFG, 'direction', HAS_FILTER, HOOKS )
    ! Read processor list filter
    IF ( HAS_FILTER ) THEN

      ! Increate filters counter
      CNT = CNT + 1_JPIB_K

      ! Get the specific sub-configuration
      PP_TRYCALL(ERRFLAG_GET_SUBCFG) YAML_GET_SUBCONFIGURATION( FILTERS_CFG, 'direction', FILTER_CFG, HOOKS )

      ! Read operation
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'operation', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_READ_STRING( FILTER_CFG, 'operation', ATMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_READ_STRING )
      SELECT CASE(TRIM(ADJUSTL(ATMP)))
      CASE ('match')
        THIS%MATCH_DIRECTION = .TRUE.
      CASE ('ignore')
        THIS%MATCH_DIRECTION = .FALSE.
      CASE DEFAULT
        PP_DEBUG_CRITICAL_THROW( ERRFLAG_READ_STRING )
      END SELECT
      DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )

      ! Read filter
      PP_TRYCALL(ERRFLAG_CHECK_INITIALIZED) THIS%DIRECTION_SET%INITIALIZED( FILTER_INITIALIZED, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( FILTER_INITIALIZED, ERRFLAG_CHECK_INITIALIZED )
      PP_TRYCALL(ERRFLAG_INITIALIZE_FILTER) THIS%DIRECTION_SET%INIT( HOOKS )
      PP_TRYCALL(ERRFLAG_HAS_KEY) YAML_CONFIGURATION_HAS_KEY( FILTER_CFG, 'values', HAS_KEY, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_HAS_KEY )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VALUES) YAML_READ_INTEGER_KEYSET_WITH_RANGES( FILTER_CFG, 'values', THIS%DIRECTION_SET, HOOKS )

      ! Deallocate the dump-output-manager object
      PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_CFG) YAML_DELETE_CONFIGURATION( FILTER_CFG, HOOKS )

    ENDIF
    ! ==============================================================================================
    ! END DIRECTION FILTER

    ! Deallocate the dump-output-manager object
    PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_CFG) YAML_DELETE_CONFIGURATION( FILTERS_CFG, HOOKS )

    ! Check if there are filters
    PP_DEBUG_CRITICAL_COND_THROW( CNT.EQ.0_JPIB_K, ERRFLAG_NO_FILTERS )

  ENDIF

  ! Deallocate the dump-output-manager object
  PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_CFG) YAML_DELETE_CONFIGURATION( MAIN_CFG, HOOKS )


  IF ( ALLOCATED(ATMP) ) THEN
    DEALLOCATE(ATMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )
  ENDIF

  ! Allocate the values array
  DEALLOCATE( CTMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT.NE.0_JPIB_K, ERRFLAG_UNABLE_TO_DEALLOCATE_STRING )
  CTMP => NULL()


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_MATCH_NOT_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Match not expected' )
    CASE (ERRFLAG_VALUES_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Values expected' )
    CASE (ERRFLAG_INVALID_VALUES_COUNT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid values count' )
    CASE (ERRFLAG_INVALID_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid configuration file' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'file: '//TRIM(ADJUSTL(FILTER_FILE)) )
    CASE (ERRFLAG_UNABLE_TO_EXPAND_ENVVAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to expand environment variable' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'variable: '//TRIM(ADJUSTL(VALUES(1))) )
    CASE (ERRFLAG_UNABLE_TO_CHECK_FILTER_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check configuration file' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'file: '//TRIM(ADJUSTL(FILTER_FILE)) )
    CASE (ERRFLAG_UNABLE_TO_OPEN_CFG_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to open configuration file' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'file: '//TRIM(ADJUSTL(FILTER_FILE)) )
    CASE (ERRFLAG_HAS_KEY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Key not found in configuration file' )
    CASE (ERRFLAG_UNABLE_TO_DESTROY_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to destroy configuration object' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'file: '//TRIM(ADJUSTL(FILTER_FILE)) )
    CASE (ERRFLAG_UNABLE_TO_ALLOCATE_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to allocate string' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG, STAT=DEALLOC_STAT)
      END IF
    CASE (ERRFLAG_UNABLE_TO_DEALLOCATE_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to deallocate string' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG, STAT=DEALLOC_STAT)
      END IF
    CASE (ERRFLAG_READ_CONFIGURATION_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading configuration file' )
    CASE (ERRFLAG_READ_TYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading type' )
    CASE (ERRFLAG_READ_DUMP_PATH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading dump path' )
    CASE (ERRFLAG_READ_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading string' )
    CASE (ERRFLAG_TOO_LONG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'String too long' )
    CASE (ERRFLAG_GET_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error getting sub-configuration' )
    CASE (ERRFLAG_READ_BOOL)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading boolean' )
    CASE (ERRFLAG_UNABLE_TO_READ_VALUES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read values' )
    CASE (ERRFLAG_NO_FILTERS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'No filters found' )
    CASE (ERRFLAG_CHECK_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Filter not initialized' )
    CASE (ERRFLAG_INITIALIZE_FILTER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error initializing filter' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMDARG_PARSE_FILTER_FILE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'READ_INTEGER_ARRAY_WITH_RANGES'
PP_THREAD_SAFE FUNCTION READ_INTEGER_ARRAY_WITH_RANGES( ATMP, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_IS_INTEGER
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_IS_INTEGER_RANGE
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_IS_INTEGER_RANGE_BY
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_TO_INTEGER
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_TO_INTEGER_RANGE
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_TO_INTEGER_RANGE_BY

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=CMDARG_STRLEN), POINTER, DIMENSION(:), INTENT(IN)    :: ATMP
  INTEGER(KIND=JPIB_K), ALLOCATABLE,  DIMENSION(:),    INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: J
  LOGICAL :: IS_INTEGER
  LOGICAL :: IS_INTEGER_RANGE
  LOGICAL :: IS_INTEGER_RANGE_BY
  INTEGER(KIND=JPIB_K) :: LO
  INTEGER(KIND=JPIB_K) :: HI
  INTEGER(KIND=JPIB_K) :: BY
  INTEGER(KIND=JPIB_K) :: VALUE_SIZE
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG


  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INPUT_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_NOT_ALLOCATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_SIZE_LT_1=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_1=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_2=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_3=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_4=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_5=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOCATION_ERROR=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUE_OUT_OF_BOUNDS=12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOCATION_ERROR=13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUS_SIZE_LT_1=14_JPIB_K

  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_READ_STRING_ARRAY=15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_IS_INTEGER=16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE=17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE_BY=18_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_TO_INTEGER=19_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE=20_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE_BY=21_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(ATMP), ERRFLAG_INPUT_NOT_ALLOCATED )

  ! Read the paramId as a string array
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(ATMP).LT.1, ERRFLAG_STRING_ARRAY_SIZE_LT_1 )

  ! Compute the size of the paramId array
  VALUE_SIZE = 0_JPIB_K
  ParamIdFIlterSizeLoop: DO I = 1, SIZE(ATMP)

    ! Check if the value is an integer
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER) STRING_IS_INTEGER( ATMP(I), IS_INTEGER, HOOKS )
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE) STRING_IS_INTEGER_RANGE( ATMP(I), IS_INTEGER_RANGE, HOOKS )
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE_BY) STRING_IS_INTEGER_RANGE_BY( ATMP(I), IS_INTEGER_RANGE_BY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT.IS_INTEGER .AND. .NOT.IS_INTEGER_RANGE .AND. .NOT.IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_1 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_2 )

    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE, ERRFLAG_INVALID_STRING_IN_ARRAY_3 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_4 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER_RANGE .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_5 )

    ! Update the total size of the paramId array
    IF ( IS_INTEGER ) THEN
      VALUE_SIZE = VALUE_SIZE + 1
    ELSE IF ( IS_INTEGER_RANGE ) THEN
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE) STRING_TO_INTEGER_RANGE( ATMP(I), LO, HI, HOOKS )
      VALUE_SIZE = VALUE_SIZE + HI - LO + 1
    ELSE IF ( IS_INTEGER_RANGE_BY ) THEN
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE_BY) STRING_TO_INTEGER_RANGE_BY( ATMP(I), LO, HI, BY, HOOKS )
      VALUE_SIZE = VALUE_SIZE + (HI - LO + 1)/BY
    ENDIF

  ENDDO ParamIdFIlterSizeLoop
  PP_DEBUG_CRITICAL_COND_THROW( VALUE_SIZE.LT.1, ERRFLAG_VALUS_SIZE_LT_1 )

  ! Allocate the paramId array
  ALLOCATE( VALUE(VALUE_SIZE), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS.NE.0, ERRFLAG_ALLOCATION_ERROR )

  ! Fill the paramId array
  J = 0_JPIB_K
  ParamIdFIlterFillLoop: DO I = 1, SIZE(ATMP)

    ! Check if the value is an integer
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER) STRING_IS_INTEGER( ATMP(I), IS_INTEGER, HOOKS )
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE) STRING_IS_INTEGER_RANGE( ATMP(I), IS_INTEGER_RANGE, HOOKS )
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE_BY) STRING_IS_INTEGER_RANGE_BY( ATMP(I), IS_INTEGER_RANGE_BY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT.IS_INTEGER .AND. .NOT.IS_INTEGER_RANGE .AND. .NOT.IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_1 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_2 )

    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE, ERRFLAG_INVALID_STRING_IN_ARRAY_3 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_4 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER_RANGE .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_5 )

    ! Update the total size of the paramId array
    IF ( IS_INTEGER ) THEN

      ! Fill the paramId array when the item is an integer (e.g., 1)
      J = J + 1
      PP_DEBUG_CRITICAL_COND_THROW( J.GT.SIZE(VALUE), ERRFLAG_VALUE_OUT_OF_BOUNDS )
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER) STRING_TO_INTEGER( ATMP(I), VALUE(J), HOOKS )

    ELSE IF ( IS_INTEGER_RANGE ) THEN

      ! Fill the paramId array when the item is an integer range (e.g., 1:10)
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE) STRING_TO_INTEGER_RANGE( ATMP(I), LO, HI, HOOKS )
      ParamIdFIlterFillRangeLoop: DO
        IF ( LO .LE. HI ) THEN
          J = J + 1
          PP_DEBUG_CRITICAL_COND_THROW( J.GT.SIZE(VALUE), ERRFLAG_VALUE_OUT_OF_BOUNDS )
          VALUE(J) = LO
          LO = LO + 1
        ELSE
          EXIT ParamIdFIlterFillRangeLoop
        ENDIF
      ENDDO ParamIdFIlterFillRangeLoop

    ELSE IF ( IS_INTEGER_RANGE_BY ) THEN

      ! Fill the paramId array when the item is an integer range by (e.g., 1:10:2)
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE_BY) STRING_TO_INTEGER_RANGE_BY( ATMP(I), LO, HI, BY, HOOKS )
      ParamIdFIlterFillRangeByLoop: DO
        IF ( LO .LE. HI ) THEN
          J = J + 1
          PP_DEBUG_CRITICAL_COND_THROW( J.GT.SIZE(VALUE), ERRFLAG_VALUE_OUT_OF_BOUNDS )
          VALUE(J) = LO
          LO = LO + BY
        ELSE
          EXIT ParamIdFIlterFillRangeByLoop
        ENDIF
      ENDDO ParamIdFIlterFillRangeByLoop

    ENDIF

  ENDDO ParamIdFIlterFillLoop

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_INPUT_NOT_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Input array not allocated' )
    CASE(ERRFLAG_STRING_ARRAY_NOT_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'String array not allocated after read' )
    CASE(ERRFLAG_STRING_ARRAY_SIZE_LT_1)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'String array is empty' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_1)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing string no matches (no integer, no integer range, no integer range by)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_2)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing string multiple matches ( integer, integer range, integer range by)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_3)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing string multiple matches (integer, integer range)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_4)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing string multiple matches (integer, integer range by)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_5)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing string multiple matches (integer range, integer range by)' )
    CASE(ERRFLAG_ALLOCATION_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error allocating VALUES' )
      ELSE
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error allocating VALUES: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE(ERRFLAG_VALUE_OUT_OF_BOUNDS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Out of bounds while setting integer value to the output array' )
    CASE(ERRFLAG_DEALLOCATION_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deallocating ATMP' )
      ELSE
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deallocating ATMP: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE (ERRFLAG_VALUS_SIZE_LT_1)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Value size is less than 1 after parsing all the elements' )
    CASE (ERRFLAG_ERROR_CALL_READ_STRING_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling YAML_READ_STRING_ARRAY' )
    CASE (ERRFLAG_ERROR_CALL_STRING_IS_INTEGER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_IS_INTEGER' )
    CASE (ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_IS_INTEGER_RANGE' )
    CASE (ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE_BY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_IS_INTEGER_RANGE_BY' )
    CASE (ERRFLAG_ERROR_CALL_STRING_TO_INTEGER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_TO_INTEGER' )
    CASE (ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_TO_INTEGER_RANGE' )
    CASE (ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE_BY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_TO_INTEGER_RANGE_BY' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif
  ! Exit point on error
  RETURN

END FUNCTION READ_INTEGER_ARRAY_WITH_RANGES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Reads an integer keyset with ranges from a YAML configuration.
!>
!> This function reads an integer keyset from a provided YAML configuration object (`CFG`)
!> using the specified key (`KEY`). The `VALUE` keyset is populated with the parsed integers,
!> supporting ranges in the YAML configuration. The function returns an error code indicating
!> success or failure of the operation. If verbose mode is enabled, additional output is generated
!> for debugging purposes.
!>
!> @section interface
!> @param [in] CFG The YAML configuration object from which the integer keyset is read.
!> @param [in] KEY The key corresponding to the integer keyset in the YAML configuration.
!> @param [out] VALUE The integer keyset to be populated with the parsed values, supporting ranges.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating the outcome of the function.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE]      YAML_CONFIGURATION_T
!>   - @dependency [PROCEDURE] YAML_READ_STRING_ARRAY
!>   - @dependency [PROCEDURE] STRING_IS_INTEGER
!>   - @dependency [PROCEDURE] STRING_IS_INTEGER_RANGE
!>   - @dependency [PROCEDURE] STRING_IS_INTEGER_RANGE_BY
!>   - @dependency [PROCEDURE] STRING_TO_INTEGER
!>   - @dependency [PROCEDURE] STRING_TO_INTEGER_RANGE
!>   - @dependency [PROCEDURE] STRING_TO_INTEGER_RANGE_BY
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see YAML_READ_STRING_ARRAY
!> @see YAML_READ_INTEGER_ARRAY
!> @see YAML_READ_INTEGER_ARRAY_WITH_FILTER
!> @see YAML_READ_STRING
!> @see YAML_READ_FLOAT
!> @see YAML_READ_LOGICAL
!> @see YAML_READ_INTEGER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'READ_INTEGER_KEYSET_WITH_RANGES'
PP_THREAD_SAFE FUNCTION READ_INTEGER_KEYSET_WITH_RANGES( ATMP, KEYSET, HOOKS ) RESULT(RET)

  ! Symbols imported from intrinsics modules
   USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: KEYSET_INT64_MOD,                ONLY: KEYSET_INT64_T
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_IS_INTEGER
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_IS_INTEGER_RANGE
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_IS_INTEGER_RANGE_BY
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_TO_INTEGER
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_TO_INTEGER_RANGE
  USE :: CONFIGURATION_UTILS_MOD,         ONLY: STRING_TO_INTEGER_RANGE_BY

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=CMDARG_STRLEN), POINTER, DIMENSION(:), INTENT(IN)    :: ATMP
  TYPE(KEYSET_INT64_T),                                INTENT(INOUT) :: KEYSET
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: J
  LOGICAL :: IS_INTEGER
  LOGICAL :: IS_INTEGER_RANGE
  LOGICAL :: IS_INTEGER_RANGE_BY
  INTEGER(KIND=JPIB_K) :: LO
  INTEGER(KIND=JPIB_K) :: HI
  INTEGER(KIND=JPIB_K) :: BY
  INTEGER(KIND=JPIB_K) :: VALUE_SIZE
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG


  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_NOT_ALLOCATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_SIZE_LT_1=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_1=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_2=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_3=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_4=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_5=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOCATION_ERROR=13_JPIB_K

  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_READ_STRING_ARRAY=15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_IS_INTEGER=16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE=17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE_BY=18_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_TO_INTEGER=19_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE=20_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE_BY=21_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_KEYSET_PUSH=22_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(ATMP), ERRFLAG_CFG_NOT_ALLOCATED )

  ! Read the paramId as a string array
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(ATMP).LT.1, ERRFLAG_STRING_ARRAY_SIZE_LT_1 )

  ! Fill the paramId array
  J = 0_JPIB_K
  ParamIdFIlterFillLoop: DO I = 1, SIZE(ATMP)

    ! Check if the value is an integer
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER) STRING_IS_INTEGER( ATMP(I), IS_INTEGER, HOOKS )
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE) STRING_IS_INTEGER_RANGE( ATMP(I), IS_INTEGER_RANGE, HOOKS )
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE_BY) STRING_IS_INTEGER_RANGE_BY( ATMP(I), IS_INTEGER_RANGE_BY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT.IS_INTEGER .AND. .NOT.IS_INTEGER_RANGE .AND. .NOT.IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_1 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_2 )

    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE, ERRFLAG_INVALID_STRING_IN_ARRAY_3 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_4 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER_RANGE .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_5 )

    ! Update the total size of the paramId array
    IF ( IS_INTEGER ) THEN

      ! Fill the paramId array when the item is an integer (e.g., 1)
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER) STRING_TO_INTEGER( ATMP(I), LO, HOOKS )
      PP_TRYCALL(ERRFLAG_ERROR_CALL_KEYSET_PUSH) KEYSET%INSERT( INT( LO, KIND=INT64), HOOKS )

    ELSE IF ( IS_INTEGER_RANGE ) THEN

      ! Fill the paramId array when the item is an integer range (e.g., 1:10)
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE) STRING_TO_INTEGER_RANGE( ATMP(I), LO, HI, HOOKS )
      ParamIdFIlterFillRangeLoop: DO
        IF ( LO .LE. HI ) THEN
          PP_TRYCALL(ERRFLAG_ERROR_CALL_KEYSET_PUSH) KEYSET%INSERT( INT( LO, KIND=INT64), HOOKS )
          LO = LO + 1
        ELSE
          EXIT ParamIdFIlterFillRangeLoop
        ENDIF
      ENDDO ParamIdFIlterFillRangeLoop

    ELSE IF ( IS_INTEGER_RANGE_BY ) THEN

      ! Fill the paramId array when the item is an integer range by (e.g., 1:10:2)
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE_BY) STRING_TO_INTEGER_RANGE_BY( ATMP(I), LO, HI, BY, HOOKS )
      ParamIdFIlterFillRangeByLoop: DO
        IF ( LO .LE. HI ) THEN
          PP_TRYCALL(ERRFLAG_ERROR_CALL_KEYSET_PUSH) KEYSET%INSERT( INT( LO, KIND=INT64), HOOKS )
          LO = LO + BY
        ELSE
          EXIT ParamIdFIlterFillRangeByLoop
        ENDIF
      ENDDO ParamIdFIlterFillRangeByLoop

    ENDIF

  ENDDO ParamIdFIlterFillLoop

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'YAML configuration not allocated' )
    CASE(ERRFLAG_STRING_ARRAY_NOT_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'String array not allocated after read' )
    CASE(ERRFLAG_STRING_ARRAY_SIZE_LT_1)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'String array is empty' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_1)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing string no matches (no integer, no integer range, no integer range by)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_2)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing string multiple matches ( integer, integer range, integer range by)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_3)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing string multiple matches (integer, integer range)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_4)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing string multiple matches (integer, integer range by)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_5)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error parsing string multiple matches (integer range, integer range by)' )
    CASE(ERRFLAG_DEALLOCATION_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deallocating ATMP' )
      ELSE
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deallocating ATMP: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE (ERRFLAG_ERROR_CALL_READ_STRING_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling YAML_READ_STRING_ARRAY' )
    CASE (ERRFLAG_ERROR_CALL_STRING_IS_INTEGER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_IS_INTEGER' )
    CASE (ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_IS_INTEGER_RANGE' )
    CASE (ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE_BY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_IS_INTEGER_RANGE_BY' )
    CASE (ERRFLAG_ERROR_CALL_STRING_TO_INTEGER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_TO_INTEGER' )
    CASE (ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_TO_INTEGER_RANGE' )
    CASE (ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE_BY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling STRING_TO_INTEGER_RANGE_BY' )
    CASE (ERRFLAG_ERROR_CALL_KEYSET_PUSH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling KEYSET_PUSH' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif
  ! Exit point on error
  RETURN

END FUNCTION READ_INTEGER_KEYSET_WITH_RANGES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'READ_INTEGER_KEYSET_WITH_FILTER'
PP_THREAD_SAFE FUNCTION READ_INTEGER_KEYSET_WITH_FILTER( ATMP, KEYSET, FILTER, HOOKS ) RESULT(RET)

  ! Symbols imported from intrinsics modules
   USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN
  USE :: YAML_CORE_UTILS_MOD,             ONLY: FUN_C2I_IF
  USE :: KEYSET_INT64_MOD,                ONLY: KEYSET_INT64_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=CMDARG_STRLEN), POINTER, DIMENSION(:), INTENT(IN)    :: ATMP
  TYPE(KEYSET_INT64_T),                                INTENT(INOUT) :: KEYSET
  PROCEDURE(FUN_C2I_IF), POINTER,                      INTENT(IN)    :: FILTER
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: TMP
  INTEGER(KIND=JPIB_K) :: VALUE_SIZE
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_NOT_ALLOCATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_SIZE_LT_1=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_KEYSET_PUSH=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CALL_FILTER=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOCATION_ERROR=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_READ_STRING_ARRAY=7_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(ATMP), ERRFLAG_CFG_NOT_ALLOCATED )

  ! Read the paramId as a string array
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(ATMP).LT.1, ERRFLAG_STRING_ARRAY_SIZE_LT_1 )

  ! Allocate the paramId array
  VALUE_SIZE = SIZE(ATMP)

  ! Compute the size of the paramId array
  ParamIdFIlterSizeLoop: DO I = 1, VALUE_SIZE

    ! Filter the value
    PP_TRYCALL(ERRFLAG_CALL_FILTER) FILTER(ATMP(I), TMP, HOOKS )

    ! Push the value to the keyset
    PP_TRYCALL(ERRFLAG_ERROR_CALL_KEYSET_PUSH) KEYSET%INSERT( INT(TMP,KIND=INT64), HOOKS )

  ENDDO ParamIdFIlterSizeLoop


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'YAML configuration not allocated' )
    CASE (ERRFLAG_STRING_ARRAY_NOT_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'String array not allocated after read' )
    CASE (ERRFLAG_STRING_ARRAY_SIZE_LT_1)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'String array is empty' )
    CASE (ERRFLAG_CALL_FILTER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling filter' )
    CASE (ERRFLAG_ERROR_CALL_KEYSET_PUSH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error pushing value to keyset' )
    CASE (ERRFLAG_DEALLOCATION_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deallocating ATMP' )
      ELSE
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deallocating ATMP: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE (ERRFLAG_ERROR_CALL_READ_STRING_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling YAML_READ_STRING_ARRAY' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION READ_INTEGER_KEYSET_WITH_FILTER
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'READ_INTEGER_ARRAY_WITH_FILTER'
PP_THREAD_SAFE FUNCTION READ_INTEGER_ARRAY_WITH_FILTER( ATMP, VALUE, FILTER, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: YAML_CORE_UTILS_MOD,             ONLY: FUN_C2I_IF
  USE :: COMMAND_ARGUMENTS_TOKENIZER_MOD, ONLY: CMDARG_STRLEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=CMDARG_STRLEN), DIMENSION(:), POINTER, INTENT(IN)    :: ATMP
  INTEGER(KIND=JPIB_K), ALLOCATABLE,  DIMENSION(:),    INTENT(OUT)   :: VALUE
  PROCEDURE(FUN_C2I_IF), POINTER,                      INTENT(IN)    :: FILTER
  TYPE(HOOKS_T),                                       INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: VALUE_SIZE
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUE_ALREADY_ALLOCATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_NOT_ALLOCATED=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_SIZE_LT_1=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOCATION_ERROR=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CALL_FILTER=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOCATION_ERROR=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_READ_STRING_ARRAY=8_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(ATMP), ERRFLAG_CFG_NOT_ALLOCATED )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOCATED(VALUE),          ERRFLAG_VALUE_ALREADY_ALLOCATED )

  ! Read the paramId as a string array
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(ATMP).LT.1, ERRFLAG_STRING_ARRAY_SIZE_LT_1 )

  ! Allocate the paramId array
  VALUE_SIZE = SIZE(ATMP)
  ALLOCATE( VALUE(VALUE_SIZE), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS.NE.0, ERRFLAG_ALLOCATION_ERROR )

  ! Compute the size of the paramId array
  ParamIdFIlterSizeLoop: DO I = 1, VALUE_SIZE

    ! Filter the value
    PP_TRYCALL(ERRFLAG_CALL_FILTER) FILTER(ATMP(I), VALUE(I), HOOKS )

  ENDDO ParamIdFIlterSizeLoop

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'YAML configuration not allocated' )
    CASE (ERRFLAG_VALUE_ALREADY_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'VALUE already allocated' )
    CASE (ERRFLAG_STRING_ARRAY_NOT_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'String array not allocated after read' )
    CASE (ERRFLAG_STRING_ARRAY_SIZE_LT_1)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'String array is empty' )
    CASE (ERRFLAG_ALLOCATION_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error allocating VALUES' )
      ELSE
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error allocating VALUES: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE (ERRFLAG_CALL_FILTER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling filter' )
    CASE (ERRFLAG_DEALLOCATION_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deallocating ATMP' )
      ELSE
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deallocating ATMP: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE (ERRFLAG_ERROR_CALL_READ_STRING_ARRAY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error calling YAML_READ_STRING_ARRAY' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION READ_INTEGER_ARRAY_WITH_FILTER
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



END MODULE COMMAND_ARGUMENTS_PARSER_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME