! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"


#define PP_FILE_NAME 'geometry_par_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'GEOMETRY_PAR_MOD'
MODULE GEOMETRY_PAR_MOD

  !> Symbols imported from other modules within the project.
  USE :: REDUCED_GG_MAP_MOD,          ONLY: REDUCED_GG_GEOM_MAP_T
  USE :: REGULAR_LL_MAP_MOD,          ONLY: REGULAR_LL_GEOM_MAP_T
  USE :: SPHERICAL_HARMONICS_MAP_MOD, ONLY: SPHERICAL_HARMONICS_MAP_T

IMPLICIT NONE

!> Default visibility of the module
PRIVATE

!> Geometry parametrization
TYPE :: GEOMETRY_PAR_T
  LOGICAL :: GG_TO_BE_DEALLOCATED=.FALSE.
  LOGICAL :: LL_TO_BE_DEALLOCATED=.FALSE.
  LOGICAL :: SH_TO_BE_DEALLOCATED=.FALSE.
  TYPE(REDUCED_GG_GEOM_MAP_T), POINTER :: GG => NULL()
  TYPE(REGULAR_LL_GEOM_MAP_T), POINTER :: LL => NULL()
  TYPE(SPHERICAL_HARMONICS_MAP_T), POINTER :: SH => NULL()
CONTAINS
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: COPY_FROM => GEOMETRY_PAR_COPY_FROM
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: READ_FROM_YAML => READ_GEOMETRY_PAR_FROM_YAML
  PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: FREE => GEOMETRY_PAR_FREE
END TYPE

!> Whitelist of public symbols
PUBLIC :: GEOMETRY_PAR_T

CONTAINS


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'GEOMETRY_PAR_FREE'
FUNCTION GEOMETRY_PAR_FREE( GEOMETRY_PAR, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(GEOMETRY_PAR_T), INTENT(INOUT) :: GEOMETRY_PAR
  TYPE(HOOKS_T),         INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: DEALLOC_STAT
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_FREE = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DEALLOCATE = 2_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  IF ( GEOMETRY_PAR%GG_TO_BE_DEALLOCATED ) THEN
    IF ( ASSOCIATED(GEOMETRY_PAR%GG) ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE) GEOMETRY_PAR%GG%FREE( HOOKS )
      DEALLOCATE( GEOMETRY_PAR%GG, STAT=DEALLOC_STAT, ERRMSG=ERRMSG )
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
    ENDIF
  ENDIF

  IF ( GEOMETRY_PAR%LL_TO_BE_DEALLOCATED ) THEN
    IF ( ASSOCIATED(GEOMETRY_PAR%LL) ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE) GEOMETRY_PAR%LL%FREE( HOOKS )
      DEALLOCATE( GEOMETRY_PAR%LL, STAT=DEALLOC_STAT, ERRMSG=ERRMSG )
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
    ENDIF
  ENDIF

  IF ( GEOMETRY_PAR%SH_TO_BE_DEALLOCATED ) THEN
    IF ( ASSOCIATED(GEOMETRY_PAR%SH) ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE) GEOMETRY_PAR%SH%FREE( HOOKS )
      DEALLOCATE( GEOMETRY_PAR%SH, STAT=DEALLOC_STAT, ERRMSG=ERRMSG )
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
    ENDIF
  ENDIF

  ! Copy the data
  GEOMETRY_PAR%GG_TO_BE_DEALLOCATED = .FALSE.
  GEOMETRY_PAR%LL_TO_BE_DEALLOCATED = .FALSE.
  GEOMETRY_PAR%SH_TO_BE_DEALLOCATED = .FALSE.
  GEOMETRY_PAR%GG => NULL()
  GEOMETRY_PAR%LL => NULL()
  GEOMETRY_PAR%SH => NULL()

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_FREE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to free the data' )
    CASE(ERRFLAG_UNABLE_TO_DEALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to deallocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE( ERRMSG, STAT=DEALLOC_STAT )
      ENDIF
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION GEOMETRY_PAR_FREE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'GEOMETRY_PAR_COPY_FROM'
FUNCTION GEOMETRY_PAR_COPY_FROM( GEOMETRY_PAR_TO, GEOMETRY_PAR_FROM, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(GEOMETRY_PAR_T), INTENT(INOUT) :: GEOMETRY_PAR_TO
  TYPE(GEOMETRY_PAR_T),  INTENT(IN)    :: GEOMETRY_PAR_FROM
  TYPE(HOOKS_T),         INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Copy the data
  GEOMETRY_PAR_TO%GG_TO_BE_DEALLOCATED = .FALSE.
  GEOMETRY_PAR_TO%LL_TO_BE_DEALLOCATED = .FALSE.
  GEOMETRY_PAR_TO%SH_TO_BE_DEALLOCATED = .FALSE.
  GEOMETRY_PAR_TO%GG => GEOMETRY_PAR_FROM%GG
  GEOMETRY_PAR_TO%LL => GEOMETRY_PAR_FROM%LL
  GEOMETRY_PAR_TO%SH => GEOMETRY_PAR_FROM%SH

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION GEOMETRY_PAR_COPY_FROM
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'READ_GEOMETRY_PAR_FROM_YAML'
FUNCTION READ_GEOMETRY_PAR_FROM_YAML( GEOMETRY_PAR, CONFIG, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATIONS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATIONS_SIZE
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATION_BY_ID
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(GEOMETRY_PAR_T),      INTENT(INOUT) :: GEOMETRY_PAR
  TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CONFIG
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL :: HAS_REPRESENTATIONS
  LOGICAL :: HAS_TYPE
  INTEGER(KIND=JPIB_K) :: SZ
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: DEALLOC_STAT
  TYPE(YAML_CONFIGURATION_T)  :: REPRESENTATION_CONFIGURATION
  TYPE(YAML_CONFIGURATIONS_T) :: REPRESENTATIONS_CONFIGURATIONS
  CHARACTER(LEN=:), ALLOCATABLE :: CTMP
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_SUBCFG = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SUBCFG = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_NUMBER_OF_REPRESENTATIONS = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_TEST_CASE_DELETE_ERROR = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_TYPE = 7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DEALLOCATE = 8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_GG_PAR = 9_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Read the encoder configuration
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'representations', HAS_REPRESENTATIONS, HOOKS )

  !> Read representations
  IF ( HAS_REPRESENTATIONS  ) THEN

    !> Read all the subconfigurations
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_SUBCFG) YAML_GET_SUBCONFIGURATIONS( CONFIG, 'representations', REPRESENTATIONS_CONFIGURATIONS, HOOKS )

    !> Get the sections size
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE) YAML_GET_CONFIGURATIONS_SIZE( REPRESENTATIONS_CONFIGURATIONS, SZ, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( SZ .LE. 0, ERRFLAG_WRONG_NUMBER_OF_REPRESENTATIONS )

    DO I = 1, SZ

      !> Get the configuration by ID
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SUBCFG) YAML_GET_CONFIGURATION_BY_ID( REPRESENTATIONS_CONFIGURATIONS, I, REPRESENTATION_CONFIGURATION, HOOKS )

      !> Check if the keywords "type" is present
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( REPRESENTATION_CONFIGURATION, 'type', HAS_TYPE, HOOKS )

      !> Read the type
      IF ( ALLOCATED(CTMP) ) THEN
        DEALLOCATE(CTMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
        PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
      ENDIF
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_STRING( REPRESENTATION_CONFIGURATION, 'type', CTMP, HOOKS )
      PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(CTMP), ERRFLAG_UNABLE_TO_READ_CFG )

      !> Read the type
      SELECT CASE (CTMP)
      CASE ( 'gg', 'reduced-gaussian' )
        PP_TRYCALL(ERRFLAG_READ_GG_PAR) DEFINITION_GG_READ_FROM_YAML( REPRESENTATION_CONFIGURATION, GEOMETRY_PAR, HOOKS )
      CASE ( 'll', 'regular-latlon' )
        PP_TRYCALL(ERRFLAG_READ_GG_PAR) DEFINITION_LL_READ_FROM_YAML( REPRESENTATION_CONFIGURATION, GEOMETRY_PAR, HOOKS )
      CASE ( 'sh', 'spherical-harmonics' )
        PP_TRYCALL(ERRFLAG_READ_GG_PAR) DEFINITION_SH_READ_FROM_YAML( REPRESENTATION_CONFIGURATION, GEOMETRY_PAR, HOOKS )
      CASE DEFAULT
        PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_TYPE )
      END SELECT

      IF ( ALLOCATED(CTMP) ) THEN
        DEALLOCATE(CTMP, STAT=DEALLOC_STAT, ERRMSG=ERRMSG)
        PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
      ENDIF

      !> Destroy the configuration object
      PP_TRYCALL(ERRFLAG_TEST_CASE_DELETE_ERROR) YAML_DELETE_CONFIGURATION( REPRESENTATION_CONFIGURATION, HOOKS )

    ENDDO

    !> Destroy the configuration object
    PP_TRYCALL(ERRFLAG_TEST_CASE_DELETE_ERROR) YAML_DELETE_CONFIGURATIONS( REPRESENTATIONS_CONFIGURATIONS, HOOKS )

  ENDIF


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read the configuration' )
    CASE(ERRFLAG_UNABLE_TO_READ_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read the subconfigurations' )
    CASE(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to get the subconfigurations size' )
    CASE(ERRFLAG_UNABLE_TO_GET_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to get the subconfigurations' )
    CASE(ERRFLAG_WRONG_NUMBER_OF_REPRESENTATIONS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'wrong number of representations' )
    CASE(ERRFLAG_TEST_CASE_DELETE_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deleting the test case' )
    CASE(ERRFLAG_UNKNOWN_TYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown type' )
    CASE(ERRFLAG_UNABLE_TO_DEALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to deallocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE( ERRMSG, STAT=DEALLOC_STAT )
      ENDIF
    CASE(ERRFLAG_READ_GG_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error reading the GG geometry' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION READ_GEOMETRY_PAR_FROM_YAML
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'DEFINITION_GG_READ_FROM_YAML'
FUNCTION DEFINITION_GG_READ_FROM_YAML( CONFIG, GEOMETRY_PAR, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATIONS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATIONS_SIZE
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATION_BY_ID
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CONFIG
  TYPE(GEOMETRY_PAR_T),       INTENT(INOUT) :: GEOMETRY_PAR
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL :: HAS_DEFINITIONS
  INTEGER(KIND=JPIB_K) :: SZ
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  TYPE(YAML_CONFIGURATION_T)  :: DEFINITION_CONFIGURATION
  TYPE(YAML_CONFIGURATIONS_T) :: DEFINITIONS_CONFIGURATIONS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_SUBCFG = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SUBCFG = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_NUMBER_OF_DEFINITIONS = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_TEST_CASE_DELETE_ERROR = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_GG_PAR = 9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ALLOCATE = 10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_INITIALIZE_MAP = 11_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Read the encoder configuration
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'definitions', HAS_DEFINITIONS, HOOKS )

  !> Read definitions
  IF ( HAS_DEFINITIONS  ) THEN

    !> Read all the subconfigurations
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_SUBCFG) YAML_GET_SUBCONFIGURATIONS( CONFIG, 'definitions', DEFINITIONS_CONFIGURATIONS, HOOKS )

    !> Get the sections size
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE) YAML_GET_CONFIGURATIONS_SIZE( DEFINITIONS_CONFIGURATIONS, SZ, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( SZ .LE. 0, ERRFLAG_WRONG_NUMBER_OF_DEFINITIONS )

    IF ( .NOT.ASSOCIATED(GEOMETRY_PAR%GG) ) THEN
      ALLOCATE( GEOMETRY_PAR%GG, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
      PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )
      GEOMETRY_PAR%GG_TO_BE_DEALLOCATED = .TRUE.
      PP_TRYCALL(ERRFLAG_UNABLE_TO_INITIALIZE_MAP) GEOMETRY_PAR%GG%INIT( HOOKS )
    ENDIF

    DO I = 1, SZ

      !> Get the configuration by ID
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SUBCFG) YAML_GET_CONFIGURATION_BY_ID( DEFINITIONS_CONFIGURATIONS, I, DEFINITION_CONFIGURATION, HOOKS )

      !> Read the type
      PP_TRYCALL(ERRFLAG_READ_GG_PAR) READ_GG_GEOMETRY( DEFINITION_CONFIGURATION, GEOMETRY_PAR%GG, HOOKS )

      !> Destroy the configuration object
      PP_TRYCALL(ERRFLAG_TEST_CASE_DELETE_ERROR) YAML_DELETE_CONFIGURATION( DEFINITION_CONFIGURATION, HOOKS )

    ENDDO

    !> Destroy the configuration object
    PP_TRYCALL(ERRFLAG_TEST_CASE_DELETE_ERROR) YAML_DELETE_CONFIGURATIONS( DEFINITIONS_CONFIGURATIONS, HOOKS )

  ENDIF


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read the configuration' )
    CASE(ERRFLAG_UNABLE_TO_READ_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read the subconfigurations' )
    CASE(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to get the subconfigurations size' )
    CASE(ERRFLAG_UNABLE_TO_GET_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to get the subconfigurations' )
    CASE(ERRFLAG_WRONG_NUMBER_OF_DEFINITIONS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'wrong number of definitions' )
    CASE(ERRFLAG_TEST_CASE_DELETE_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deleting the test case' )
    CASE(ERRFLAG_READ_GG_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error reading the GG geometry' )
    CASE(ERRFLAG_UNABLE_TO_ALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to allocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE( ERRMSG, STAT=ALLOC_STATUS )
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_INITIALIZE_MAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to initialize the map' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION DEFINITION_GG_READ_FROM_YAML
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'DEFINITION_LL_READ_FROM_YAML'
FUNCTION DEFINITION_LL_READ_FROM_YAML( CONFIG, GEOMETRY_PAR, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATIONS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATIONS_SIZE
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATION_BY_ID
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CONFIG
  TYPE(GEOMETRY_PAR_T),       INTENT(INOUT) :: GEOMETRY_PAR
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL :: HAS_DEFINITIONS
  INTEGER(KIND=JPIB_K) :: SZ
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  TYPE(YAML_CONFIGURATION_T)  :: DEFINITION_CONFIGURATION
  TYPE(YAML_CONFIGURATIONS_T) :: DEFINITIONS_CONFIGURATIONS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_SUBCFG = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SUBCFG = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_NUMBER_OF_DEFINITIONS = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_TEST_CASE_DELETE_ERROR = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_GG_PAR = 9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ALLOCATE = 10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_INITIALIZE_MAP = 11_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Read the encoder configuration
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'definitions', HAS_DEFINITIONS, HOOKS )

  !> Read definitions
  IF ( HAS_DEFINITIONS  ) THEN

    !> Read all the subconfigurations
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_SUBCFG) YAML_GET_SUBCONFIGURATIONS( CONFIG, 'definitions', DEFINITIONS_CONFIGURATIONS, HOOKS )

    !> Get the sections size
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE) YAML_GET_CONFIGURATIONS_SIZE( DEFINITIONS_CONFIGURATIONS, SZ, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( SZ .LE. 0, ERRFLAG_WRONG_NUMBER_OF_DEFINITIONS )

    IF ( .NOT.ASSOCIATED(GEOMETRY_PAR%LL) ) THEN
      ALLOCATE( GEOMETRY_PAR%LL, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
      PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )
      GEOMETRY_PAR%LL_TO_BE_DEALLOCATED = .TRUE.
      PP_TRYCALL(ERRFLAG_UNABLE_TO_INITIALIZE_MAP) GEOMETRY_PAR%LL%INIT( HOOKS )
    ENDIF

    DO I = 1, SZ

      !> Get the configuration by ID
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SUBCFG) YAML_GET_CONFIGURATION_BY_ID( DEFINITIONS_CONFIGURATIONS, I, DEFINITION_CONFIGURATION, HOOKS )

      !> Read the type
      PP_TRYCALL(ERRFLAG_READ_GG_PAR) READ_LL_GEOMETRY( DEFINITION_CONFIGURATION, GEOMETRY_PAR%LL, HOOKS )

      !> Destroy the configuration object
      PP_TRYCALL(ERRFLAG_TEST_CASE_DELETE_ERROR) YAML_DELETE_CONFIGURATION( DEFINITION_CONFIGURATION, HOOKS )

    ENDDO

    !> Destroy the configuration object
    PP_TRYCALL(ERRFLAG_TEST_CASE_DELETE_ERROR) YAML_DELETE_CONFIGURATIONS( DEFINITIONS_CONFIGURATIONS, HOOKS )

  ENDIF


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read the configuration' )
    CASE(ERRFLAG_UNABLE_TO_READ_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read the subconfigurations' )
    CASE(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to get the subconfigurations size' )
    CASE(ERRFLAG_UNABLE_TO_GET_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to get the subconfigurations' )
    CASE(ERRFLAG_WRONG_NUMBER_OF_DEFINITIONS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'wrong number of definitions' )
    CASE(ERRFLAG_TEST_CASE_DELETE_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deleting the test case' )
    CASE(ERRFLAG_READ_GG_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error reading the GG geometry' )
    CASE(ERRFLAG_UNABLE_TO_ALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to allocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE( ERRMSG, STAT=ALLOC_STATUS )
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_INITIALIZE_MAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to initialize the map' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION DEFINITION_LL_READ_FROM_YAML
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'DEFINITION_SH_READ_FROM_YAML'
FUNCTION DEFINITION_SH_READ_FROM_YAML( CONFIG, GEOMETRY_PAR, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATIONS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATIONS_SIZE
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATION_BY_ID
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CONFIG
  TYPE(GEOMETRY_PAR_T),       INTENT(INOUT) :: GEOMETRY_PAR
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL :: HAS_DEFINITIONS
  INTEGER(KIND=JPIB_K) :: SZ
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  TYPE(YAML_CONFIGURATION_T)  :: DEFINITION_CONFIGURATION
  TYPE(YAML_CONFIGURATIONS_T) :: DEFINITIONS_CONFIGURATIONS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_SUBCFG = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SUBCFG = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_NUMBER_OF_DEFINITIONS = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_TEST_CASE_DELETE_ERROR = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_SH_PAR = 9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ALLOCATE = 10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_INITIALIZE_MAP = 11_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Read the encoder configuration
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'definitions', HAS_DEFINITIONS, HOOKS )

  !> Read definitions
  IF ( HAS_DEFINITIONS  ) THEN

    !> Read all the subconfigurations
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_SUBCFG) YAML_GET_SUBCONFIGURATIONS( CONFIG, 'definitions', DEFINITIONS_CONFIGURATIONS, HOOKS )

    !> Get the sections size
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE) YAML_GET_CONFIGURATIONS_SIZE( DEFINITIONS_CONFIGURATIONS, SZ, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( SZ .LE. 0, ERRFLAG_WRONG_NUMBER_OF_DEFINITIONS )

    IF ( .NOT.ASSOCIATED(GEOMETRY_PAR%SH) ) THEN
      ALLOCATE( GEOMETRY_PAR%SH, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
      PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )
      GEOMETRY_PAR%SH_TO_BE_DEALLOCATED = .TRUE.
      PP_TRYCALL(ERRFLAG_UNABLE_TO_INITIALIZE_MAP) GEOMETRY_PAR%SH%INIT( HOOKS )
    ENDIF

    DO I = 1, SZ

      !> Get the configuration by ID
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SUBCFG) YAML_GET_CONFIGURATION_BY_ID( DEFINITIONS_CONFIGURATIONS, I, DEFINITION_CONFIGURATION, HOOKS )

      !> Read the type
      PP_TRYCALL(ERRFLAG_READ_SH_PAR) READ_SH_GEOMETRY( DEFINITION_CONFIGURATION, GEOMETRY_PAR%SH, HOOKS )

      !> Destroy the configuration object
      PP_TRYCALL(ERRFLAG_TEST_CASE_DELETE_ERROR) YAML_DELETE_CONFIGURATION( DEFINITION_CONFIGURATION, HOOKS )

    ENDDO

    !> Destroy the configuration object
    PP_TRYCALL(ERRFLAG_TEST_CASE_DELETE_ERROR) YAML_DELETE_CONFIGURATIONS( DEFINITIONS_CONFIGURATIONS, HOOKS )

  ENDIF


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read the configuration' )
    CASE(ERRFLAG_UNABLE_TO_READ_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read the subconfigurations' )
    CASE(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to get the subconfigurations size' )
    CASE(ERRFLAG_UNABLE_TO_GET_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to get the subconfigurations' )
    CASE(ERRFLAG_WRONG_NUMBER_OF_DEFINITIONS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'wrong number of definitions' )
    CASE(ERRFLAG_TEST_CASE_DELETE_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error deleting the test case' )
    CASE(ERRFLAG_READ_SH_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'error reading the SH geometry' )
    CASE(ERRFLAG_UNABLE_TO_ALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to allocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE( ERRMSG, STAT=ALLOC_STATUS )
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_INITIALIZE_MAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to initialize the map' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION DEFINITION_SH_READ_FROM_YAML
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'READ_GG_GEOMETRY'
FUNCTION READ_GG_GEOMETRY( CONFIG, GG_MAP, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: REDUCED_GG_MAP_MOD,  ONLY: REDUCED_GG_GEOM_MAP_T
  USE :: REDUCED_GG_MAP_MOD,  ONLY: REDUCED_GG_GEOMETRY_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_STRING
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_INTEGER
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_INTEGER_ARRAY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_FLOAT


  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(YAML_CONFIGURATION_T),  INTENT(IN)    :: CONFIG
  TYPE(REDUCED_GG_GEOM_MAP_T), INTENT(INOUT) :: GG_MAP
  TYPE(HOOKS_T),               INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL :: HAS_KEY
  TYPE(REDUCED_GG_GEOMETRY_T), POINTER :: GG_GEOMETRY
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  CHARACTER(LEN=:), ALLOCATABLE :: CTMP
  CHARACTER(LEN=8) :: KEY
  INTEGER(KIND=JPIB_K), DIMENSION(:), ALLOCATABLE :: PL

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ALLOCATE = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DEALLOCATE = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_PUSH = 4_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Allocate the geometry object
  GG_GEOMETRY => NULL()
  ALLOCATE( GG_GEOMETRY, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )


  !> Read the "key"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'name', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  IF ( ALLOCATED(CTMP) ) THEN
    DEALLOCATE(CTMP, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
  ENDIF
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_STRING( CONFIG, 'name', CTMP, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(CTMP), ERRFLAG_UNABLE_TO_READ_CFG )
  PP_DEBUG_CRITICAL_COND_THROW( LEN_TRIM(CTMP) .GT. 8, ERRFLAG_UNABLE_TO_READ_CFG )
  KEY = REPEAT(' ',8)
  KEY = CTMP
  IF ( ALLOCATED(CTMP) ) THEN
    DEALLOCATE(CTMP, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
  ENDIF

  !> Read the "truncate-degrees"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'truncate-degrees', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( CONFIG, 'truncate-degrees', GG_GEOMETRY%TRUNCATE_DEGREES, HOOKS )

  !> Read the "number-of-points-along-a-meridian"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'number-of-points-along-a-meridian', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( CONFIG, 'number-of-points-along-a-meridian', GG_GEOMETRY%NUMBER_OF_POINTS_ALONG_A_MERIDIAN, HOOKS )


  !> Read the "number-of-points-between-pole-and-equator"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'number-of-points-between-pole-and-equator', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( CONFIG, 'number-of-points-between-pole-and-equator', GG_GEOMETRY%NUMBER_OF_PARALLELS_BETWEEN_POLE_AND_EQUATOR, HOOKS )

  !> Read the "lat-first-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lat-first-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lat-first-gp-deg', GG_GEOMETRY%LAT_FIRST_GP_DEG, HOOKS )

  !> Read the "lon-first-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lon-first-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lon-first-gp-deg', GG_GEOMETRY%LON_FIRST_GP_DEG, HOOKS )

  !> Read the "lat-last-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lat-last-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lat-last-gp-deg', GG_GEOMETRY%LAT_LAST_GP_DEG, HOOKS )

  !> Read the "lon-last-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lon-last-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lon-last-gp-deg', GG_GEOMETRY%LON_LAST_GP_DEG, HOOKS )

  !> Read "pl"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'pl', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER_ARRAY( CONFIG, 'pl', PL, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(PL), ERRFLAG_UNABLE_TO_READ_CFG )

  !> Allocate the PL array
  ALLOCATE( GG_GEOMETRY%PL( SIZE(PL) ), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )
  GG_GEOMETRY%PL = PL
  DEALLOCATE( PL, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
  GG_GEOMETRY%TO_BE_DEALLOCATED = .TRUE.

  !> Set the geometry object
  PP_TRYCALL(ERRFLAG_UNABLE_TO_PUSH) GG_MAP%PUSH( KEY, GG_GEOMETRY, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_ALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to allocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE( ERRMSG, STAT=ALLOC_STATUS )
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read the configuration' )
    CASE(ERRFLAG_UNABLE_TO_DEALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to deallocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
          PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
          DEALLOCATE( ERRMSG, STAT=ALLOC_STATUS )
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_PUSH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to push into map' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION READ_GG_GEOMETRY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'READ_SH_GEOMETRY'
FUNCTION READ_SH_GEOMETRY( CONFIG, SH_MAP, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,           ONLY: JPIB_K
  USE :: HOOKS_MOD,                   ONLY: HOOKS_T
  USE :: SPHERICAL_HARMONICS_MAP_MOD, ONLY: SPHERICAL_HARMONICS_MAP_T
  USE :: SPHERICAL_HARMONICS_MAP_MOD, ONLY: SPHERICAL_HARMONICS_T
  USE :: YAML_CORE_UTILS_MOD,         ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD,         ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD,         ONLY: YAML_READ_STRING
  USE :: YAML_CORE_UTILS_MOD,         ONLY: YAML_READ_INTEGER
  USE :: YAML_CORE_UTILS_MOD,         ONLY: YAML_READ_INTEGER_ARRAY
  USE :: YAML_CORE_UTILS_MOD,         ONLY: YAML_READ_FLOAT


  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(YAML_CONFIGURATION_T),      INTENT(IN)    :: CONFIG
  TYPE(SPHERICAL_HARMONICS_MAP_T), INTENT(INOUT) :: SH_MAP
  TYPE(HOOKS_T),                   INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL :: HAS_KEY
  TYPE(SPHERICAL_HARMONICS_T), POINTER :: SH_GEOMETRY
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  CHARACTER(LEN=:), ALLOCATABLE :: CTMP
  CHARACTER(LEN=8) :: KEY
  INTEGER(KIND=JPIB_K), DIMENSION(:), ALLOCATABLE :: PL

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ALLOCATE = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DEALLOCATE = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_PUSH = 4_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Allocate the geometry object
  SH_GEOMETRY => NULL()
  ALLOCATE( SH_GEOMETRY, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )


  !> Read the "key"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'name', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  IF ( ALLOCATED(CTMP) ) THEN
    DEALLOCATE(CTMP, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
  ENDIF
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_STRING( CONFIG, 'name', CTMP, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(CTMP), ERRFLAG_UNABLE_TO_READ_CFG )
  PP_DEBUG_CRITICAL_COND_THROW( LEN_TRIM(CTMP) .GT. 8, ERRFLAG_UNABLE_TO_READ_CFG )
  KEY = REPEAT(' ',8)
  KEY = CTMP
  IF ( ALLOCATED(CTMP) ) THEN
    DEALLOCATE(CTMP, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
  ENDIF

#if 0
  !> Read the "truncate-degrees"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'truncate-degrees', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( CONFIG, 'truncate-degrees', SH_GEOMETRY%TRUNCATE_DEGREES, HOOKS )

  !> Read the "number-of-points-along-a-meridian"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'number-of-points-along-a-meridian', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( CONFIG, 'number-of-points-along-a-meridian', SH_GEOMETRY%NUMBER_OF_POINTS_ALONG_A_MERIDIAN, HOOKS )


  !> Read the "number-of-points-between-pole-and-equator"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'number-of-points-between-pole-and-equator', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( CONFIG, 'number-of-points-between-pole-and-equator', SH_GEOMETRY%NUMBER_OF_PARALLELS_BETWEEN_POLE_AND_EQUATOR, HOOKS )

  !> Read the "lat-first-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lat-first-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lat-first-gp-deg', SH_GEOMETRY%LAT_FIRST_GP_DEG, HOOKS )

  !> Read the "lon-first-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lon-first-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lon-first-gp-deg', SH_GEOMETRY%LON_FIRST_GP_DEG, HOOKS )

  !> Read the "lat-last-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lat-last-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lat-last-gp-deg', SH_GEOMETRY%LAT_LAST_GP_DEG, HOOKS )

  !> Read the "lon-last-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lon-last-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lon-last-gp-deg', SH_GEOMETRY%LON_LAST_GP_DEG, HOOKS )

  !> Read "pl"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'pl', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER_ARRAY( CONFIG, 'pl', PL, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(PL), ERRFLAG_UNABLE_TO_READ_CFG )

  !> Allocate the PL array
  ALLOCATE( SH_GEOMETRY%PL( SIZE(PL) ), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )
  SH_GEOMETRY%PL = PL
  DEALLOCATE( PL, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
  SH_GEOMETRY%TO_BE_DEALLOCATED = .TRUE.

  !> Set the geometry object
  PP_TRYCALL(ERRFLAG_UNABLE_TO_PUSH) SH_MAP%PUSH( KEY, SH_GEOMETRY, HOOKS )
#endif

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_ALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to allocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE( ERRMSG, STAT=ALLOC_STATUS )
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read the configuration' )
    CASE(ERRFLAG_UNABLE_TO_DEALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to deallocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
          PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
          DEALLOCATE( ERRMSG, STAT=ALLOC_STATUS )
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_PUSH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to push into map' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION READ_SH_GEOMETRY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'READ_LL_GEOMETRY'
FUNCTION READ_LL_GEOMETRY( CONFIG, LL_MAP, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: REGULAR_LL_MAP_MOD,  ONLY: REGULAR_LL_GEOM_MAP_T
  USE :: REGULAR_LL_MAP_MOD,  ONLY: REGULAR_LL_GEOMETRY_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_STRING
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_INTEGER
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_INTEGER_ARRAY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_FLOAT


  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(YAML_CONFIGURATION_T),  INTENT(IN)    :: CONFIG
  TYPE(REGULAR_LL_GEOM_MAP_T), INTENT(INOUT) :: LL_MAP
  TYPE(HOOKS_T),               INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL :: HAS_KEY
  TYPE(REGULAR_LL_GEOMETRY_T), POINTER :: LL_GEOMETRY
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  CHARACTER(LEN=:), ALLOCATABLE :: CTMP
  CHARACTER(LEN=8) :: KEY
  INTEGER(KIND=JPIB_K), DIMENSION(:), ALLOCATABLE :: PL

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ALLOCATE = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DEALLOCATE = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_PUSH = 4_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Allocate the geometry object
  LL_GEOMETRY => NULL()
  ALLOCATE( LL_GEOMETRY, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )


  !> Read the "key"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'name', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  IF ( ALLOCATED(CTMP) ) THEN
    DEALLOCATE(CTMP, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
  ENDIF
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_STRING( CONFIG, 'name', CTMP, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(CTMP), ERRFLAG_UNABLE_TO_READ_CFG )
  PP_DEBUG_CRITICAL_COND_THROW( LEN_TRIM(CTMP) .GT. 8, ERRFLAG_UNABLE_TO_READ_CFG )
  KEY = REPEAT(' ',8)
  KEY = CTMP
  IF ( ALLOCATED(CTMP) ) THEN
    DEALLOCATE(CTMP, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
  ENDIF

#if 0
  !> Read the "truncate-degrees"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'truncate-degrees', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( CONFIG, 'truncate-degrees', LL_GEOMETRY%TRUNCATE_DEGREES, HOOKS )

  !> Read the "number-of-points-along-a-meridian"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'number-of-points-along-a-meridian', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( CONFIG, 'number-of-points-along-a-meridian', LL_GEOMETRY%NUMBER_OF_POINTS_ALONG_A_MERIDIAN, HOOKS )


  !> Read the "number-of-points-between-pole-and-equator"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'number-of-points-between-pole-and-equator', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( CONFIG, 'number-of-points-between-pole-and-equator', LL_GEOMETRY%NUMBER_OF_PARALLELS_BETWEEN_POLE_AND_EQUATOR, HOOKS )

  !> Read the "lat-first-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lat-first-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lat-first-gp-deg', LL_GEOMETRY%LAT_FIRST_GP_DEG, HOOKS )

  !> Read the "lon-first-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lon-first-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lon-first-gp-deg', LL_GEOMETRY%LON_FIRST_GP_DEG, HOOKS )

  !> Read the "lat-last-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lat-last-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lat-last-gp-deg', LL_GEOMETRY%LAT_LAST_GP_DEG, HOOKS )

  !> Read the "lon-last-gp-deg"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'lon-last-gp-deg', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( CONFIG, 'lon-last-gp-deg', LL_GEOMETRY%LON_LAST_GP_DEG, HOOKS )

  !> Read "pl"
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'pl', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_KEY, ERRFLAG_UNABLE_TO_READ_CFG )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER_ARRAY( CONFIG, 'pl', PL, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(PL), ERRFLAG_UNABLE_TO_READ_CFG )

  !> Allocate the PL array
  ALLOCATE( LL_GEOMETRY%PL( SIZE(PL) ), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )
  LL_GEOMETRY%PL = PL
  DEALLOCATE( PL, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_DEALLOCATE )
  LL_GEOMETRY%TO_BE_DEALLOCATED = .TRUE.

  !> Set the geometry object
  PP_TRYCALL(ERRFLAG_UNABLE_TO_PUSH) LL_MAP%PUSH( KEY, LL_GEOMETRY, HOOKS )
#endif

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_ALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to allocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE( ERRMSG, STAT=ALLOC_STATUS )
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read the configuration' )
    CASE(ERRFLAG_UNABLE_TO_DEALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to deallocate memory' )
      IF ( ALLOCATED(ERRMSG) ) THEN
          PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
          DEALLOCATE( ERRMSG, STAT=ALLOC_STATUS )
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_PUSH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to push into map' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION READ_LL_GEOMETRY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


END MODULE GEOMETRY_PAR_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME
