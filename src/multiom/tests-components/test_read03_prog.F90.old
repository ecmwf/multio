! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"

#define PP_FILE_NAME 'test_read03_prog.F90'
#define PP_SECTION_TYPE 'PROGRAM'
#define PP_SECTION_NAME 'TEST_READ03_PROG'
#define PP_PROCEDURE_TYPE 'PROGRAM'
#define PP_PROCEDURE_NAME 'MAIN'
PROGRAM TEST_READ03_PROG

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K

  USE :: FILTER_BASE_MOD,    ONLY: FILTER_BASE_A
  USE :: FILTER_FACTORY_MOD, ONLY: MAKE_FILTER
  USE :: FILTER_FACTORY_MOD, ONLY: DESTROY_FILTER
  USE :: FILTER_OPTIONS_MOD, ONLY: FILTER_OPTIONS_T

  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATIONS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_NEW_CONFIGURATION_FROM_FILE
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATIONS_SIZE
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATION_BY_ID
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATIONS

  USE :: PARAMETRIZATION_MOD, ONLY: PARAMETRIZATION_T
  USE :: FORTRAN_MESSAGE_MOD, ONLY: FORTRAN_MESSAGE_T

  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T

  USE :: HOOKS_MOD, ONLY: HOOKS_T
  USE :: ENCODING_RULES_MOD, ONLY: ENCODING_RULE_CONTAINER_T
  USE :: ENCODING_RULES_MOD, ONLY: ENCODING_RULE_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

IMPLICIT NONE

  !> Test encodr object
  CLASS(FILTER_BASE_A), POINTER :: FILTER => NULL()
  TYPE(HOOKS_T) :: HOOKS
  TYPE(YAML_CONFIGURATION_T) :: CONFIG
  INTEGER(KIND=JPIB_K) :: UNIT
  INTEGER(KIND=JPIB_K) :: OFFSET
  INTEGER(KIND=JPIB_K) :: RET
  INTEGER(KIND=JPIB_K) :: LENGTH
  INTEGER(KIND=JPIB_K) :: ENCODER_TYPE
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: N_RULES
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  LOGICAL :: HAS_RULES
  TYPE(YAML_CONFIGURATIONS_T) :: RULES_CONFIGURATION
  TYPE(YAML_CONFIGURATION_T) :: RULE_CONFIGURATION
  TYPE(ENCODING_RULE_CONTAINER_T), ALLOCATABLE, DIMENSION(:) :: RULES
  TYPE(FORTRAN_MESSAGE_T) :: MSG
  TYPE(PARAMETRIZATION_T) :: PAR
  TYPE(FILTER_OPTIONS_T)       :: FILTER_OPT
  TYPE(GRIB_ENCODER_OPTIONS_T) :: ENCODER_OPT
  TYPE(ENCODING_RULE_T) :: RULE
  LOGICAL :: MATCH
  LOGICAL :: FEXIST


  ! TYPE(GRIB_ENCODER_OPTIONS_T) :: OPT
  CHARACTER(LEN=256) :: FNAME

  ! Error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_FILE_DOES_NOT_EXIST=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_FILE=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_SECTIONS_UNDEFINED=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_SUBCFG=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_NUMBER_OF_RULES=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ALLOCATE_RULES=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG_BY_ID=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONSTRUCT_THE_RULE=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULE_DEALLOCATION_ERROR=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DELETE_CONFIGURATIONS=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_PRINT_THE_RULE=12_JPIB_K



  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Get the first command-line argument (index starts from 1)
  FNAME = REPEAT(' ', 256)
  IF ( COMMAND_ARGUMENT_COUNT() .EQ. 1 ) THEN
    ! Get the first command-line argument (index starts from 1)
    CALL GET_COMMAND_ARGUMENT(1, FNAME, LENGTH, RET )
    IF (RET .NE. 0) THEN
      FNAME = 'config-rule.yaml'
    END IF
  ELSE
    FNAME = 'config-rule.yaml'
  END IF

  ! Inquire file existence
  INQUIRE( FILE=TRIM(ADJUSTL(FNAME)), EXIST=FEXIST )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. FEXIST, ERRFLAG_CFG_FILE )

  !> Set the unit and offset
  UNIT = 6
  OFFSET = 1
  CALL HOOKS%DEBUG_HOOK_%INIT( )


  MSG%PARAM = 1
  MSG%LEVTYPE = 1


  !> Open the configuration file
  PP_TRYCALL(ERRFLAG_CFG_FILE_DOES_NOT_EXIST) YAML_NEW_CONFIGURATION_FROM_FILE( TRIM(ADJUSTL(FNAME)), CONFIG, HOOKS )

  !> Read the encoder configuration
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'rules', HAS_RULES, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. HAS_RULES, ERRFLAG_SECTIONS_UNDEFINED )

  !> Read all the subconfigurations
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_SUBCFG) YAML_GET_SUBCONFIGURATIONS( CONFIG, 'rules', RULES_CONFIGURATION, HOOKS )

  !> Get the sections size
  PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE) YAML_GET_CONFIGURATIONS_SIZE( RULES_CONFIGURATION, N_RULES, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( N_RULES .LE. 0, ERRFLAG_WRONG_NUMBER_OF_RULES )

  ALLOCATE(RULES(N_RULES), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE_RULES )

  !> Loop over sections
  DO I = 1 , N_RULES

    !> Get section configuration by ID
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG_BY_ID) YAML_GET_CONFIGURATION_BY_ID( RULES_CONFIGURATION, I, RULE_CONFIGURATION, HOOKS )

    !> Create the rule object
    ALLOCATE(RULES(I)%RULE_, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE_RULES )

    !> Read the rule
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONSTRUCT_THE_RULE) RULES(I)%RULE_%INIT( I, RULE_CONFIGURATION, FILTER_OPT, ENCODER_OPT, HOOKS )

    !> Print the rule
    PP_TRYCALL(ERRFLAG_UNABLE_TO_PRINT_THE_RULE) RULES(I)%RULE_%PRINT( 6_JPIB_K, 0_JPIB_K, ENCODER_OPT, HOOKS )

    !> Deallocate section configuration
    PP_TRYCALL( ERRFLAG_RULE_DEALLOCATION_ERROR ) YAML_DELETE_CONFIGURATION( RULE_CONFIGURATION, HOOKS )

  ENDDO

  !> Destroy the configuration object
  PP_TRYCALL(ERRFLAG_DELETE_CONFIGURATIONS) YAML_DELETE_CONFIGURATIONS( RULES_CONFIGURATION, HOOKS )

  !> Deallocate section configuration
  PP_TRYCALL( ERRFLAG_RULE_DEALLOCATION_ERROR ) YAML_DELETE_CONFIGURATION( CONFIG, HOOKS )

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  !> Exit point (on success)
  STOP 0

! Error handler
PP_ERROR_HANDLER

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_CFG_FILE_DOES_NOT_EXIST)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'The configuration file does not exist' )
    CASE(ERRFLAG_CFG_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error opening the configuration file' )
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading the configuration file' )
    CASE(ERRFLAG_SECTIONS_UNDEFINED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'The sections are not defined' )
    CASE(ERRFLAG_UNABLE_TO_READ_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading the subconfigurations' )
    CASE(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error getting the subconfigurations size' )
    CASE(ERRFLAG_WRONG_NUMBER_OF_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'The number of rules is wrong' )
    CASE(ERRFLAG_UNABLE_TO_ALLOCATE_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error allocating the rules' )
    CASE(ERRFLAG_UNABLE_TO_READ_CFG_BY_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error reading the configuration by ID' )
    CASE(ERRFLAG_UNABLE_TO_CONSTRUCT_THE_RULE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error constructing the rule' )
    CASE(ERRFLAG_RULE_DEALLOCATION_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error deallocating the rule' )
    CASE(ERRFLAG_DELETE_CONFIGURATIONS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error deleting the configuration object' )
    CASE(ERRFLAG_UNABLE_TO_PRINT_THE_RULE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error printing the rule' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( 6_JPIB_K )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT()

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  STOP 1

END PROGRAM TEST_READ03_PROG
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME