! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"


#define PP_FILE_NAME 'api_dictionary_wrapper_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'API_DICTIONARY_WRAPPER_MOD'
MODULE API_DICTIONARY_WRAPPER_MOD

IMPLICIT NONE

!> Default visibility of the module
PRIVATE


! Whitelist of public symbols (dictionaries management)
PUBLIC :: MULTIO_GRIB2_INIT_OPTIONS
PUBLIC :: MULTIO_GRIB2_DICT_CREATE
PUBLIC :: MULTIO_GRIB2_DICT_DESTROY
PUBLIC :: MULTIO_GRIB2_DICT_SET
PUBLIC :: MULTIO_GRIB2_DICT_GET
PUBLIC :: MULTIO_GRIB2_DICT_HAS
PUBLIC :: MULTIO_GRIB2_DICT_ITERATE
PUBLIC :: MULTIO_GRIB2_DICT_TO_YAML

CONTAINS


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_INIT_OPTIONS'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_INIT_OPTIONS( DICT ) &
 BIND(C,NAME='multio_grib2_init_options') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), INTENT(INOUT) :: DICT

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

  ! TODO: Add error handling code here

  RETURN

END FUNCTION MULTIO_GRIB2_INIT_OPTIONS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_CREATE'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_CREATE( MULTIO_GRIB2, DICT_TYPE, LEN ) &
 BIND(C,NAME='multio_grib2_dict_create_f') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LOC
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,                ONLY: JPIB_K
  USE :: HOOKS_MOD,                        ONLY: HOOKS_T
  USE :: MAP_INT64_OPT_DICT_MOD,           ONLY: MAP_FUNCTION_INT64_OPT_DICT_IF
  USE :: MAP_INT64_MARS_DICT_MOD,          ONLY: MAP_FUNCTION_INT64_MARS_DICT_IF
  USE :: MAP_INT64_PAR_DICT_MOD,           ONLY: MAP_FUNCTION_INT64_PAR_DICT_IF
  USE :: MAP_INT64_REDUCED_GG_DICT_MOD,    ONLY: MAP_FUNCTION_INT64_REDUCED_GG_DICT_IF
  USE :: MAP_INT64_SH_DICT_MOD,            ONLY: MAP_FUNCTION_INT64_SH_DICT_IF
  USE :: API_SHARED_DATA_MOD,              ONLY: OPT_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,              ONLY: MARS_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,              ONLY: PAR_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,              ONLY: REDUCED_GG_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,              ONLY: SH_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,              ONLY: SHARED_OPT_DICT_MAP
  USE :: API_SHARED_DATA_MOD,              ONLY: SHARED_MARS_DICT_MAP
  USE :: API_SHARED_DATA_MOD,              ONLY: SHARED_PAR_DICT_MAP
  USE :: API_SHARED_DATA_MOD,              ONLY: SHARED_REDUCED_GG_DICT_MAP
  USE :: API_SHARED_DATA_MOD,              ONLY: SHARED_SH_DICT_MAP
  USE :: API_SHARED_DATA_MOD,              ONLY: FREE_OPTIONS
  USE :: API_SHARED_DATA_MOD,              ONLY: FREE_MARS_MESSAGE
  USE :: API_SHARED_DATA_MOD,              ONLY: FREE_PARAMETRIZATION
  USE :: API_SHARED_DATA_MOD,              ONLY: FREE_REDUCED_GG_DICT
  USE :: API_SHARED_DATA_MOD,              ONLY: FREE_SH_DICT
  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: API_OPTIONS_T
  USE :: FORTRAN_MESSAGE_MOD,              ONLY: FORTRAN_MESSAGE_T
  USE :: PARAMETRIZATION_MOD,              ONLY: PARAMETRIZATION_T
  USE :: REPRESENTATIONS_MOD,              ONLY: REDUCED_GG_T
  USE :: REPRESENTATIONS_MOD,              ONLY: SH_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR),                INTENT(INOUT) :: MULTIO_GRIB2
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: DICT_TYPE
  INTEGER(KIND=C_INT), VALUE, INTENT(IN)    :: LEN

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  TYPE(HOOKS_T) :: HOOKS
  LOGICAL :: INITIALIZED
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_MULTIO_GRIB2
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: SIZE
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  INTEGER(KIND=C_LONG_LONG), DIMENSION(:) , POINTER   :: MAX_DICT_HANDLE
  CHARACTER(LEN=1,KIND=C_CHAR), DIMENSION(:), POINTER :: DICT_TYPE_C
  CHARACTER(LEN=32) :: DICT_TYPE_NAME
  TYPE(API_OPTIONS_T), POINTER     :: OPTIONS
  TYPE(FORTRAN_MESSAGE_T), POINTER :: MESSAGE
  TYPE(PARAMETRIZATION_T), POINTER :: PARAMETRIZATION
  TYPE(REDUCED_GG_T), POINTER      :: REDUCED_GG
  TYPE(SH_T), POINTER              :: SH
  PROCEDURE(MAP_FUNCTION_INT64_OPT_DICT_IF), POINTER        :: OPTIONS_DESTRUCTOR
  PROCEDURE(MAP_FUNCTION_INT64_MARS_DICT_IF), POINTER       :: MESSAGE_DESTRUCTOR
  PROCEDURE(MAP_FUNCTION_INT64_PAR_DICT_IF), POINTER        :: PARAMETRIZATION_DESTRUCTOR
  PROCEDURE(MAP_FUNCTION_INT64_REDUCED_GG_DICT_IF), POINTER :: REDUCED_GG_DESTRUCTOR
  PROCEDURE(MAP_FUNCTION_INT64_SH_DICT_IF), POINTER         :: SH_DESTRUCTOR


  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOC_FAILURE=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ADD_DICTIONARY=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_INIT_MAP=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SIZE=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_MAXIMUM=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_LENGTH=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_ALREADY_ASSOCIATED=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTYPE_NOT_ASSOCIATED=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TOCHECK_INITIALIZATION_STATUS=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_DICTIONARY_TYPE=11_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( C_ASSOCIATED(MULTIO_GRIB2),   ERRFLAG_DICTIONARY_ALREADY_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT_TYPE), ERRFLAG_DICTYPE_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( LEN .LE. 0, ERRFLAG_INVALID_LENGTH )

  !> Get the size of the dictionary type
  CALL C_F_POINTER( DICT_TYPE, DICT_TYPE_C, [LEN] )

  ! Copy the dictionary type to a fortran string
  DICT_TYPE_NAME = REPEAT(' ', 32)
  DO I = 1, LEN
    DICT_TYPE_NAME(I:I) = DICT_TYPE_C(I)
  END DO

  !TODO: Convert to lowercase

  SELECT CASE( TRIM(DICT_TYPE_NAME) )

  CASE ('mars', 'm', 'mars-dict', 'mars_dict')

    !> Get the dictionary handle from the c pointer
    ALLOCATE( F_MULTIO_GRIB2(2), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_UNABLE_TOCHECK_INITIALIZATION_STATUS) SHARED_MARS_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )

    !> Conditionally initialized the dictionarys map
!$omp single
    IF ( .NOT. INITIALIZED ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_INIT_MAP) SHARED_MARS_DICT_MAP%INIT( HOOKS )
    ENDIF
!$omp end single

!$omp critical(API_DICTIONARY_MAP_INSERT)
    !> Get the size of the dictionary map
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_MARS_DICT_MAP%SIZE( SIZE, HOOKS )

    IF ( SIZE .EQ. 0_JPIB_K ) THEN
      F_MULTIO_GRIB2(1) = MARS_DICT_TYPE_E
      F_MULTIO_GRIB2(2) = 1_C_LONG_LONG
    ELSE
      !> Check if the dictionary is already in the dictionarys map
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAXIMUM) SHARED_MARS_DICT_MAP%MAX( MAX_DICT_HANDLE, HOOKS )

      !> Increment the dictionary handle
      F_MULTIO_GRIB2(1) = MARS_DICT_TYPE_E
      F_MULTIO_GRIB2(2) = MAX_DICT_HANDLE(2) + 1_C_LONG_LONG
    ENDIF

    !> Allocate the mars dictionary
    ALLOCATE( MESSAGE, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    MESSAGE_DESTRUCTOR => FREE_MARS_MESSAGE
    PP_TRYCALL(ERRFLAG_UNABLE_TO_ADD_DICTIONARY) SHARED_MARS_DICT_MAP%INSERT( F_MULTIO_GRIB2, MESSAGE, MESSAGE_DESTRUCTOR, HOOKS )
!$omp end critical(API_DICTIONARY_MAP_INSERT)

    !> Get the location of the dictionary
    MULTIO_GRIB2 = C_LOC( F_MULTIO_GRIB2 )

  CASE ('parametrization', 'p', 'par', 'param', 'parametrization-dict', 'parametrization_dict', 'par-dict', 'par_dict', 'param-dict', 'param_dict')


    !> Get the dictionary handle from the c pointer
    ALLOCATE( F_MULTIO_GRIB2(2), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_UNABLE_TOCHECK_INITIALIZATION_STATUS) SHARED_PAR_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )

    !> Conditionally initialized the dictionarys map
!$omp single
    IF ( .NOT. INITIALIZED ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_INIT_MAP) SHARED_PAR_DICT_MAP%INIT( HOOKS )
    ENDIF
!$omp end single

!$omp critical(API_DICTIONARY_MAP_INSERT)
    !> Get the size of the dictionary map
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_PAR_DICT_MAP%SIZE( SIZE, HOOKS )

    IF ( SIZE .EQ. 0_JPIB_K ) THEN
      F_MULTIO_GRIB2(1) = PAR_DICT_TYPE_E
      F_MULTIO_GRIB2(2) = 1_C_LONG_LONG
    ELSE
      !> Check if the dictionary is already in the dictionarys map
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAXIMUM) SHARED_PAR_DICT_MAP%MAX( MAX_DICT_HANDLE, HOOKS )

      !> Increment the dictionary handle
      F_MULTIO_GRIB2(1) = PAR_DICT_TYPE_E
      F_MULTIO_GRIB2(2) = MAX_DICT_HANDLE(2) + 1_C_LONG_LONG
    ENDIF

    !> Allocate the mars dictionary
    ALLOCATE( PARAMETRIZATION, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    PARAMETRIZATION_DESTRUCTOR => FREE_PARAMETRIZATION
    PP_TRYCALL(ERRFLAG_UNABLE_TO_ADD_DICTIONARY) SHARED_PAR_DICT_MAP%INSERT( F_MULTIO_GRIB2, PARAMETRIZATION, PARAMETRIZATION_DESTRUCTOR, HOOKS )
!$omp end critical(API_DICTIONARY_MAP_INSERT)

    !> Get the location of the dictionary
    MULTIO_GRIB2 = C_LOC( F_MULTIO_GRIB2 )


  CASE ( 'reducedgg', 'reduced-gg', 'geometryreducedgg', 'geometry-reduced-gg' )

    !> Get the dictionary handle from the c pointer
    ALLOCATE( F_MULTIO_GRIB2(2), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_UNABLE_TOCHECK_INITIALIZATION_STATUS) SHARED_REDUCED_GG_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )

    !> Conditionally initialized the dictionarys map
!$omp single
    IF ( .NOT. INITIALIZED ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_INIT_MAP) SHARED_REDUCED_GG_DICT_MAP%INIT( HOOKS )
    ENDIF
!$omp end single

!$omp critical(API_DICTIONARY_MAP_INSERT)
    !> Get the size of the dictionary map
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_REDUCED_GG_DICT_MAP%SIZE( SIZE, HOOKS )

    IF ( SIZE .EQ. 0_JPIB_K ) THEN
      F_MULTIO_GRIB2(1) = REDUCED_GG_DICT_TYPE_E
      F_MULTIO_GRIB2(2) = 1_C_LONG_LONG
    ELSE
      !> Check if the dictionary is already in the dictionarys map
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAXIMUM) SHARED_REDUCED_GG_DICT_MAP%MAX( MAX_DICT_HANDLE, HOOKS )

      !> Increment the dictionary handle
      F_MULTIO_GRIB2(1) = REDUCED_GG_DICT_TYPE_E
      F_MULTIO_GRIB2(2) = MAX_DICT_HANDLE(2) + 1_C_LONG_LONG
    ENDIF

    !> Allocate the mars dictionary
    ALLOCATE( REDUCED_GG, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    REDUCED_GG_DESTRUCTOR => FREE_REDUCED_GG_DICT
    PP_TRYCALL(ERRFLAG_UNABLE_TO_ADD_DICTIONARY) SHARED_REDUCED_GG_DICT_MAP%INSERT( F_MULTIO_GRIB2, REDUCED_GG, REDUCED_GG_DESTRUCTOR, HOOKS )
!$omp end critical(API_DICTIONARY_MAP_INSERT)

    !> Get the location of the dictionary
    MULTIO_GRIB2 = C_LOC( F_MULTIO_GRIB2 )


  CASE ( 'sh', 'spherical-harmonics', 'geometry-sh', 'geometry-spherical-harmonics', 'geometrysh', 'geometrysphericalharmonics' )

    !> Get the dictionary handle from the c pointer
    ALLOCATE( F_MULTIO_GRIB2(2), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_UNABLE_TOCHECK_INITIALIZATION_STATUS) SHARED_SH_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )

    !> Conditionally initialized the dictionarys map
!$omp single
    IF ( .NOT. INITIALIZED ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_INIT_MAP) SHARED_SH_DICT_MAP%INIT( HOOKS )
    ENDIF
!$omp end single

!$omp critical(API_DICTIONARY_MAP_INSERT)
    !> Get the size of the dictionary map
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_SH_DICT_MAP%SIZE( SIZE, HOOKS )

    IF ( SIZE .EQ. 0_JPIB_K ) THEN
      F_MULTIO_GRIB2(1) = SH_DICT_TYPE_E
      F_MULTIO_GRIB2(2) = 1_C_LONG_LONG
    ELSE
      !> Check if the dictionary is already in the dictionarys map
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAXIMUM) SHARED_SH_DICT_MAP%MAX( MAX_DICT_HANDLE, HOOKS )

      !> Increment the dictionary handle
      F_MULTIO_GRIB2(1) = SH_DICT_TYPE_E
      F_MULTIO_GRIB2(2) = MAX_DICT_HANDLE(2) + 1_C_LONG_LONG
    ENDIF

    !> Allocate the mars dictionary
    ALLOCATE( SH, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    SH_DESTRUCTOR => FREE_SH_DICT
    PP_TRYCALL(ERRFLAG_UNABLE_TO_ADD_DICTIONARY) SHARED_SH_DICT_MAP%INSERT( F_MULTIO_GRIB2, SH, SH_DESTRUCTOR, HOOKS )
!$omp end critical(API_DICTIONARY_MAP_INSERT)

    !> Get the location of the dictionary
    MULTIO_GRIB2 = C_LOC( F_MULTIO_GRIB2 )

  CASE ('options', 'opt' )

    !> Get the dictionary handle from the c pointer
    ALLOCATE( F_MULTIO_GRIB2(2), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_UNABLE_TOCHECK_INITIALIZATION_STATUS) SHARED_OPT_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )

    !> Conditionally initialized the dictionarys map
!$omp single
    IF ( .NOT. INITIALIZED ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_INIT_MAP) SHARED_OPT_DICT_MAP%INIT( HOOKS )
    ENDIF
!$omp end single

!$omp critical(API_DICTIONARY_MAP_INSERT)
    !> Get the size of the dictionary map
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_OPT_DICT_MAP%SIZE( SIZE, HOOKS )

    IF ( SIZE .EQ. 0_JPIB_K ) THEN
      F_MULTIO_GRIB2(1) = OPT_DICT_TYPE_E
      F_MULTIO_GRIB2(2) = 1_C_LONG_LONG
    ELSE
      !> Check if the dictionary is already in the dictionarys map
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAXIMUM) SHARED_OPT_DICT_MAP%MAX( MAX_DICT_HANDLE, HOOKS )

      !> Increment the dictionary handle
      F_MULTIO_GRIB2(1) = OPT_DICT_TYPE_E
      F_MULTIO_GRIB2(2) = MAX_DICT_HANDLE(2) + 1_C_LONG_LONG
    ENDIF

    !> Allocate the mars dictionary
    ALLOCATE( OPTIONS, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    OPTIONS_DESTRUCTOR => FREE_OPTIONS
    PP_TRYCALL(ERRFLAG_UNABLE_TO_ADD_DICTIONARY) SHARED_OPT_DICT_MAP%INSERT( F_MULTIO_GRIB2, OPTIONS, OPTIONS_DESTRUCTOR, HOOKS )
!$omp end critical(API_DICTIONARY_MAP_INSERT)

    !> Get the location of the dictionary
    MULTIO_GRIB2 = C_LOC( F_MULTIO_GRIB2 )


  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_DICTIONARY_TYPE )
  END SELECT


  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_ALREADY_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary already associated' )
    CASE (ERRFLAG_DICTYPE_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary type not associated' )
    CASE (ERRFLAG_INVALID_LENGTH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid length for "dic_type"' )
    CASE (ERRFLAG_ALLOC_FAILURE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Allocation failure' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG, STAT=ALLOC_STATUS)
      END IF
    CASE (ERRFLAG_UNABLE_TO_INIT_MAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to initialize the map' )
    CASE (ERRFLAG_UNABLE_TO_GET_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get the size of the map' )
    CASE (ERRFLAG_UNABLE_TO_GET_MAXIMUM)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get the maximum of the map' )
    CASE (ERRFLAG_UNABLE_TO_ADD_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to add the dictionary to the map' )
    CASE (ERRFLAG_UNABLE_TOCHECK_INITIALIZATION_STATUS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check the initialization status of the map' )
    CASE (ERRFLAG_UNKNOWN_DICTIONARY_TYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown dictionary type' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_CREATE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE






#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_DESTROY'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_DESTROY( MULTIO_GRIB2 ) &
 BIND(C,NAME='multio_grib2_dict_destroy') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: API_SHARED_DATA_MOD, ONLY: SHARED_OPT_DICT_MAP
  USE :: API_SHARED_DATA_MOD, ONLY: SHARED_MARS_DICT_MAP
  USE :: API_SHARED_DATA_MOD, ONLY: SHARED_PAR_DICT_MAP
  USE :: API_SHARED_DATA_MOD, ONLY: SHARED_REDUCED_GG_DICT_MAP
  USE :: API_SHARED_DATA_MOD, ONLY: SHARED_SH_DICT_MAP
  USE :: API_SHARED_DATA_MOD, ONLY: OPT_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: MARS_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: PAR_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: REDUCED_GG_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: SH_DICT_TYPE_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE, INTENT(IN) :: MULTIO_GRIB2

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  TYPE(C_PTR), POINTER, DIMENSION(:) :: TMP
  LOGICAL :: INITIALIZED
  LOGICAL :: MAP_HAS_DICTIONARY
  LOGICAL :: DICTIONARY_REMOVED
  INTEGER(KIND=JPIB_K) :: MAP_SIZE
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_MULTIO_GRIB2
  TYPE(HOOKS_T) :: HOOKS

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAP_NOT_INITIALIZED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_DICTIONARY=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_REMOVE_DICTIONARY=4_JPIB_K
  ! INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAP_LIST=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_FREE_MAP=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SIZE=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE=10_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(MULTIO_GRIB2), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  ! WRITE(*,*) 'MULTIO_GRIB2 0 '
  TMP => NULL()
  CALL C_F_POINTER( MULTIO_GRIB2, TMP, [1] )
  ! WRITE(*,*) 'MULTIO_GRIB2 1 '

  !> Get th fortran handle from the c handle
  F_MULTIO_GRIB2 => NULL()
  CALL C_F_POINTER( TMP(1), F_MULTIO_GRIB2, [2] )
  ! WRITE(*,*) 'F_MULTIO_GRIB2(1): ', F_MULTIO_GRIB2(1)

  !> Check the allocation status of the fortran handle
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_MULTIO_GRIB2), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_MULTIO_GRIB2(1) )

  CASE ( MARS_DICT_TYPE_E )

!$omp critical(API_DICTIONARY_MAP_REMOVE)

    !> Print the mars dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_MARS_DICT_MAP%LIST( 6_JPIB_K, 'MARS_DICTIONARY_MAP: ', HOOKS )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_MAP_NOT_INITIALIZED) SHARED_MARS_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. INITIALIZED, ERRFLAG_MAP_NOT_INITIALIZED )

    !> Check if the handle is associated to an dictionary
    PP_TRYCALL(ERRFLAG_MATCH_DICTIONARY) SHARED_MARS_DICT_MAP%HAS( F_MULTIO_GRIB2, MAP_HAS_DICTIONARY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. MAP_HAS_DICTIONARY, ERRFLAG_MATCH_DICTIONARY )

    !> Remove the dictionary from the map
    PP_TRYCALL(ERRFLAG_REMOVE_DICTIONARY) SHARED_MARS_DICT_MAP%REMOVE( F_MULTIO_GRIB2, DICTIONARY_REMOVED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. DICTIONARY_REMOVED, ERRFLAG_REMOVE_DICTIONARY )

    !> Print the dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_ESHARED_MARS_DICT_MAPNCODER_MAP%LIST( 6_JPIB_K, 'MARS_DICTIONARY_MAP: ', HOOKS )

    !> Get the map size
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_MARS_DICT_MAP%SIZE( MAP_SIZE, HOOKS )

    !> To avoid the need of init/exit API, every time the map is empty we deallocate the map
    IF ( MAP_SIZE .EQ. 0_JPIB_K ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE_MAP) SHARED_MARS_DICT_MAP%FREE( HOOKS )
    ENDIF
!$omp end critical(API_DICTIONARY_MAP_REMOVE)

  CASE ( PAR_DICT_TYPE_E )


!$omp critical(API_DICTIONARY_MAP_REMOVE)

    !> Print the parametrization dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_PAR_DICT_MAP%LIST( 6_JPIB_K, 'PARAMETRIZATION_DICTIONARY_MAP: ', HOOKS )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_MAP_NOT_INITIALIZED) SHARED_PAR_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. INITIALIZED, ERRFLAG_MAP_NOT_INITIALIZED )

    !> Check if the handle is associated to an dictionary
    PP_TRYCALL(ERRFLAG_MATCH_DICTIONARY) SHARED_PAR_DICT_MAP%HAS( F_MULTIO_GRIB2, MAP_HAS_DICTIONARY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. MAP_HAS_DICTIONARY, ERRFLAG_MATCH_DICTIONARY )

    !> Remove the dictionary from the map
    PP_TRYCALL(ERRFLAG_REMOVE_DICTIONARY) SHARED_PAR_DICT_MAP%REMOVE( F_MULTIO_GRIB2, DICTIONARY_REMOVED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. DICTIONARY_REMOVED, ERRFLAG_REMOVE_DICTIONARY )

    !> Print the dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_PAR_DICT_MAP%LIST( 6_JPIB_K, 'PARAMETRIZATION_DICTIONARY_MAP: ', HOOKS )

    !> Get the map size
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_PAR_DICT_MAP%SIZE( MAP_SIZE, HOOKS )

    !> To avoid the need of init/exit API, every time the map is empty we deallocate the map
    IF ( MAP_SIZE .EQ. 0_JPIB_K ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE_MAP) SHARED_PAR_DICT_MAP%FREE( HOOKS )
    ENDIF
!$omp end critical(API_DICTIONARY_MAP_REMOVE)


  CASE ( REDUCED_GG_DICT_TYPE_E )


!$omp critical(API_DICTIONARY_MAP_REMOVE)

    !> Print the parametrization dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_REDUCED_GG_DICT_MAP%LIST( 6_JPIB_K, 'PARAMETRIZATION_DICTIONARY_MAP: ', HOOKS )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_MAP_NOT_INITIALIZED) SHARED_REDUCED_GG_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. INITIALIZED, ERRFLAG_MAP_NOT_INITIALIZED )

    !> Check if the handle is associated to an dictionary
    PP_TRYCALL(ERRFLAG_MATCH_DICTIONARY) SHARED_REDUCED_GG_DICT_MAP%HAS( F_MULTIO_GRIB2, MAP_HAS_DICTIONARY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. MAP_HAS_DICTIONARY, ERRFLAG_MATCH_DICTIONARY )

    !> Remove the dictionary from the map
    PP_TRYCALL(ERRFLAG_REMOVE_DICTIONARY) SHARED_REDUCED_GG_DICT_MAP%REMOVE( F_MULTIO_GRIB2, DICTIONARY_REMOVED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. DICTIONARY_REMOVED, ERRFLAG_REMOVE_DICTIONARY )

    !> Print the dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_REDUCED_GG_DICT_MAP%LIST( 6_JPIB_K, 'PARAMETRIZATION_DICTIONARY_MAP: ', HOOKS )

    !> Get the map size
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_REDUCED_GG_DICT_MAP%SIZE( MAP_SIZE, HOOKS )

    !> To avoid the need of init/exit API, every time the map is empty we deallocate the map
    IF ( MAP_SIZE .EQ. 0_JPIB_K ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE_MAP) SHARED_REDUCED_GG_DICT_MAP%FREE( HOOKS )
    ENDIF
!$omp end critical(API_DICTIONARY_MAP_REMOVE)


  CASE ( SH_DICT_TYPE_E )


!$omp critical(API_DICTIONARY_MAP_REMOVE)

    !> Print the parametrization dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_SH_DICT_MAP%LIST( 6_JPIB_K, 'PARAMETRIZATION_DICTIONARY_MAP: ', HOOKS )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_MAP_NOT_INITIALIZED) SHARED_SH_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. INITIALIZED, ERRFLAG_MAP_NOT_INITIALIZED )

    !> Check if the handle is associated to an dictionary
    PP_TRYCALL(ERRFLAG_MATCH_DICTIONARY) SHARED_SH_DICT_MAP%HAS( F_MULTIO_GRIB2, MAP_HAS_DICTIONARY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. MAP_HAS_DICTIONARY, ERRFLAG_MATCH_DICTIONARY )

    !> Remove the dictionary from the map
    PP_TRYCALL(ERRFLAG_REMOVE_DICTIONARY) SHARED_SH_DICT_MAP%REMOVE( F_MULTIO_GRIB2, DICTIONARY_REMOVED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. DICTIONARY_REMOVED, ERRFLAG_REMOVE_DICTIONARY )

    !> Print the dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_SH_DICT_MAP%LIST( 6_JPIB_K, 'PARAMETRIZATION_DICTIONARY_MAP: ', HOOKS )

    !> Get the map size
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_SH_DICT_MAP%SIZE( MAP_SIZE, HOOKS )

    !> To avoid the need of init/exit API, every time the map is empty we deallocate the map
    IF ( MAP_SIZE .EQ. 0_JPIB_K ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE_MAP) SHARED_SH_DICT_MAP%FREE( HOOKS )
    ENDIF
!$omp end critical(API_DICTIONARY_MAP_REMOVE)


  CASE ( OPT_DICT_TYPE_E )


!$omp critical(API_DICTIONARY_MAP_REMOVE)

    !> Print the parametrization dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_OPT_DICT_MAP%LIST( 6_JPIB_K, 'PARAMETRIZATION_DICTIONARY_MAP: ', HOOKS )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_MAP_NOT_INITIALIZED) SHARED_OPT_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. INITIALIZED, ERRFLAG_MAP_NOT_INITIALIZED )

    !> Check if the handle is associated to an dictionary
    PP_TRYCALL(ERRFLAG_MATCH_DICTIONARY) SHARED_OPT_DICT_MAP%HAS( F_MULTIO_GRIB2, MAP_HAS_DICTIONARY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. MAP_HAS_DICTIONARY, ERRFLAG_MATCH_DICTIONARY )

    !> Remove the dictionary from the map
    PP_TRYCALL(ERRFLAG_REMOVE_DICTIONARY) SHARED_OPT_DICT_MAP%REMOVE( F_MULTIO_GRIB2, DICTIONARY_REMOVED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. DICTIONARY_REMOVED, ERRFLAG_REMOVE_DICTIONARY )

    !> Print the dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_OPT_DICT_MAP%LIST( 6_JPIB_K, 'PARAMETRIZATION_DICTIONARY_MAP: ', HOOKS )

    !> Get the map size
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_OPT_DICT_MAP%SIZE( MAP_SIZE, HOOKS )

    !> To avoid the need of init/exit API, every time the map is empty we deallocate the map
    IF ( MAP_SIZE .EQ. 0_JPIB_K ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE_MAP) SHARED_OPT_DICT_MAP%FREE( HOOKS )
    ENDIF
!$omp end critical(API_DICTIONARY_MAP_REMOVE)

  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )
  END SELECT

  ! Reset the input pointer
  TMP(1) = C_NULL_PTR

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_MAP_NOT_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Map not initialized' )
    CASE (ERRFLAG_MATCH_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to match the dictionary' )
    CASE (ERRFLAG_REMOVE_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to remove the dictionary' )
    ! CASE (ERRFLAG_MAP_LIST)
    !   PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to list the map' )
    CASE (ERRFLAG_UNABLE_TO_FREE_MAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free the map' )
    CASE (ERRFLAG_UNABLE_TO_GET_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get the size of the map' )
    CASE (ERRFLAG_WRONG_HANDLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong handle (handle is not from an dictionary)' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_DESTROY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_SET'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_SET( DICT, KEY, KLEN, VALUE, VLEN ) &
 BIND(C,NAME='multio_grib2_dict_set_f') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,                   ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,                   ONLY: JPRD_K
  USE :: HOOKS_MOD,                           ONLY: HOOKS_T
  USE :: API_SHARED_DATA_MOD,                 ONLY: EXTRACT_OPTIONS_DICTIONARY
  USE :: API_SHARED_DATA_MOD,                 ONLY: EXTRACT_MARS_DICTIONARY
  USE :: API_SHARED_DATA_MOD,                 ONLY: EXTRACT_PAR_DICTIONARY
  USE :: API_SHARED_DATA_MOD,                 ONLY: EXTRACT_REDUCED_GG_DICTIONARY
  USE :: API_SHARED_DATA_MOD,                 ONLY: EXTRACT_SH_DICTIONARY
  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD,    ONLY: API_OPTIONS_T
  USE :: FORTRAN_MESSAGE_MOD,                 ONLY: FORTRAN_MESSAGE_T
  USE :: PARAMETRIZATION_MOD,                 ONLY: PARAMETRIZATION_T
  USE :: REPRESENTATIONS_MOD,                 ONLY: REDUCED_GG_T
  USE :: REPRESENTATIONS_MOD,                 ONLY: SH_T
  USE :: API_SHARED_DATA_MOD,                 ONLY: OPT_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,                 ONLY: MARS_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,                 ONLY: PAR_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,                 ONLY: REDUCED_GG_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,                 ONLY: SH_DICT_TYPE_E
  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD,    ONLY: OPTIONS_DICTIONARY_NAME2ITERATOR
  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD,    ONLY: OPTIONS_DICTIONARY_SET_VALUE_FROM_STRING
  USE :: API_MARS_DICTIONARY_UTILS_MOD,       ONLY: MARS_DICTIONARY_NAME2ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD,       ONLY: MARS_DICTIONARY_SET_VALUE_FROM_STRING
  USE :: API_PAR_DICTIONARY_UTILS_MOD,        ONLY: PAR_DICTIONARY_NAME2ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD,        ONLY: PAR_DICTIONARY_SET_VALUE_FROM_STRING
  USE :: API_SH_DICTIONARY_UTILS_MOD,         ONLY: SH_DICTIONARY_NAME2ITERATOR
  USE :: API_SH_DICTIONARY_UTILS_MOD,         ONLY: SH_DICTIONARY_SET_VALUE_FROM_STRING
  USE :: API_REDUCED_GG_DICTIONARY_UTILS_MOD, ONLY: REDUCED_GG_DICTIONARY_NAME2ITERATOR
  USE :: API_REDUCED_GG_DICTIONARY_UTILS_MOD, ONLY: REDUCED_GG_DICTIONARY_SET_VALUE_FROM_STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR),         VALUE, INTENT(IN) :: DICT
  TYPE(C_PTR),         VALUE, INTENT(IN) :: KEY
  INTEGER(KIND=C_INT), VALUE, INTENT(IN) :: KLEN
  TYPE(C_PTR),         VALUE, INTENT(IN) :: VALUE
  INTEGER(KIND=C_INT), VALUE, INTENT(IN) :: VLEN

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_DICT
  TYPE(FORTRAN_MESSAGE_T), POINTER :: MARS_DICT
  TYPE(PARAMETRIZATION_T), POINTER :: PAR_DICT
  TYPE(REDUCED_GG_T), POINTER :: REDUCED_GG_DICT
  TYPE(SH_T), POINTER :: SH_DICT
  TYPE(API_OPTIONS_T), POINTER :: OPT_DICT
  CHARACTER(LEN=1,KIND=C_CHAR), DIMENSION(:), POINTER :: C_TMP_KEY
  CHARACTER(LEN=1,KIND=C_CHAR), DIMENSION(:), POINTER :: C_TMP_VAL
  CHARACTER(LEN=KLEN) :: F_KEY
  CHARACTER(LEN=VLEN) :: F_VAL
  INTEGER(KIND=JPIB_K) :: ITERATOR
  INTEGER(KIND=JPIB_K) :: I
  TYPE(HOOKS_T) :: HOOKS

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_KEY_NOT_ASSOCIATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUE_NOT_ASSOCIATED=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_DICTIONARY=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_SET_VAL=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE=7_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(KEY),  ERRFLAG_KEY_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(VALUE), ERRFLAG_VALUE_NOT_ASSOCIATED )

  !> Get the size of the dictionary type
  CALL C_F_POINTER( KEY,   C_TMP_KEY, [KLEN] )
  CALL C_F_POINTER( VALUE, C_TMP_VAL, [VLEN] )

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(C_TMP_KEY), ERRFLAG_KEY_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(C_TMP_VAL), ERRFLAG_VALUE_NOT_ASSOCIATED )

  ! Copy the key to a fortran string
  F_KEY = REPEAT(' ', KLEN)
  DO I = 1, KLEN
    F_KEY(I:I) = C_TMP_KEY(I)
  ENDDO
  C_TMP_KEY => NULL()

  ! Copy the key to a fortran string
  F_VAL = REPEAT(' ', VLEN)
  DO I = 1, VLEN
    F_VAL(I:I) = C_TMP_VAL(I)
  ENDDO
  C_TMP_VAL => NULL()

  !> Get th fortran handle from the c handle
  F_DICT => NULL()
  CALL C_F_POINTER( DICT, F_DICT, [2] )

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_DICT(1) )

  CASE ( MARS_DICT_TYPE_E )

    !> Check the allocation status of the fortran handle
    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_MARS_DICTIONARY( F_DICT, MARS_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) MARS_DICTIONARY_NAME2ITERATOR( MARS_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_VAL) MARS_DICTIONARY_SET_VALUE_FROM_STRING( MARS_DICT, ITERATOR, F_VAL, HOOKS )

  CASE ( PAR_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_PAR_DICTIONARY( F_DICT, PAR_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) PAR_DICTIONARY_NAME2ITERATOR( PAR_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_VAL) PAR_DICTIONARY_SET_VALUE_FROM_STRING( PAR_DICT, ITERATOR, F_VAL, HOOKS )

  CASE ( REDUCED_GG_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_REDUCED_GG_DICTIONARY( F_DICT, REDUCED_GG_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) REDUCED_GG_DICTIONARY_NAME2ITERATOR( REDUCED_GG_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_VAL) REDUCED_GG_DICTIONARY_SET_VALUE_FROM_STRING( REDUCED_GG_DICT, ITERATOR, F_VAL, HOOKS )


  CASE ( SH_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_SH_DICTIONARY( F_DICT, SH_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) SH_DICTIONARY_NAME2ITERATOR( SH_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_VAL) SH_DICTIONARY_SET_VALUE_FROM_STRING( SH_DICT, ITERATOR, F_VAL, HOOKS )

  CASE ( OPT_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_OPTIONS_DICTIONARY( F_DICT, OPT_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) OPTIONS_DICTIONARY_NAME2ITERATOR( OPT_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_VAL) OPTIONS_DICTIONARY_SET_VALUE_FROM_STRING( OPT_DICT, ITERATOR, F_VAL, HOOKS )

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )

  END SELECT

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_KEY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Key not associated' )
    CASE (ERRFLAG_VALUE_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Value not associated' )
    CASE (ERRFLAG_EXTRACT_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the dictionary' )
    CASE (ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert the key to an iterator' )
    CASE (ERRFLAG_UNABLE_TO_SET_VAL)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to set the value' )
    CASE (ERRFLAG_WRONG_HANDLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong handle (handle is not from an dictionary)' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_SET
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_SET_GEOMETRY'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_SET_GEOMETRY( DICT, SUBDICT ) &
 BIND(C,NAME='multio_grib2_dict_set_geometry') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPRD_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T

  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_PAR_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_REDUCED_GG_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_SH_DICTIONARY

  USE :: PARAMETRIZATION_MOD, ONLY: PARAMETRIZATION_T
  USE :: REPRESENTATIONS_MOD, ONLY: REPRES_A
  USE :: REPRESENTATIONS_MOD, ONLY: REDUCED_GG_T
  USE :: REPRESENTATIONS_MOD, ONLY: SH_T

  USE :: API_SHARED_DATA_MOD, ONLY: PAR_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: REDUCED_GG_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: SH_DICT_TYPE_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE, INTENT(IN) :: DICT
  TYPE(C_PTR), VALUE, INTENT(IN) :: SUBDICT

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_DICT
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_SUBDICT
  TYPE(PARAMETRIZATION_T), POINTER :: PAR_DICT
  TYPE(REDUCED_GG_T), POINTER :: REDUCED_GG_DICT
  TYPE(SH_T), POINTER :: SH_DICT
  CLASS(REPRES_A), POINTER :: REPRES
  TYPE(HOOKS_T) :: HOOKS

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_DICTIONARY=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  !> Get the fortran handle from the c handle
  F_DICT => NULL()
  CALL C_F_POINTER( DICT, F_DICT, [2] )

  !> Check the association status of the fortran handle
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_DICT(1) )

  CASE ( PAR_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_PAR_DICTIONARY( F_DICT, PAR_DICT, HOOKS )

    !> Get th fortran handle from the c handle
    F_SUBDICT => NULL()
    CALL C_F_POINTER( SUBDICT, F_SUBDICT, [2] )

    SELECT CASE (  F_SUBDICT(1) )

    CASE ( REDUCED_GG_DICT_TYPE_E )
      PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_REDUCED_GG_DICTIONARY( F_SUBDICT, REDUCED_GG_DICT, HOOKS )
      REPRES => REDUCED_GG_DICT

    CASE ( SH_DICT_TYPE_E )
      PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_SH_DICTIONARY( F_SUBDICT, SH_DICT, HOOKS )
      REPRES => SH_DICT

    CASE DEFAULT

      PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )

    END SELECT

    !> Associate the subdictionary with the parametrization dictionary
    PAR_DICT%GEOMETRY%REPRES => REPRES

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )

  END SELECT

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_WRONG_HANDLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong handle (handle is not from an dictionary)' )
    CASE (ERRFLAG_EXTRACT_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the dictionary' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_SET_GEOMETRY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_GET'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_GET( DICT, KEY, KLEN, VALUE ) &
 BIND(C,NAME='multio_grib2_dict_get_f') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LOC
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPRD_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T

  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_OPTIONS_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_MARS_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_PAR_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_REDUCED_GG_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_SH_DICTIONARY

  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: API_OPTIONS_T
  USE :: FORTRAN_MESSAGE_MOD, ONLY: FORTRAN_MESSAGE_T
  USE :: PARAMETRIZATION_MOD, ONLY: PARAMETRIZATION_T
  USE :: REPRESENTATIONS_MOD, ONLY: REDUCED_GG_T
  USE :: REPRESENTATIONS_MOD, ONLY: SH_T

  USE :: API_SHARED_DATA_MOD, ONLY: OPT_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: MARS_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: PAR_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: REDUCED_GG_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: SH_DICT_TYPE_E

  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: OPTIONS_DICTIONARY_NAME2ITERATOR
  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: OPTIONS_DICTIONARY_GET_VALUE_AS_STRING
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_NAME2ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_GET_VALUE_AS_STRING
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_NAME2ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_GET_VALUE_AS_STRING
  USE :: API_REDUCED_GG_DICTIONARY_UTILS_MOD, ONLY: REDUCED_GG_DICTIONARY_NAME2ITERATOR
  USE :: API_REDUCED_GG_DICTIONARY_UTILS_MOD, ONLY: REDUCED_GG_DICTIONARY_GET_VALUE_AS_STRING
  USE :: API_SH_DICTIONARY_UTILS_MOD, ONLY: SH_DICTIONARY_NAME2ITERATOR
  USE :: API_SH_DICTIONARY_UTILS_MOD, ONLY: SH_DICTIONARY_GET_VALUE_AS_STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: DICT
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: KEY
  INTEGER(KIND=C_INT), VALUE, INTENT(IN)    :: KLEN
  TYPE(C_PTR),                INTENT(INOUT) :: VALUE

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  LOGICAL :: LHAS
  INTEGER(KIND=JPIB_K) :: ITERATOR
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_DICT
  TYPE(FORTRAN_MESSAGE_T), POINTER :: MARS_DICT
  TYPE(PARAMETRIZATION_T), POINTER :: PAR_DICT
  TYPE(REDUCED_GG_T), POINTER :: REDUCED_GG_DICT
  TYPE(SH_T), POINTER :: SH_DICT
  TYPE(API_OPTIONS_T), POINTER :: OPT_DICT
  CHARACTER(LEN=1,KIND=C_CHAR), DIMENSION(:), POINTER :: C_TMP_KEY
  CHARACTER(LEN=KLEN) :: F_KEY
  TYPE(HOOKS_T) :: HOOKS

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_KEY_NOT_ASSOCIATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_DICTIONARY=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_VALUE=6_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(KEY),  ERRFLAG_KEY_NOT_ASSOCIATED )

  !> Get the size of the dictionary type
  CALL C_F_POINTER( KEY,   C_TMP_KEY, [KLEN] )

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(C_TMP_KEY), ERRFLAG_KEY_NOT_ASSOCIATED )

  ! Copy the key to a fortran string
  F_KEY = REPEAT(' ', KLEN)
  DO I = 1, KLEN
    F_KEY(I:I) = C_TMP_KEY(I)
  ENDDO
  C_TMP_KEY => NULL()

  !> Get th fortran handle from the c handle
  F_DICT => NULL()
  CALL C_F_POINTER( DICT, F_DICT, [2] )

  !> Check the allocation status of the fortran handle
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_DICT(1) )

  CASE ( MARS_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_MARS_DICTIONARY( F_DICT, MARS_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) MARS_DICTIONARY_NAME2ITERATOR( MARS_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_VALUE) MARS_DICTIONARY_GET_VALUE_AS_STRING( MARS_DICT, ITERATOR, VALUE, LHAS, HOOKS )

  CASE ( PAR_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_PAR_DICTIONARY( F_DICT, PAR_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) PAR_DICTIONARY_NAME2ITERATOR( PAR_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_VALUE) PAR_DICTIONARY_GET_VALUE_AS_STRING( PAR_DICT, ITERATOR, VALUE, LHAS, HOOKS )

  CASE ( REDUCED_GG_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_REDUCED_GG_DICTIONARY( F_DICT, REDUCED_GG_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) REDUCED_GG_DICTIONARY_NAME2ITERATOR( REDUCED_GG_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_VALUE) REDUCED_GG_DICTIONARY_GET_VALUE_AS_STRING( REDUCED_GG_DICT, ITERATOR, VALUE, LHAS, HOOKS )


  CASE ( SH_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_SH_DICTIONARY( F_DICT, SH_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) SH_DICTIONARY_NAME2ITERATOR( SH_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_VALUE) SH_DICTIONARY_GET_VALUE_AS_STRING( SH_DICT, ITERATOR, VALUE, LHAS, HOOKS )


  CASE ( OPT_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_OPTIONS_DICTIONARY( F_DICT, OPT_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) OPTIONS_DICTIONARY_NAME2ITERATOR( OPT_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_VALUE) OPTIONS_DICTIONARY_GET_VALUE_AS_STRING( OPT_DICT, ITERATOR, VALUE, LHAS, HOOKS )

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )

  END SELECT



  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_KEY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Key not associated' )
    CASE (ERRFLAG_WRONG_HANDLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong handle (handle is not from an dictionary)' )
    CASE (ERRFLAG_EXTRACT_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the dictionary' )
    CASE (ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert the key to an iterator' )
    CASE (ERRFLAG_UNABLE_TO_GET_VALUE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get the value' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_GET
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_HAS'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_HAS( DICT, KEY, KLEN, HAS ) &
 BIND(C,NAME='multio_grib2_dict_has_f') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T

  USE :: API_SHARED_DATA_MOD, ONLY: OPT_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: MARS_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: PAR_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: REDUCED_GG_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: SH_DICT_TYPE_E

  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_OPTIONS_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_MARS_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_PAR_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_REDUCED_GG_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_SH_DICTIONARY

  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: API_OPTIONS_T
  USE :: FORTRAN_MESSAGE_MOD, ONLY: FORTRAN_MESSAGE_T
  USE :: PARAMETRIZATION_MOD, ONLY: PARAMETRIZATION_T
  USE :: REPRESENTATIONS_MOD, ONLY: REDUCED_GG_T
  USE :: REPRESENTATIONS_MOD, ONLY: SH_T

  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: OPTIONS_DICTIONARY_NAME2ITERATOR
  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: OPTIONS_DICTIONARY_HAS
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_NAME2ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_HAS
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_NAME2ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_HAS
  USE :: API_REDUCED_GG_DICTIONARY_UTILS_MOD, ONLY: REDUCED_GG_DICTIONARY_NAME2ITERATOR
  USE :: API_REDUCED_GG_DICTIONARY_UTILS_MOD, ONLY: REDUCED_GG_DICTIONARY_HAS
  USE :: API_SH_DICTIONARY_UTILS_MOD, ONLY: SH_DICTIONARY_NAME2ITERATOR
  USE :: API_SH_DICTIONARY_UTILS_MOD, ONLY: SH_DICTIONARY_HAS

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: DICT
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: KEY
  INTEGER(KIND=C_INT), VALUE, INTENT(IN)    :: KLEN
  INTEGER(KIND=C_INT),        INTENT(INOUT) :: HAS

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  LOGICAL :: LHAS
  INTEGER(KIND=JPIB_K) :: ITERATOR
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_DICT
  TYPE(FORTRAN_MESSAGE_T), POINTER :: MARS_DICT
  TYPE(PARAMETRIZATION_T), POINTER :: PAR_DICT
  TYPE(REDUCED_GG_T), POINTER :: REDUCED_GG_DICT
  TYPE(SH_T), POINTER :: SH_DICT
  TYPE(API_OPTIONS_T), POINTER :: OPT_DICT
  CHARACTER(LEN=1,KIND=C_CHAR), DIMENSION(:), POINTER :: C_TMP_KEY
  CHARACTER(LEN=KLEN) :: F_KEY
  TYPE(HOOKS_T) :: HOOKS

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_KEY_NOT_ASSOCIATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_DICTIONARY=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CHECK_STATUS=8_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(KEY),  ERRFLAG_KEY_NOT_ASSOCIATED )

  !> Get the size of the dictionary type
  CALL C_F_POINTER( KEY, C_TMP_KEY, [KLEN] )

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(C_TMP_KEY), ERRFLAG_KEY_NOT_ASSOCIATED )

  ! Copy the key to a fortran string
  F_KEY = REPEAT(' ', KLEN)
  DO I = 1, KLEN
    F_KEY(I:I) = C_TMP_KEY(I)
  ENDDO
  C_TMP_KEY => NULL()

  !> Get th fortran handle from the c handle
  F_DICT => NULL()
  CALL C_F_POINTER( DICT, F_DICT, [2] )

  !> Check the allocation status of the fortran handle
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_DICT), ERRFLAG_KEY_NOT_ASSOCIATED )

  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_DICT(1) )

  CASE ( MARS_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_MARS_DICTIONARY( F_DICT, MARS_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) MARS_DICTIONARY_NAME2ITERATOR( MARS_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_STATUS) MARS_DICTIONARY_HAS( MARS_DICT, ITERATOR, LHAS, HOOKS )

    IF ( LHAS ) THEN
      HAS = 1_C_INT
    ELSE
      HAS = 0_C_INT
    END IF

  CASE ( PAR_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_PAR_DICTIONARY( F_DICT, PAR_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) PAR_DICTIONARY_NAME2ITERATOR( PAR_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_STATUS) PAR_DICTIONARY_HAS( PAR_DICT, ITERATOR, LHAS, HOOKS )

    IF ( LHAS ) THEN
      HAS = 1_C_INT
    ELSE
      HAS = 0_C_INT
    END IF


  CASE ( REDUCED_GG_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_REDUCED_GG_DICTIONARY( F_DICT, REDUCED_GG_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) REDUCED_GG_DICTIONARY_NAME2ITERATOR( REDUCED_GG_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_STATUS) REDUCED_GG_DICTIONARY_HAS( REDUCED_GG_DICT, ITERATOR, LHAS, HOOKS )

    IF ( LHAS ) THEN
      HAS = 1_C_INT
    ELSE
      HAS = 0_C_INT
    END IF

  CASE ( SH_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_SH_DICTIONARY( F_DICT, SH_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) SH_DICTIONARY_NAME2ITERATOR( SH_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_STATUS) SH_DICTIONARY_HAS( SH_DICT, ITERATOR, LHAS, HOOKS )

    IF ( LHAS ) THEN
      HAS = 1_C_INT
    ELSE
      HAS = 0_C_INT
    END IF

  CASE ( OPT_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_OPTIONS_DICTIONARY( F_DICT, OPT_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) OPTIONS_DICTIONARY_NAME2ITERATOR( OPT_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_STATUS) OPTIONS_DICTIONARY_HAS( OPT_DICT, ITERATOR, LHAS, HOOKS )

    IF ( LHAS ) THEN
      HAS = 1_C_INT
    ELSE
      HAS = 0_C_INT
    END IF

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )

  END SELECT

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_KEY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Key not associated' )
    CASE (ERRFLAG_WRONG_HANDLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong handle (handle is not from an dictionary)' )
    CASE (ERRFLAG_EXTRACT_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the mars dictionary' )
    CASE (ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert key to iterator' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key: ' // F_KEY )
    CASE (ERRFLAG_UNABLE_TO_CHECK_STATUS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check status' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_HAS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_ITERATE'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_ITERATE( DICT, IT, KEY, VALUE ) &
 BIND(C,NAME='multio_grib2_dict_iterate') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LOC
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_OPTIONS_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_MARS_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_PAR_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_REDUCED_GG_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_SH_DICTIONARY

  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: API_OPTIONS_T
  USE :: FORTRAN_MESSAGE_MOD, ONLY: FORTRAN_MESSAGE_T
  USE :: PARAMETRIZATION_MOD, ONLY: PARAMETRIZATION_T
  USE :: REPRESENTATIONS_MOD, ONLY: REDUCED_GG_T
  USE :: REPRESENTATIONS_MOD, ONLY: SH_T
  USE :: GENERAL_UTILS_MOD,   ONLY: TOLOWER
  USE :: API_GENERAL_UTILS_MOD,   ONLY: CONVERT_TO_C_STRING
  USE :: API_GENERAL_UTILS_MOD,   ONLY: ALLOCATE_ITERATOR
  USE :: API_GENERAL_UTILS_MOD,   ONLY: DEALLOCATE_ITERATOR

  USE :: API_SHARED_DATA_MOD,                 ONLY: OPT_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: MARS_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: PAR_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: REDUCED_GG_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD, ONLY: SH_DICT_TYPE_E

  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: OPTIONS_DICTIONARY_MAX_ITERATOR
  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: OPTIONS_DICTIONARY_INIT_ITERATOR
  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: OPTIONS_DICTIONARY_GET_NEXT_ITERATOR
  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: OPTIONS_DICTIONARY_GET_KEY_AS_STRING
  USE :: API_OPTIONS_DICTIONARY_UTILS_MOD, ONLY: OPTIONS_DICTIONARY_GET_VALUE_AS_STRING

  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_MAX_ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_INIT_ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_GET_NEXT_ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_GET_KEY_AS_STRING
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_GET_VALUE_AS_STRING

  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_MAX_ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_INIT_ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_GET_NEXT_ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_GET_KEY_AS_STRING
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_GET_VALUE_AS_STRING

  USE :: API_REDUCED_GG_DICTIONARY_UTILS_MOD, ONLY: REDUCED_GG_DICTIONARY_MAX_ITERATOR
  USE :: API_REDUCED_GG_DICTIONARY_UTILS_MOD, ONLY: REDUCED_GG_DICTIONARY_INIT_ITERATOR
  USE :: API_REDUCED_GG_DICTIONARY_UTILS_MOD, ONLY: REDUCED_GG_DICTIONARY_GET_NEXT_ITERATOR
  USE :: API_REDUCED_GG_DICTIONARY_UTILS_MOD, ONLY: REDUCED_GG_DICTIONARY_GET_KEY_AS_STRING
  USE :: API_REDUCED_GG_DICTIONARY_UTILS_MOD, ONLY: REDUCED_GG_DICTIONARY_GET_VALUE_AS_STRING


  USE :: API_SH_DICTIONARY_UTILS_MOD, ONLY: SH_DICTIONARY_MAX_ITERATOR
  USE :: API_SH_DICTIONARY_UTILS_MOD, ONLY: SH_DICTIONARY_INIT_ITERATOR
  USE :: API_SH_DICTIONARY_UTILS_MOD, ONLY: SH_DICTIONARY_GET_NEXT_ITERATOR
  USE :: API_SH_DICTIONARY_UTILS_MOD, ONLY: SH_DICTIONARY_GET_KEY_AS_STRING
  USE :: API_SH_DICTIONARY_UTILS_MOD, ONLY: SH_DICTIONARY_GET_VALUE_AS_STRING


  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE, INTENT(IN)    :: DICT
  TYPE(C_PTR),        INTENT(INOUT) :: IT
  TYPE(C_PTR),        INTENT(INOUT) :: KEY
  TYPE(C_PTR),        INTENT(INOUT) :: VALUE

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_DICT
  TYPE(FORTRAN_MESSAGE_T), POINTER :: MARS_DICT
  TYPE(PARAMETRIZATION_T), POINTER :: PAR_DICT
  TYPE(REDUCED_GG_T), POINTER :: REDUCED_GG_DICT
  TYPE(SH_T), POINTER :: SH_DICT
  TYPE(API_OPTIONS_T), POINTER :: OPT_DICT
  INTEGER(KIND=C_INT), POINTER, DIMENSION(:) :: F_ITERATOR
  INTEGER(KIND=JPIB_K) :: OPTIONS_ITERATOR_SIZE
  INTEGER(KIND=JPIB_K) :: MARS_ITERATOR_SIZE
  INTEGER(KIND=JPIB_K) :: PAR_ITERATOR_SIZE
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: ITERATOR
  CHARACTER(LEN=64) :: F_KEY
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  LOGICAL :: END_OF_ITERATORS
  LOGICAL :: HAS
  TYPE(HOOKS_T) :: HOOKS

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOC_FAILURE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_MARS_DICTIONARY=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_PAR_DICTIONARY=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_NEXT_IT=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_MARS_KEY=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_MARS_VAL=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONVERT_TO_C_STRING=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_STR=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_MAX_ITERATOR=12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZE_ITERATOR=13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_MARS=14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_PAR=16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_PAR_KEY=17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_PAR_VAL=18_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! WRITE(*,*) ' + ENTER ITERATE'

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  !> Get th fortran handle from the c handle
  F_DICT => NULL()
  CALL C_F_POINTER( DICT, F_DICT, [2] )

  !> Check the allocation status of the fortran handle
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  F_KEY=REPEAT(' ', LEN(F_KEY))


  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_DICT(1) )

  CASE ( MARS_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_MARS_DICTIONARY) EXTRACT_MARS_DICTIONARY( F_DICT, MARS_DICT, HOOKS )

    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAX_ITERATOR) MARS_DICTIONARY_MAX_ITERATOR( MARS_DICT, MARS_ITERATOR_SIZE, HOOKS )
    IF ( .NOT.C_ASSOCIATED(IT) ) THEN
      F_ITERATOR => NULL()
      PP_TRYCALL(ERRFLAG_ALLOC_FAILURE) ALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      ITERATOR = F_ITERATOR(1)
      PP_TRYCALL(ERRFLAG_INITIALIZE_ITERATOR) MARS_DICTIONARY_INIT_ITERATOR( MARS_DICT, ITERATOR, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
      IT = C_LOC(F_ITERATOR)
      END_OF_ITERATORS = .FALSE.
    ELSE
      CALL C_F_POINTER( IT, F_ITERATOR, [1] )
      ITERATOR = INT( F_ITERATOR(1), KIND=C_INT )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_NEXT_IT) MARS_DICTIONARY_GET_NEXT_ITERATOR( MARS_DICT, ITERATOR, END_OF_ITERATORS, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
    ENDIF


    ! If the iterator is out of bounds, the deallocate it
    IF ( END_OF_ITERATORS ) THEN
      F_ITERATOR(1) = 0_C_INT
      PP_TRYCALL(ERRFLAG_DEALLOC_STR) DEALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      IT    = C_NULL_PTR
      KEY   = C_NULL_PTR
      VALUE = C_NULL_PTR

    ELSE

      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MARS_KEY) MARS_DICTIONARY_GET_KEY_AS_STRING( MARS_DICT, ITERATOR, F_KEY, HOOKS )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MARS_VAL) MARS_DICTIONARY_GET_VALUE_AS_STRING( MARS_DICT, ITERATOR, VALUE, HAS, HOOKS )
      PP_TRYCALL(ERRFLAG_CONVERT_TO_C_STRING) CONVERT_TO_C_STRING( F_KEY, KEY, HOOKS )

    ENDIF

  CASE ( PAR_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_PAR_DICTIONARY) EXTRACT_PAR_DICTIONARY( F_DICT, PAR_DICT, HOOKS )

    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAX_ITERATOR) PAR_DICTIONARY_MAX_ITERATOR( PAR_DICT, PAR_ITERATOR_SIZE, HOOKS )
    IF ( .NOT.C_ASSOCIATED(IT) ) THEN
      F_ITERATOR => NULL()
      PP_TRYCALL(ERRFLAG_ALLOC_FAILURE) ALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      ITERATOR = F_ITERATOR(1)
      PP_TRYCALL(ERRFLAG_INITIALIZE_ITERATOR) PAR_DICTIONARY_INIT_ITERATOR( PAR_DICT, ITERATOR, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
      IT = C_LOC(F_ITERATOR)
      END_OF_ITERATORS = .FALSE.
    ELSE
      CALL C_F_POINTER( IT, F_ITERATOR, [1] )
      ITERATOR = INT( F_ITERATOR(1), KIND=C_INT )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_NEXT_IT) PAR_DICTIONARY_GET_NEXT_ITERATOR( PAR_DICT, ITERATOR, END_OF_ITERATORS, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
    ENDIF


    ! If the iterator is out of bounds, the deallocate it
    IF ( END_OF_ITERATORS ) THEN
      F_ITERATOR(1) = 0_C_INT
      PP_TRYCALL(ERRFLAG_DEALLOC_STR) DEALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      IT    = C_NULL_PTR
      KEY   = C_NULL_PTR
      VALUE = C_NULL_PTR

    ELSE

      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR_KEY) PAR_DICTIONARY_GET_KEY_AS_STRING( PAR_DICT, ITERATOR, F_KEY, HOOKS )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR_VAL) PAR_DICTIONARY_GET_VALUE_AS_STRING( PAR_DICT, ITERATOR, VALUE, HAS, HOOKS )
      PP_TRYCALL(ERRFLAG_CONVERT_TO_C_STRING) CONVERT_TO_C_STRING( F_KEY, KEY, HOOKS )

    ENDIF



  CASE ( REDUCED_GG_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_PAR_DICTIONARY) EXTRACT_REDUCED_GG_DICTIONARY( F_DICT, REDUCED_GG_DICT, HOOKS )

    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAX_ITERATOR) REDUCED_GG_DICTIONARY_MAX_ITERATOR( REDUCED_GG_DICT, PAR_ITERATOR_SIZE, HOOKS )
    IF ( .NOT.C_ASSOCIATED(IT) ) THEN
      F_ITERATOR => NULL()
      PP_TRYCALL(ERRFLAG_ALLOC_FAILURE) ALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      ITERATOR = F_ITERATOR(1)
      PP_TRYCALL(ERRFLAG_INITIALIZE_ITERATOR) REDUCED_GG_DICTIONARY_INIT_ITERATOR( REDUCED_GG_DICT, ITERATOR, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
      IT = C_LOC(F_ITERATOR)
      END_OF_ITERATORS = .FALSE.
    ELSE
      CALL C_F_POINTER( IT, F_ITERATOR, [1] )
      ITERATOR = INT( F_ITERATOR(1), KIND=C_INT )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_NEXT_IT) REDUCED_GG_DICTIONARY_GET_NEXT_ITERATOR( REDUCED_GG_DICT, ITERATOR, END_OF_ITERATORS, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
    ENDIF


    ! If the iterator is out of bounds, the deallocate it
    IF ( END_OF_ITERATORS ) THEN
      F_ITERATOR(1) = 0_C_INT
      PP_TRYCALL(ERRFLAG_DEALLOC_STR) DEALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      IT    = C_NULL_PTR
      KEY   = C_NULL_PTR
      VALUE = C_NULL_PTR

    ELSE

      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR_KEY) REDUCED_GG_DICTIONARY_GET_KEY_AS_STRING( REDUCED_GG_DICT, ITERATOR, F_KEY, HOOKS )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR_VAL) REDUCED_GG_DICTIONARY_GET_VALUE_AS_STRING( REDUCED_GG_DICT, ITERATOR, VALUE, HAS, HOOKS )
      PP_TRYCALL(ERRFLAG_CONVERT_TO_C_STRING) CONVERT_TO_C_STRING( F_KEY, KEY, HOOKS )

    ENDIF

  CASE ( SH_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_PAR_DICTIONARY) EXTRACT_SH_DICTIONARY( F_DICT, SH_DICT, HOOKS )

    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAX_ITERATOR) SH_DICTIONARY_MAX_ITERATOR( SH_DICT, PAR_ITERATOR_SIZE, HOOKS )
    IF ( .NOT.C_ASSOCIATED(IT) ) THEN
      F_ITERATOR => NULL()
      PP_TRYCALL(ERRFLAG_ALLOC_FAILURE) ALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      ITERATOR = F_ITERATOR(1)
      PP_TRYCALL(ERRFLAG_INITIALIZE_ITERATOR) SH_DICTIONARY_INIT_ITERATOR( SH_DICT, ITERATOR, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
      IT = C_LOC(F_ITERATOR)
      END_OF_ITERATORS = .FALSE.
    ELSE
      CALL C_F_POINTER( IT, F_ITERATOR, [1] )
      ITERATOR = INT( F_ITERATOR(1), KIND=C_INT )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_NEXT_IT) SH_DICTIONARY_GET_NEXT_ITERATOR( SH_DICT, ITERATOR, END_OF_ITERATORS, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
    ENDIF


    ! If the iterator is out of bounds, the deallocate it
    IF ( END_OF_ITERATORS ) THEN
      F_ITERATOR(1) = 0_C_INT
      PP_TRYCALL(ERRFLAG_DEALLOC_STR) DEALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      IT    = C_NULL_PTR
      KEY   = C_NULL_PTR
      VALUE = C_NULL_PTR

    ELSE

      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR_KEY) SH_DICTIONARY_GET_KEY_AS_STRING( SH_DICT, ITERATOR, F_KEY, HOOKS )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR_VAL) SH_DICTIONARY_GET_VALUE_AS_STRING( SH_DICT, ITERATOR, VALUE, HAS, HOOKS )
      PP_TRYCALL(ERRFLAG_CONVERT_TO_C_STRING) CONVERT_TO_C_STRING( F_KEY, KEY, HOOKS )

    ENDIF

  CASE ( OPT_DICT_TYPE_E )

    PP_TRYCALL(ERRFLAG_EXTRACT_PAR_DICTIONARY) EXTRACT_OPTIONS_DICTIONARY( F_DICT, OPT_DICT, HOOKS )

    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAX_ITERATOR) OPTIONS_DICTIONARY_MAX_ITERATOR( OPT_DICT, OPTIONS_ITERATOR_SIZE, HOOKS )
    IF ( .NOT.C_ASSOCIATED(IT) ) THEN
      F_ITERATOR => NULL()
      PP_TRYCALL(ERRFLAG_ALLOC_FAILURE) ALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      ITERATOR = F_ITERATOR(1)
      PP_TRYCALL(ERRFLAG_INITIALIZE_ITERATOR) OPTIONS_DICTIONARY_INIT_ITERATOR( OPT_DICT, ITERATOR, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
      IT = C_LOC(F_ITERATOR)
      END_OF_ITERATORS = .FALSE.
    ELSE
      CALL C_F_POINTER( IT, F_ITERATOR, [1] )
      ITERATOR = INT( F_ITERATOR(1), KIND=C_INT )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_NEXT_IT) OPTIONS_DICTIONARY_GET_NEXT_ITERATOR( OPT_DICT, ITERATOR, END_OF_ITERATORS, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
    ENDIF


    ! If the iterator is out of bounds, the deallocate it
    IF ( END_OF_ITERATORS ) THEN
      F_ITERATOR(1) = 0_C_INT
      PP_TRYCALL(ERRFLAG_DEALLOC_STR) DEALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      IT    = C_NULL_PTR
      KEY   = C_NULL_PTR
      VALUE = C_NULL_PTR

    ELSE

      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR_KEY) OPTIONS_DICTIONARY_GET_KEY_AS_STRING( OPT_DICT, ITERATOR, F_KEY, HOOKS )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR_VAL) OPTIONS_DICTIONARY_GET_VALUE_AS_STRING( OPT_DICT, ITERATOR, VALUE, HAS, HOOKS )
      PP_TRYCALL(ERRFLAG_CONVERT_TO_C_STRING) CONVERT_TO_C_STRING( F_KEY, KEY, HOOKS )

    ENDIF


  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )

  END SELECT

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_WRONG_HANDLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong handle (handle is not from an dictionary)' )
    CASE (ERRFLAG_EXTRACT_MARS_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the mars dictionary' )
    CASE (ERRFLAG_EXTRACT_PAR_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the parametrization dictionary' )
    CASE (ERRFLAG_UNABLE_TO_GET_NEXT_IT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get next iterator' )
    CASE (ERRFLAG_UNABLE_TO_GET_MARS_KEY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get mars key' )
    CASE (ERRFLAG_UNABLE_TO_GET_MARS_VAL)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get mars value' )
    CASE (ERRFLAG_CONVERT_TO_C_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Can not copy to cstring' )
    CASE (ERRFLAG_DEALLOC_STR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Can not deallocate string' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_ITERATE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_DESTROY_ITERATEOR'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_DESTROY_ITERATEOR( DICT, IT ) &
 BIND(C,NAME='multio_grib2_dict_destroy_iterator') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,     ONLY: JPIB_K
  USE :: HOOKS_MOD,             ONLY: HOOKS_T
  USE :: API_GENERAL_UTILS_MOD, ONLY: DEALLOCATE_ITERATOR


  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE, INTENT(IN)    :: DICT
  TYPE(C_PTR),        INTENT(INOUT) :: IT

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  INTEGER(KIND=C_INT), POINTER, DIMENSION(:) :: F_ITERATOR
  TYPE(HOOKS_T) :: HOOKS

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_ITERATOR=1_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  ! If needed free memory for the iterator
  IF ( C_ASSOCIATED(IT) ) THEN
    CALL C_F_POINTER( IT, F_ITERATOR, [1] )
    PP_TRYCALL(ERRFLAG_DEALLOC_ITERATOR) DEALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
    IT = C_NULL_PTR
  ENDIF

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DEALLOC_ITERATOR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to deallocate dictionary iterator' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_DESTROY_ITERATEOR
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_TO_YAML'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_TO_YAML( DICT, FNAME, LEN ) &
 BIND(C,NAME='multio_grib2_dict_to_yaml_f') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LOC
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: OUTPUT_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,             ONLY: JPIB_K
  USE :: HOOKS_MOD,                     ONLY: HOOKS_T
  USE :: MAP_INT64_MARS_DICT_MOD,       ONLY: MAP_FUNCTION_INT64_MARS_DICT_IF
  USE :: MAP_INT64_PAR_DICT_MOD,        ONLY: MAP_FUNCTION_INT64_PAR_DICT_IF
  USE :: MAP_INT64_REDUCED_GG_DICT_MOD, ONLY: MAP_FUNCTION_INT64_REDUCED_GG_DICT_IF
  USE :: MAP_INT64_SH_DICT_MOD,         ONLY: MAP_FUNCTION_INT64_SH_DICT_IF
  USE :: API_SHARED_DATA_MOD,           ONLY: MARS_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,           ONLY: PAR_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,           ONLY: REDUCED_GG_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,           ONLY: SH_DICT_TYPE_E
  USE :: API_SHARED_DATA_MOD,           ONLY: SHARED_MARS_DICT_MAP
  USE :: API_SHARED_DATA_MOD,           ONLY: SHARED_PAR_DICT_MAP
  USE :: API_SHARED_DATA_MOD,           ONLY: SHARED_REDUCED_GG_DICT_MAP
  USE :: API_SHARED_DATA_MOD,           ONLY: SHARED_SH_DICT_MAP
  USE :: API_SHARED_DATA_MOD,           ONLY: FREE_MARS_MESSAGE
  USE :: API_SHARED_DATA_MOD,           ONLY: FREE_PARAMETRIZATION
  USE :: API_SHARED_DATA_MOD,           ONLY: FREE_REDUCED_GG_DICT
  USE :: API_SHARED_DATA_MOD,           ONLY: FREE_SH_DICT
  USE :: API_SHARED_DATA_MOD,           ONLY: EXTRACT_MARS_DICTIONARY
  USE :: API_SHARED_DATA_MOD,           ONLY: EXTRACT_MARS_DICTIONARY
  USE :: API_SHARED_DATA_MOD,           ONLY: EXTRACT_PAR_DICTIONARY
  USE :: API_SHARED_DATA_MOD,           ONLY: EXTRACT_REDUCED_GG_DICTIONARY
  USE :: API_SHARED_DATA_MOD,           ONLY: EXTRACT_SH_DICTIONARY
  USE :: FORTRAN_MESSAGE_MOD,           ONLY: FORTRAN_MESSAGE_T
  USE :: PARAMETRIZATION_MOD,           ONLY: PARAMETRIZATION_T
  USE :: REPRESENTATIONS_MOD,           ONLY: REDUCED_GG_T
  USE :: REPRESENTATIONS_MOD,           ONLY: SH_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: DICT
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: FNAME
  INTEGER(KIND=C_INT), VALUE, INTENT(IN)    :: LEN

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  TYPE(HOOKS_T) :: HOOKS

  CHARACTER(LEN=1,KIND=C_CHAR), DIMENSION(:), POINTER :: FNAME_C
  CHARACTER(LEN=1024) :: FNAME_F
  INTEGER(KIND=JPIB_K) :: WRITE_STAT
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: UNIT
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_DICT
  TYPE(FORTRAN_MESSAGE_T), POINTER :: MARS_DICT
  TYPE(PARAMETRIZATION_T), POINTER :: PAR_DICT
  TYPE(REDUCED_GG_T), POINTER :: REDUCED_GG_DICT
  TYPE(SH_T), POINTER :: SH_DICT

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRITE_YAML=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OPEN_UNIT=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED =4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_LENGTH=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FNAME_NOT_ASSOCIATED =6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_DICTIONARY =7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE =8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_DICTIONARY_TYPE=9_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(FNAME), ERRFLAG_FNAME_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( LEN .LE. 0, ERRFLAG_INVALID_LENGTH )

  !> Get the size of the dictionary type
  CALL C_F_POINTER( FNAME, FNAME_C, [LEN] )

  ! Copy the dictionary type to a fortran string
  FNAME_F = REPEAT(' ', 1024)
  DO I = 1, LEN
    FNAME_F(I:I) = FNAME_C(I)
  END DO

  !TODO: Convert to lowercase

  SELECT CASE( TRIM(FNAME_F) )

  CASE ('stderr')
    WRITE(ERROR_UNIT, *) "TO_YAML: "
    UNIT = ERROR_UNIT
  CASE ('stdout')
    WRITE(OUTPUT_UNIT, *) "TO_YAML: "
    UNIT = OUTPUT_UNIT
  CASE default
    OPEN(NEWUNIT=UNIT, FILE=FNAME_F, ACTION="WRITE", IOSTAT=WRITE_STAT)

    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_OPEN_UNIT )
  END SELECT


  !> Get th fortran handle from the c handle
  F_DICT => NULL()
  CALL C_F_POINTER( DICT, F_DICT, [2] )

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_DICT(1) )

  CASE ( MARS_DICT_TYPE_E )
    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_MARS_DICTIONARY( F_DICT, MARS_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_WRITE_YAML) MARS_DICT%WRITE_TO_YAML(UNIT, 0_JPIB_K, HOOKS)

  CASE ( PAR_DICT_TYPE_E )
    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_PAR_DICTIONARY( F_DICT, PAR_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_WRITE_YAML) PAR_DICT%WRITE_TO_YAML(UNIT, 0_JPIB_K, HOOKS)

  CASE ( REDUCED_GG_DICT_TYPE_E )
    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_REDUCED_GG_DICTIONARY( F_DICT, REDUCED_GG_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_WRITE_YAML) REDUCED_GG_DICT%WRITE_TO_YAML(UNIT, 0_JPIB_K, HOOKS)


  CASE ( SH_DICT_TYPE_E )
    PP_TRYCALL(ERRFLAG_EXTRACT_DICTIONARY) EXTRACT_SH_DICTIONARY( F_DICT, SH_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_WRITE_YAML) SH_DICT%WRITE_TO_YAML(UNIT, 0_JPIB_K, HOOKS)

  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )

  END SELECT


  SELECT CASE( TRIM(FNAME_F) )
  CASE ('stderr')
  CASE ('stdout')
  CASE default
    CLOSE(UNIT=UNIT)
  END SELECT


  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_WRITE_YAML)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error writing yaml' )
    CASE (ERRFLAG_OPEN_UNIT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error opening write to file' )
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_INVALID_LENGTH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid length of fname' )
    CASE (ERRFLAG_FNAME_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'FNAME not associated' )
    CASE (ERRFLAG_EXTRACT_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Can not extract dictionary' )
    CASE (ERRFLAG_UNKNOWN_DICTIONARY_TYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown dictionary type' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_TO_YAML
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





END MODULE API_DICTIONARY_WRAPPER_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME
