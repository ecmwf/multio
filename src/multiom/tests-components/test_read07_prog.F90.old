! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"

#define PP_FILE_NAME 'test_read07_prog.F90'
#define PP_SECTION_TYPE 'PROGRAM'
#define PP_SECTION_NAME 'TEST_READ07_PROG'
#define PP_PROCEDURE_TYPE 'PROGRAM'
#define PP_PROCEDURE_NAME 'MAIN'
PROGRAM TEST_READ07_PROG

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K


  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATIONS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_NEW_CONFIGURATION_FROM_FILE
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATION

  USE :: HOOKS_MOD,          ONLY: HOOKS_T
  USE :: INTOP_FACTORY_MOD,  ONLY: MAKE_INTOP
  USE :: INTOP_FACTORY_MOD,  ONLY: DESTROY_INTOP
  USE :: INTOP_BASE_MOD,     ONLY: INTOP_BASE_A
  USE :: FILTER_OPTIONS_MOD, ONLY: FILTER_OPTIONS_T

  USE :: PARAMETRIZATION_MOD, ONLY: PARAMETRIZATION_T
  USE :: FORTRAN_MESSAGE_MOD, ONLY: FORTRAN_MESSAGE_T
  USE :: MAPPING_RULES_COLLECTION_MOD, ONLY: MAPPING_RULES_COLLECTION_T
  USE :: CASHED_MAPPER_MOD, ONLY: CASHED_MAPPER_T
  USE :: CACHED_MAPPER_COLLECTION_MOD, ONLY: CACHED_MAPPER_COLLECTION_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Test encodr object
  TYPE(HOOKS_T) :: HOOKS
  TYPE(YAML_CONFIGURATION_T) :: CONFIG
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: SZ
  INTEGER(KIND=JPIB_K) :: UNIT
  INTEGER(KIND=JPIB_K) :: OFFSET
  INTEGER(KIND=JPIB_K) :: RET
  INTEGER(KIND=JPIB_K) :: LENGTH
  INTEGER(KIND=JPIB_K) :: RES
  INTEGER(KIND=JPIB_K) :: DEALLOC_ERROR
  LOGICAL :: HAS_INTOP
  TYPE(YAML_CONFIGURATION_T) :: INTOP_CONFIGURATION
  CLASS(INTOP_BASE_A), POINTER :: INTOP

  TYPE(FORTRAN_MESSAGE_T) :: MSG
  TYPE(PARAMETRIZATION_T) :: PAR
  TYPE(FORTRAN_MESSAGE_T) :: MSG_OUT
  TYPE(PARAMETRIZATION_T) :: PAR_OUT
  TYPE(MAPPING_RULES_COLLECTION_T) :: MAPPING_RULES_COLLECTION
  TYPE(FILTER_OPTIONS_T) :: FILTER_OPT
  TYPE(CASHED_MAPPER_T), POINTER, DIMENSION(:) :: MAPPING_INFO
  TYPE(CACHED_MAPPER_COLLECTION_T) :: NODE

  LOGICAL :: FEXIST
  CHARACTER(LEN=:), ALLOCATABLE :: JSON
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  CHARACTER(LEN=256) :: FNAME

  ! Error codes

  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_FILE = 0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_FILE_DOES_NOT_EXIST = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAKE_INTOP = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INTOP_DEALLOCATION_ERROR = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INTOP_PRINT_ERROR = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INTOP_EVAL_ERROR = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAPPING_RULES_INIT = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAPPING_RULES_MATCH = 7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAPPING_RULES_EVAL = 8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAPPING_RULES_PRINT = 9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAPPING_RULES_FREE = 10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MESSAGE_PRINT = 11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MESSAGE_TO_JSON = 12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MESSAGE_UNABLE_TO_DEALLOCATE = 13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAPPING_COLLECTION_INIT = 14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAPPING_COLLECTION_SIZE = 15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAPPING_COLLECTION_EVAL = 16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAPPING_COLLECTION_FREE = 17_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Get the first command-line argument (index starts from 1)
  FNAME = REPEAT(' ', 256)
  IF ( COMMAND_ARGUMENT_COUNT() .EQ. 1 ) THEN
    ! Get the first command-line argument (index starts from 1)
    CALL GET_COMMAND_ARGUMENT(1, FNAME, LENGTH, RET )
    IF (RET .NE. 0) THEN
      FNAME = 'config-expression.yaml'
    END IF
  ELSE
    FNAME = 'config-expression.yaml'
  END IF

  ! Inquire file existence
  INQUIRE( FILE=TRIM(ADJUSTL(FNAME)), EXIST=FEXIST )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. FEXIST, ERRFLAG_CFG_FILE )

  !> Set the unit and offset
  UNIT = 6
  OFFSET = 1
  CALL HOOKS%DEBUG_HOOK_%INIT( )


  MSG%PARAM=220221
  MSG%LEVTYPE=6
  MSG%LEVELIST=137
  MSG%EXPVER='XYZT'

  !> Open the configuration file
  PP_TRYCALL(ERRFLAG_CFG_FILE_DOES_NOT_EXIST) YAML_NEW_CONFIGURATION_FROM_FILE( TRIM(ADJUSTL(FNAME)), CONFIG, HOOKS )

  !> Read the mapping rules
  PP_TRYCALL(ERRFLAG_MAPPING_RULES_INIT) MAPPING_RULES_COLLECTION%INIT( CONFIG, FILTER_OPT, HOOKS )

  !> Apply filter to a message/parameterization
  PP_TRYCALL(ERRFLAG_MAPPING_RULES_MATCH) MAPPING_RULES_COLLECTION%MATCH( MSG, PAR, FILTER_OPT, MAPPING_INFO, HOOKS )

  !> Check if we have any mapping info
  IF ( ASSOCIATED(MAPPING_INFO) ) THEN
    !> Check if we have any mapping info
    PP_TRYCALL(ERRFLAG_MAPPING_COLLECTION_INIT) NODE%INIT( MAPPING_INFO, HOOKS )
    PP_TRYCALL(ERRFLAG_MAPPING_COLLECTION_SIZE) NODE%SIZE( SZ, HOOKS )
    DO I = 1, SZ
      !> Evaluate the configuration
      PP_TRYCALL(ERRFLAG_MAPPING_COLLECTION_EVAL) NODE%EVAL( I, MSG, PAR, MSG_OUT, PAR_OUT, HOOKS )
      PP_TRYCALL(ERRFLAG_MESSAGE_PRINT) MSG_OUT%PRINT( 6_JPIB_K, HOOKS )
      PP_TRYCALL(ERRFLAG_MESSAGE_PRINT) PAR_OUT%PRINT( 6_JPIB_K, HOOKS )
      PP_TRYCALL(ERRFLAG_MESSAGE_TO_JSON) MSG_OUT%TO_JSON( JSON, HOOKS )
      IF ( ALLOCATED(JSON) ) THEN
        WRITE(*,*) ' - MESSAGE JSON: ', JSON, LEN(JSON), LEN_TRIM(JSON)
        DEALLOCATE(JSON, STAT=DEALLOC_ERROR, ERRMSG=ERRMSG)
        PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_ERROR .NE. 0, ERRFLAG_MESSAGE_UNABLE_TO_DEALLOCATE )
      ENDIF
      PP_TRYCALL(ERRFLAG_MESSAGE_TO_JSON) PAR_OUT%TO_JSON( JSON, HOOKS )
      IF ( ALLOCATED(JSON) ) THEN
        WRITE(*,*) ' - PARAMETRIZATION JSON: ', JSON, LEN(JSON), LEN_TRIM(JSON)
        DEALLOCATE(JSON, STAT=DEALLOC_ERROR, ERRMSG=ERRMSG)
        PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_ERROR .NE. 0, ERRFLAG_MESSAGE_UNABLE_TO_DEALLOCATE )
      ENDIF
    END DO
    !> Check if we have any mapping info
    PP_TRYCALL(ERRFLAG_MAPPING_COLLECTION_FREE) NODE%FREE( HOOKS )
  ELSE
    WRITE(*,*) ' - No mapping info associated'
  ENDIF

  !> Read the intop configuration
  PP_TRYCALL(ERRFLAG_MAPPING_RULES_PRINT) MAPPING_RULES_COLLECTION%PRINT( UNIT, OFFSET, HOOKS )

  !> Read the intop configuration
  PP_TRYCALL(ERRFLAG_MAPPING_RULES_FREE) MAPPING_RULES_COLLECTION%FREE( HOOKS )


  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  !> Exit point (on success)
  STOP 0

! Error handler
PP_ERROR_HANDLER

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_FILE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to open the configuration file' )
    CASE (ERRFLAG_CFG_FILE_DOES_NOT_EXIST)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'The configuration file does not exist' )
    CASE (ERRFLAG_MAKE_INTOP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to make the intop' )
    CASE (ERRFLAG_INTOP_DEALLOCATION_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to deallocate the intop' )
    CASE (ERRFLAG_INTOP_PRINT_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to print the intop' )
    CASE (ERRFLAG_INTOP_EVAL_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to evaluate the intop' )
    CASE (ERRFLAG_MAPPING_RULES_INIT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to initialize the mapping rules' )
    CASE (ERRFLAG_MAPPING_RULES_PRINT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to print the mapping rules' )
    CASE (ERRFLAG_MESSAGE_PRINT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to print the message' )
    CASE (ERRFLAG_MAPPING_RULES_FREE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free the mapping rules' )
    CASE (ERRFLAG_MAPPING_RULES_EVAL)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to eval the mapping rules' )
    CASE (ERRFLAG_MESSAGE_TO_JSON)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert the message to JSON' )
    CASE (ERRFLAG_MESSAGE_UNABLE_TO_DEALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to deallocate the message' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error message: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG, STAT=DEALLOC_ERROR)
      END IF
    CASE (ERRFLAG_MAPPING_COLLECTION_INIT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to initialize the mapping collection' )
    CASE (ERRFLAG_MAPPING_COLLECTION_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get the size of the mapping collection' )
    CASE (ERRFLAG_MAPPING_COLLECTION_EVAL)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to evaluate the mapping collection' )
    CASE (ERRFLAG_MAPPING_COLLECTION_FREE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free the mapping collection' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( 6_JPIB_K )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT()

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  STOP 1

END PROGRAM TEST_READ07_PROG
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME