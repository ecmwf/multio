MODULE OM_DISTRIBUTOR_MOD

  ! Symbols imported from the main library of the project.
  USE :: OM_API_MOD, ONLY: JPIB_K
  USE :: OM_API_MOD, ONLY: MAP_T

IMPLICIT NONE

PRIVATE

INTEGER :: NPROCS
INTEGER :: ME

TYPE :: PROC_MAP_T
  INTEGER(KIND=JPIB_K) :: PROC_ID_
  INTEGER(KIND=JPIB_K) :: CNT_
  TYPE(PROC_MAP_T), POINTER :: NEXT_ => NULL()
END TYPE

TYPE :: PARAM_ID_NODE_T
  TYPE(MAP_T), DIMENSION(2,11) :: LEVEL_MAPS_
  TYPE(PARAM_ID_NODE_T), POINTER :: NEXT_ => NULL()
CONTAINS
    PROCEDURE, PUBLIC, PASS :: INIT => PARAM_INIT
    PROCEDURE, PUBLIC, PASS :: FREE => PARAM_FREE
    PROCEDURE, PUBLIC, PASS :: ACCESS_OR_CREATE => PARAM_ACCESS_OR_CREATE
END TYPE

TYPE :: DISTRIBUTOR_T
  TYPE(MAP_T) :: PARAM_ID_MAP_
CONTAINS
  PROCEDURE, PUBLIC, PASS :: INIT => DISTRIBUTOR_INIT
  PROCEDURE, PUBLIC, PASS :: FREE => DISTRIBUTOR_FREE
  PROCEDURE, PUBLIC, PASS :: ACCESS_OR_CREATE => DISTRIBUTOR_ACCESS_OR_CREATE
END TYPE

TYPE(PARAM_ID_NODE_T), POINTER :: PHEAD_LEVREP
TYPE(PROC_MAP_T),      POINTER :: PHEAD_PROCS


PUBLIC :: DISTRIBUTOR_T
PUBLIC :: MP_INIT
PUBLIC :: MP_FREE
PUBLIC :: MP_ME

CONTAINS

FUNCTION MP_ME() RESULT(M)
  INTEGER :: M
  M = ME
  RETURN
END FUNCTION MP_ME

SUBROUTINE MP_INIT( )
  USE :: MPI_F08, ONLY: MPI_INIT
  USE :: MPI_F08, ONLY: MPI_COMM_WORLD
  USE :: MPI_F08, ONLY: MPI_COMM_SIZE
  USE :: MPI_F08, ONLY: MPI_COMM_RANK
IMPLICIT NONE
  INTEGER :: IERR
  CALL MPI_INIT( IERR )
  CALL MPI_COMM_SIZE(MPI_COMM_WORLD, NPROCS, IERR)
  CALL MPI_COMM_RANK(MPI_COMM_WORLD, ME, IERR)
  RETURN
END SUBROUTINE MP_INIT


SUBROUTINE MP_FREE( )
  USE :: MPI_F08, ONLY: MPI_FINALIZE
IMPLICIT NONE
  INTEGER :: IERR
  CALL MPI_FINALIZE( IERR )
  RETURN
END SUBROUTINE MP_FREE

SUBROUTINE DISTRIBUTOR_INIT( THIS )
  USE :: OM_API_MOD, ONLY: MAP_INIT
IMPLICIT NONE
  CLASS(DISTRIBUTOR_T), INTENT(INOUT) :: THIS
  CALL MAP_INIT( THIS%PARAM_ID_MAP_ )
  RETURN
END SUBROUTINE DISTRIBUTOR_INIT

SUBROUTINE PARAM_INIT( THIS )
  USE :: OM_API_MOD, ONLY: MAP_INIT
IMPLICIT NONE
  CLASS(PARAM_ID_NODE_T), INTENT(INOUT) :: THIS

  CALL MAP_INIT( THIS%LEVEL_MAPS_(1,1) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(1,2) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(1,3) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(1,4) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(1,5) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(1,6) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(1,7) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(1,8) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(1,9) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(1,10) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(1,11) )

  CALL MAP_INIT( THIS%LEVEL_MAPS_(2,1) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(2,2) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(2,3) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(2,4) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(2,5) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(2,6) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(2,7) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(2,8) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(2,9) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(2,10) )
  CALL MAP_INIT( THIS%LEVEL_MAPS_(2,11) )

  RETURN

END SUBROUTINE PARAM_INIT

SUBROUTINE DISTRIBUTOR_FREE( THIS )
  USE :: OM_API_MOD, ONLY: MAP_FREE
IMPLICIT NONE
  CLASS(DISTRIBUTOR_T), INTENT(INOUT) :: THIS

  TYPE(PARAM_ID_NODE_T), POINTER :: TMP1
  TYPE(PROC_MAP_T),      POINTER :: TMP2


  FreeParamLoop: DO
    IF ( .NOT.ASSOCIATED(PHEAD_PROCS) ) THEN
      EXIT FreeParamLoop
    ENDIF
    TMP2 => PHEAD_PROCS
    PHEAD_PROCS => PHEAD_PROCS%NEXT_
    DEALLOCATE(TMP2)
    NULLIFY(TMP2)
  ENDDO FreeParamLoop

  FreeLevRepLoop: DO
    IF ( .NOT.ASSOCIATED(PHEAD_LEVREP) ) THEN
      EXIT FreeLevRepLoop
    ENDIF
    TMP1 => PHEAD_LEVREP
    PHEAD_LEVREP => PHEAD_LEVREP%NEXT_
    CALL TMP1%FREE()
    DEALLOCATE(TMP1)
    NULLIFY(TMP1)
  ENDDO FreeLevRepLoop

  ! Free the main map
  CALL MAP_FREE( THIS%PARAM_ID_MAP_ )

  ! Exit point
  RETURN

END SUBROUTINE DISTRIBUTOR_FREE



SUBROUTINE PARAM_FREE( THIS )
  USE :: OM_API_MOD, ONLY: MAP_FREE
IMPLICIT NONE
  CLASS(PARAM_ID_NODE_T), INTENT(INOUT) :: THIS

  ! Free the main map
  CALL MAP_FREE( THIS%LEVEL_MAPS_(1,1) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(1,2) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(1,3) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(1,4) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(1,5) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(1,6) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(1,7) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(1,8) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(1,9) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(1,10) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(1,11) )

  CALL MAP_FREE( THIS%LEVEL_MAPS_(2,1) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(2,2) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(2,3) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(2,4) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(2,5) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(2,6) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(2,7) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(2,8) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(2,9) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(2,10) )
  CALL MAP_FREE( THIS%LEVEL_MAPS_(2,11) )

  ! Exit point
  RETURN

END SUBROUTINE PARAM_FREE


FUNCTION DISTRIBUTOR_ACCESS_OR_CREATE( THIS, CNT, PARAM_ID, REPRES, LEVTYPE, LEVEL, IS_NEW ) RESULT(CHECK)

  ! Symbols imported from the main library of the project.
  USE :: OM_API_MOD, ONLY: JPIB_K
  USE :: OM_API_MOD, ONLY: KEY_T
  USE :: OM_API_MOD, ONLY: MAP_INSERT
  USE :: OM_API_MOD, ONLY: MAP_GET

IMPLICIT NONE

  ! Dummy arguments
  CLASS(DISTRIBUTOR_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: CNT
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: PARAM_ID
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: REPRES
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: LEVTYPE
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: LEVEL
  LOGICAL,              INTENT(OUT)   :: IS_NEW

  ! Function result
  LOGICAL :: CHECK

  ! Local variables
  TYPE(KEY_T) :: KEY
  CLASS(*), POINTER :: VALUE
  TYPE(PARAM_ID_NODE_T), POINTER :: TMP
  LOGICAL :: EX
  INTEGER(KIND=JPIB_K) :: RET

  ! Initialize the key
  KEY%K = PARAM_ID

 ! Get encoding info
  EX = MAP_GET( THIS%PARAM_ID_MAP_, KEY, VALUE )

  IF ( EX ) THEN

    SELECT TYPE ( A => VALUE )

    CLASS IS ( PARAM_ID_NODE_T )

        ! Access the parameter
        RET = A%ACCESS_OR_CREATE( CNT, REPRES, LEVTYPE, LEVEL, IS_NEW )

    CLASS DEFAULT

        ! Error
        RET = -1

    END SELECT

  ELSE

    ! Update the list of nodes
    IF ( .NOT.ASSOCIATED(PHEAD_LEVREP) ) THEN
      ALLOCATE(PHEAD_LEVREP)
      TMP => PHEAD_LEVREP
    ELSE
      TMP => PHEAD_LEVREP
      NULLIFY(PHEAD_LEVREP)
      ALLOCATE(PHEAD_LEVREP)
      PHEAD_LEVREP%NEXT_ => TMP
      TMP => PHEAD_LEVREP
    ENDIF

    ! Insert in the subtree
    CALL TMP%INIT()
    RET = TMP%ACCESS_OR_CREATE( CNT, REPRES, LEVTYPE, LEVEL, IS_NEW )

    ! Associate the abstract pointer
    VALUE => TMP

    ! Insert in the main tree
    CALL MAP_INSERT( THIS%PARAM_ID_MAP_, KEY, VALUE )

  ENDIF

  IF ( RET .EQ. ME ) THEN
    CHECK = .TRUE.
  ELSE
    CHECK = .FALSE.
  ENDIF

  ! Exit point
  RETURN

END FUNCTION DISTRIBUTOR_ACCESS_OR_CREATE




FUNCTION PARAM_ACCESS_OR_CREATE( THIS, CNT, REPRES, LEVTYPE, LEVEL, IS_NEW ) RESULT(RET)

  ! Symbols imported from the main library of the project.
  USE :: OM_API_MOD, ONLY: JPIB_K
  USE :: OM_API_MOD, ONLY: KEY_T
  USE :: OM_API_MOD, ONLY: MAP_INSERT
  USE :: OM_API_MOD, ONLY: MAP_GET

IMPLICIT NONE

  ! Dummy arguments
  CLASS(PARAM_ID_NODE_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K),   INTENT(IN)    :: CNT
  INTEGER(KIND=JPIB_K),   INTENT(IN)    :: REPRES
  INTEGER(KIND=JPIB_K),   INTENT(IN)    :: LEVTYPE
  INTEGER(KIND=JPIB_K),   INTENT(IN)    :: LEVEL
  LOGICAL,                INTENT(OUT)   :: IS_NEW

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  TYPE(KEY_T) :: KEY
  CLASS(*), POINTER :: VALUE
  TYPE(PROC_MAP_T), POINTER :: TMP
  LOGICAL :: EX

  ! Initialize the key
  KEY%K = LEVEL

 ! Get encoding info
  EX = MAP_GET( THIS%LEVEL_MAPS_(REPRES,LEVTYPE), KEY, VALUE )

  IF ( EX ) THEN

    IS_NEW = .FALSE.
    SELECT TYPE ( A => VALUE )

    CLASS IS ( PROC_MAP_T )

        ! Access the parameter
        RET = A%PROC_ID_

    CLASS DEFAULT

        ! Error
        RET = -2

    END SELECT

  ELSE

    ! Update the list of nodes
    IF ( .NOT.ASSOCIATED(PHEAD_PROCS) ) THEN
      ALLOCATE(PHEAD_PROCS)
      TMP => PHEAD_PROCS
    ELSE
      TMP => PHEAD_PROCS
      NULLIFY(PHEAD_PROCS)
      ALLOCATE(PHEAD_PROCS)
      PHEAD_PROCS%NEXT_ => TMP
      TMP => PHEAD_PROCS
    ENDIF

    IS_NEW = .TRUE.

    ! Initialize the node
    TMP%CNT_     = CNT
    TMP%PROC_ID_ = MOD(CNT,NPROCS)
    RET          = TMP%PROC_ID_

    ! Associate the abstract pointer
    VALUE => TMP

    ! Insert in the main tree
    CALL MAP_INSERT( THIS%LEVEL_MAPS_(REPRES,LEVTYPE), KEY, VALUE )

  ENDIF

  ! Exit point
  RETURN

END FUNCTION PARAM_ACCESS_OR_CREATE

END MODULE OM_DISTRIBUTOR_MOD