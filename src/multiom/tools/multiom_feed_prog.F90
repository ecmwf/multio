! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"

#define PP_FILE_NAME 'multiom_feed_prog.F90'
#define PP_SECTION_TYPE 'PROGRAM'
#define PP_SECTION_NAME 'MULTIOM_FEED_PROG'
#define PP_PROCEDURE_TYPE 'PROGRAM'
#define PP_PROCEDURE_NAME 'MULTIOM_FEED_PROG'
PROGRAM MULTIOM_FEED_PROG

  ! Symbolds imported from intrinsic modules
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: OUTPUT_UNIT
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
  USE, INTRINSIC :: ISO_C_BINDING,   ONLY: C_INT

  ! Symbols imported from other modules within the project.
  ! USE :: OM_TOOL_UTILS_MOD, ONLY: SET_HOOK_VERBOSITY
  ! USE :: OM_TOOL_UTILS_MOD, ONLY: OM_ABORT
  USE :: MULTIOM_TOOLS_UTILS_MOD, ONLY: DR_HOOK_DEFAULT8
  USE :: MULTIOM_TOOLS_UTILS_MOD, ONLY: PREPARE_OUTPUT_MANAGER_EC
  USE :: MULTIOM_TOOLS_UTILS_MOD, ONLY: READ_ATM_MESSAGE
  USE :: MULTIOM_TOOLS_UTILS_MOD, ONLY: READ_WAM_MESSAGE
  USE :: MULTIOM_TOOLS_UTILS_MOD, ONLY: READ_VAL_SP
  USE :: MULTIOM_TOOLS_UTILS_MOD, ONLY: READ_VAL_DP

  USE :: MULTIOM_TOOLS_CFG_MOD, ONLY: COMMAND_LINE_ARGS_T
  USE :: MULTIOM_TOOLS_CFG_MOD, ONLY: INIT_COMMAND_LINE_OPTIONS
  USE :: MULTIOM_TOOLS_CFG_MOD, ONLY: PARSE_COMMAND_LINE_OPTIONS
  USE :: MULTIOM_TOOLS_CFG_MOD, ONLY: PRINT_COMMAND_LINE_OPTIONS
  USE :: MULTIOM_TOOLS_CFG_MOD, ONLY: FREE_COMMAND_LINE_OPTIONS
  USE :: MULTIOM_TOOLS_CFG_MOD, ONLY: MATCH

  USE :: MULTIO_API, ONLY: MULTIO_INITIALISE
  USE :: MULTIO_API, ONLY: MULTIO_SUCCESS

  ! Symbols imported from the main library of the project.
  USE :: MULTIOM_API, ONLY: HOOKS_T
  USE :: MULTIOM_API, ONLY: IPREFIX2ILEVTYPE
  USE :: MULTIOM_API, ONLY: ILEVTYPE2CLEVTYPE
  USE :: MULTIOM_API, ONLY: IREPRES2CREPRES
  USE :: MULTIOM_API, ONLY: JPIB_K
  USE :: MULTIOM_API, ONLY: VALUES_SP_E
  USE :: MULTIOM_API, ONLY: VALUES_DP_E
  USE :: MULTIOM_API, ONLY: OM_ATM_MSG_T
  USE :: MULTIOM_API, ONLY: OM_WAM_MSG_T
  USE :: MULTIOM_API, ONLY: MODEL_PAR_T
  USE :: MULTIOM_API, ONLY: PROC_TOPO_T
  USE :: MULTIOM_API, ONLY: OUTPUT_MANAGER_BASE_A
  USE :: MULTIOM_API, ONLY: MAKE_OUTPUT_MANAGER
  USE :: MULTIOM_API, ONLY: DESTROY_OUTPUT_MANAGER
  ! USE :: MULTIOM_API, ONLY: CHECK_REAL_KIND
  ! USE :: MULTIOM_API, ONLY: OM_SET_ABORT_PROCEDURE
  ! USE :: MULTIOM_API, ONLY: OM_SET_ERROR_UNIT
  USE :: MULTIOM_API, ONLY: OM_SET_DR_HOOK
  USE :: MULTIOM_API, ONLY: MSG_PRINT_ATM
  USE :: MULTIOM_API, ONLY: MSG_PRINT_WAM
  USE :: MULTIOM_API, ONLY: TOC_CONTAINER_T
  USE :: MULTIOM_API, ONLY: TOC_CREATE_NAME
  USE :: MULTIOM_API, ONLY: TOC_ENTRY_BASE_T
  USE :: MULTIOM_API, ONLY: TOC_SIM_INIT_T
  USE :: MULTIOM_API, ONLY: TOC_ATM_FIELD_T
  USE :: MULTIOM_API, ONLY: TOC_WAM_FIELD_T
  USE :: MULTIOM_API, ONLY: TOC_FLUSH_STEP_T
  USE :: MULTIOM_API, ONLY: TOC_FLUSH_STEP_RST_T
  USE :: MULTIOM_API, ONLY: TOC_FLUSH_LAST_STEP_T
  USE :: MULTIOM_API, ONLY: TOC_SIM_END_T
  USE :: MULTIOM_API, ONLY: TOC_READ_ALL
  USE :: MULTIOM_API, ONLY: TOC_READ
  USE :: MULTIOM_API, ONLY: TOC_FREE

IMPLICIT NONE

  !
  ! Local variables
  TYPE(HOOKS_T) :: HOOKS
  TYPE(COMMAND_LINE_ARGS_T) :: CFG
  CLASS(OUTPUT_MANAGER_BASE_A), POINTER :: YLOM
  TYPE(PROC_TOPO_T) :: YLTOPO
  TYPE(MODEL_PAR_T) :: YLOMP
  INTEGER(KIND=JPIB_K) :: TOCID
  INTEGER(KIND=JPIB_K) :: WRITE_STATUS
  LOGICAL :: LMATCH
  CHARACTER(LEN=16) :: CLEVTYPE
  CHARACTER(LEN=16) :: CREPRES
  INTEGER(KIND=JPIB_K) :: ILEVTYPE
  INTEGER(KIND=C_INT) :: ERR
  TYPE(OM_ATM_MSG_T) :: YLATMMSG
  TYPE(OM_WAM_MSG_T) :: YLWAMMSG
  CHARACTER(LEN=2048) :: TOCFNAME
  CHARACTER(LEN=2048) :: MSGFNAME
  CHARACTER(LEN=2048) :: FULLDIR
  LOGICAL :: EX
  TYPE(TOC_CONTAINER_T), DIMENSION(:), ALLOCATABLE :: TOC
  REAL(KIND=REAL32), POINTER, DIMENSION(:) :: VALUES_SP
  REAL(KIND=REAL64), POINTER, DIMENSION(:) :: VALUES_DP

  ! Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_INITIALIZE_MULTIO=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_INIT_CMD_LINE=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_PARSE_CMD_LINE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_PRINT_CMD_LINE=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_PREPARE_OUTPUT_MANAGER=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_MAKE_OUTPUT_MANAGER=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_TOC_NAME=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_TOC=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_ALL_TOC=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CREATE_TOC_NAME=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_HEADER=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_FREE_COMMAND_LINE_OPTIONS=12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_FREE_TOC=13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_LOG=14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_ATM_MESSAGE=15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_WAM_MESSAGE=16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_VAL_SP=17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_VAL_DP=18_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_ATM_SP=19_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_ATM_DP=20_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_VAL_TYPE=21_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_REPRES=22_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_ILEVTYPE=23_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_CLEVTYPE=24_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_MATCH_MESSAGE=25_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_FLUSH_STEP=26_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_FLUSH_STEP_AND_RESTART=27_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_LAST_STEP=28_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DESTROY_OUTPUT_MANAGER=29_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_TOC_TYPE=30_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_WAM_SP=31_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_WAM_DP=32_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialize the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  ! Initialize multio
  ERR = MULTIO_INITIALISE()
  PP_DEBUG_CRITICAL_COND_THROW( ERR.NE.MULTIO_SUCCESS, ERRFLAG_UNABLE_TO_INITIALIZE_MULTIO )

  ! Set the default values for the command line options
  PP_TRYCALL(ERRFLAG_UNABLE_TO_INIT_CMD_LINE) INIT_COMMAND_LINE_OPTIONS( CFG, HOOKS )


  ! Parse command line options
  PP_TRYCALL(ERRFLAG_UNABLE_TO_PARSE_CMD_LINE) PARSE_COMMAND_LINE_OPTIONS( CFG, HOOKS )

  ! Log the configuration of hte tool
  IF ( CFG%VERBOSE ) THEN
    PP_TRYCALL(ERRFLAG_UNABLE_TO_PRINT_CMD_LINE) PRINT_COMMAND_LINE_OPTIONS( CFG, HOOKS )
  ENDIF

  ! Set the verbosity of the hooks at begin and end of every function
  ! CALL SET_HOOK_VERBOSITY( .FALSE. )


  ! Configure the DR_HOOK handlers
  CALL OM_SET_DR_HOOK( .TRUE., DR_HOOK_DEFAULT8 )

  ! Configure the error unit to be used by the output manager
  ! CALL OM_SET_ERROR_UNIT( ERROR_UNIT )

  ! Extract topology informations and all model parameters from the IOserver data structure
  PP_TRYCALL(ERRFLAG_UNABLE_TO_PREPARE_OUTPUT_MANAGER) PREPARE_OUTPUT_MANAGER_EC( TRIM(CFG%INPUT_DIR), CFG%PROC_IDX, YLTOPO, YLOMP, CFG%BIG_ENDIAN_READ, CFG%VERBOSE, HOOKS )

  ! Consttruct an outu manager
  PP_TRYCALL(ERRFLAG_UNABLE_TO_MAKE_OUTPUT_MANAGER)  MAKE_OUTPUT_MANAGER( CFG%OUTPUT_MANAGER_TYPE, YLTOPO, YLOMP, CFG%YAML_CONFIGURATION, YLOM, HOOKS )

  ! Read and merge all the toc files
  IF ( CFG%NPROCS .GT. 0 ) THEN
    TOCFNAME = REPEAT( ' ', 2048 )
    WRITE(FULLDIR,'(A,A,I6.6,A)',IOSTAT=WRITE_STATUS) TRIM(ADJUSTL(CFG%INPUT_DIR)), '/io_serv.', CFG%NPROCS, '.d'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_TOC_NAME )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CREATE_TOC_NAME) TOC_CREATE_NAME( TRIM(FULLDIR), CFG%NPROCS, TOCFNAME, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_TOC) TOC_READ( TOCFNAME, TOC, CFG%BIG_ENDIAN_READ, CFG%VERBOSE, HOOKS )
  ELSE
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_ALL_TOC) TOC_READ_ALL( TRIM(CFG%INPUT_DIR), TOC, YLOMP%SIM_%NPROC_IO, CFG%BIG_ENDIAN_READ, CFG%VERBOSE, HOOKS )
  ENDIF

  ! Print the header
  IF ( CFG%VERBOSE ) THEN
    WRITE(OUTPUT_UNIT,'(A150)',IOSTAT=WRITE_STATUS) REPEAT('-',150)
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_HEADER )
    WRITE(OUTPUT_UNIT,'(A20,A10,A10,A10,A10,A10,A10,A4,A20,A10)',IOSTAT=WRITE_STATUS) ' message type', 'paramId', 'level/uid', 'step', 'proc', 'repres', 'prefix', '    ', 'crepres', 'clevtype'
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_HEADER )
  ENDIF


  ! Loop over the toc entries
  FeederLoop: DO TOCID = 1, SIZE(TOC)

    SELECT TYPE ( A => TOC(TOCID)%ENTRY_ )

    ! ==============================================================================================
    CLASS IS ( TOC_SIM_INIT_T )

      IF ( CFG%DRYRUN ) THEN
        WRITE(OUTPUT_UNIT,'(A150)', IOSTAT=WRITE_STATUS) REPEAT('-',150)
        PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
        WRITE(OUTPUT_UNIT,*, IOSTAT=WRITE_STATUS) 'Begin of simulation'
        PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
      ENDIF
      CYCLE FeederLoop

    ! ==============================================================================================
    CLASS IS ( TOC_ATM_FIELD_T )

      PP_TRYCALL(ERRFLAG_UNABLE_TO_MATCH_MESSAGE) MATCH( CFG, A%PARAM_ID_, A%U_ID_, A%STEP_ID_, &
&             A%PROC_ID_, A%REPRES_ID_, A%PREFIX_ID_, LMATCH, HOOKS )
      IF ( LMATCH ) THEN
        IF ( .NOT.CFG%DRYRUN ) THEN
          SELECT CASE ( A%VAL_TYPE_ )
          CASE ( VALUES_SP_E )

            ! Read the next message to be processed
            PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_ATM_MESSAGE) READ_ATM_MESSAGE( TRIM(CFG%INPUT_DIR), A%PROC_ID_, &
&                A%MSG_ID_, A%MSG_ADDR_, YLATMMSG, CFG%BIG_ENDIAN_READ, CFG%VERBOSE, HOOKS )

            ! Read the values
            PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VAL_SP) READ_VAL_SP( TRIM(CFG%INPUT_DIR), A%PROC_ID_, A%MSG_ID_, &
&                  A%VAL_ADDR_, A%VAL_LB_, A%VAL_UB_, VALUES_SP, CFG%BIG_ENDIAN_READ, CFG%VERBOSE, HOOKS )

            ! Write data to the output manager
            PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_ATM_SP) YLOM%WRITE_ATM_SP( YLATMMSG, VALUES_SP, HOOKS )

          CASE ( VALUES_DP_E )

            ! Read the next message to be processed
            PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_ATM_MESSAGE) READ_ATM_MESSAGE( TRIM(CFG%INPUT_DIR), A%PROC_ID_, A%MSG_ID_, &
&                       A%MSG_ADDR_, YLATMMSG, CFG%BIG_ENDIAN_READ, CFG%VERBOSE, HOOKS )

            ! Rdad the values
            PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VAL_DP) READ_VAL_DP( TRIM(CFG%INPUT_DIR), A%PROC_ID_, A%MSG_ID_, A%VAL_ADDR_, &
&                  A%VAL_LB_, A%VAL_UB_, VALUES_DP, CFG%BIG_ENDIAN_READ, CFG%VERBOSE, HOOKS )

            ! Write data to the output manager
            PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_ATM_DP) YLOM%WRITE_ATM_DP( YLATMMSG, VALUES_DP, HOOKS )

          CASE DEFAULT
            PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_VAL_TYPE )
          END SELECT
        ELSE
          PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_REPRES) IREPRES2CREPRES(A%REPRES_ID_, CREPRES, HOOKS)
          PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_ILEVTYPE) IPREFIX2ILEVTYPE( A%PREFIX_ID_,A%PARAM_ID_, A%U_ID_,A%REPRES_ID_, ILEVTYPE, HOOKS )
          PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_CLEVTYPE) ILEVTYPE2CLEVTYPE( ILEVTYPE, CLEVTYPE, HOOKS )
          WRITE(OUTPUT_UNIT,'(A,I10,I10,I10,I10,I10,I10,A4,A20,A10)',IOSTAT=WRITE_STATUS) &
&           'Atm. message:       ', A%PARAM_ID_, A%U_ID_, A%STEP_ID_, A%PROC_ID_, A%REPRES_ID_, A%PREFIX_ID_, &
&           '    ', TRIM(ADJUSTL(CREPRES)), TRIM(ADJUSTL(CLEVTYPE))
          PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
        ENDIF

      ENDIF

    ! ==============================================================================================
    CLASS IS ( TOC_WAM_FIELD_T )

      PP_TRYCALL(ERRFLAG_UNABLE_TO_MATCH_MESSAGE) MATCH( CFG, A%PARAM_ID_, A%U_ID_, A%STEP_ID_, &
&             A%PROC_ID_, A%REPRES_ID_, A%PREFIX_ID_, LMATCH, HOOKS )
      IF ( LMATCH ) THEN
        IF ( .NOT.CFG%DRYRUN ) THEN

          ! Check that the message file exist
          SELECT CASE ( A%VAL_TYPE_ )
          CASE ( VALUES_SP_E )

            ! Read the next message to be processed
            PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_WAM_MESSAGE)  READ_WAM_MESSAGE( TRIM(CFG%INPUT_DIR), A%PROC_ID_, &
&                A%MSG_ID_, A%MSG_ADDR_, YLWAMMSG, CFG%BIG_ENDIAN_READ, CFG%VERBOSE, HOOKS )

            ! Read the values
            PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VAL_SP) READ_VAL_SP( TRIM(CFG%INPUT_DIR), A%PROC_ID_, A%MSG_ID_, A%VAL_ADDR_, &
&                A%VAL_LB_, A%VAL_UB_, VALUES_SP, CFG%BIG_ENDIAN_READ, CFG%VERBOSE, HOOKS )

            ! Write data to the output manager
            PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_WAM_SP) YLOM%WRITE_WAM_SP( YLWAMMSG, VALUES_SP, HOOKS )

          CASE ( VALUES_DP_E )

            ! Read the next message to be processed
            PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_WAM_MESSAGE) READ_WAM_MESSAGE( TRIM(CFG%INPUT_DIR), A%PROC_ID_, A%MSG_ID_, &
&                A%MSG_ADDR_, YLWAMMSG, CFG%BIG_ENDIAN_READ, CFG%VERBOSE, HOOKS )

            ! Rdad the values
            PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_VAL_DP) READ_VAL_DP( TRIM(CFG%INPUT_DIR), A%PROC_ID_, A%MSG_ID_, A%VAL_ADDR_, &
&                A%VAL_LB_, A%VAL_UB_, VALUES_DP, CFG%BIG_ENDIAN_READ, CFG%VERBOSE, HOOKS )

            ! Write data to the output manager
            PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_WAM_DP) YLOM%WRITE_WAM_DP( YLWAMMSG, VALUES_DP, HOOKS )

          CASE DEFAULT
            PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_VAL_TYPE )
          END SELECT

        ELSE
          PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_REPRES) IREPRES2CREPRES(A%REPRES_ID_, CREPRES, HOOKS)
          PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_ILEVTYPE) IPREFIX2ILEVTYPE( A%PREFIX_ID_,A%PARAM_ID_, A%U_ID_,A%REPRES_ID_, ILEVTYPE, HOOKS )
          PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_CLEVTYPE) ILEVTYPE2CLEVTYPE( ILEVTYPE, CLEVTYPE, HOOKS )
          WRITE(OUTPUT_UNIT,'(A,I10,I10,I10,I10,I10,I10,A4,A20,A10)',IOSTAT=WRITE_STATUS) &
&           'Wam. message:       ', A%PARAM_ID_, A%U_ID_, A%STEP_ID_, A%PROC_ID_, A%REPRES_ID_, A%PREFIX_ID_, &
&           '    ',  TRIM(ADJUSTL(CREPRES)), TRIM(ADJUSTL(CLEVTYPE))
          PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
        ENDIF
      ENDIF

    ! ==============================================================================================
    CLASS IS ( TOC_FLUSH_STEP_T )
      IF ( .NOT.CFG%DRYRUN ) THEN
        PP_TRYCALL(ERRFLAG_UNABLE_TO_FLUSH_STEP) YLOM%FLUSH_STEP( A%STEP_, HOOKS )
      ELSE
        WRITE(OUTPUT_UNIT,'(A150)',IOSTAT=WRITE_STATUS) REPEAT('-',150)
        PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
        WRITE(OUTPUT_UNIT,'(A,I10)',IOSTAT=WRITE_STATUS) 'Flush:              ', A%STEP_
        PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
      ENDIF

    ! ==============================================================================================
    CLASS IS ( TOC_FLUSH_STEP_RST_T )
      IF ( .NOT.CFG%DRYRUN ) THEN
        PP_TRYCALL(ERRFLAG_UNABLE_TO_FLUSH_STEP_AND_RESTART) YLOM%FLUSH_STEP_AND_TRIGGER_RESTART( A%STEP_, HOOKS )
      ELSE
        WRITE(OUTPUT_UNIT,'(A150)',IOSTAT=WRITE_STATUS) REPEAT('-',150)
        PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
        WRITE(OUTPUT_UNIT,'(A,I10)',IOSTAT=WRITE_STATUS) 'Flush and restart:  ', A%STEP_
        PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
      ENDIF

    ! ==============================================================================================
    CLASS IS ( TOC_FLUSH_LAST_STEP_T )
      IF ( .NOT.CFG%DRYRUN ) THEN
        PP_TRYCALL(ERRFLAG_UNABLE_TO_LAST_STEP) YLOM%FLUSH_LAST_STEP( A%STEP_, HOOKS )
      ELSE
        WRITE(OUTPUT_UNIT,'(A150)',IOSTAT=WRITE_STATUS) REPEAT('-',150)
        PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
        WRITE(OUTPUT_UNIT,'(A,I10)',IOSTAT=WRITE_STATUS) 'Flush last step:    ', A%STEP_
        PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
      ENDIF

    ! ==============================================================================================
    CLASS IS ( TOC_SIM_END_T )
      IF ( .NOT.CFG%DRYRUN ) THEN
        PP_TRYCALL(ERRFLAG_UNABLE_TO_DESTROY_OUTPUT_MANAGER) DESTROY_OUTPUT_MANAGER( YLOM, HOOKS )
      ELSE
        WRITE(OUTPUT_UNIT,'(A150)',IOSTAT=WRITE_STATUS) REPEAT('-',150)
        PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
        WRITE(OUTPUT_UNIT,*,IOSTAT=WRITE_STATUS) 'End of simulation'
        PP_DEBUG_CRITICAL_COND_THROW( WRITE_STATUS.NE.0, ERRFLAG_UNABLE_TO_WRITE_LOG )
      ENDIF
      EXIT FeederLoop

    ! ==============================================================================================
    CLASS DEFAULT

      PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_TOC_TYPE )

    END SELECT

  ENDDO FeederLoop


  ! Free memory
  PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE_COMMAND_LINE_OPTIONS) FREE_COMMAND_LINE_OPTIONS( CFG, HOOKS )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE_TOC) TOC_FREE( TOC, HOOKS )

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  !> Exit point (on success)
  STOP 0

! Error handler
PP_ERROR_HANDLER

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_INITIALIZE_MULTIO)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to initialize multio' )
    CASE (ERRFLAG_UNABLE_TO_INIT_CMD_LINE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to initialize command line options' )
    CASE (ERRFLAG_UNABLE_TO_PARSE_CMD_LINE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to parse command line options' )
    CASE (ERRFLAG_UNABLE_TO_PRINT_CMD_LINE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to print command line options' )
    CASE (ERRFLAG_UNABLE_TO_PREPARE_OUTPUT_MANAGER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to prepare output manager' )
    CASE (ERRFLAG_UNABLE_TO_MAKE_OUTPUT_MANAGER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to make output manager' )
    CASE (ERRFLAG_UNABLE_TO_WRITE_TOC_NAME)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to write toc name' )
    CASE (ERRFLAG_UNABLE_TO_READ_TOC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read toc' )
    CASE (ERRFLAG_UNABLE_TO_READ_ALL_TOC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read all toc' )
    CASE (ERRFLAG_UNABLE_TO_CREATE_TOC_NAME)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to create toc name' )
    CASE (ERRFLAG_UNABLE_TO_WRITE_HEADER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to write header' )
    CASE (ERRFLAG_UNABLE_TO_FREE_COMMAND_LINE_OPTIONS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free command line options' )
    CASE (ERRFLAG_UNABLE_TO_FREE_TOC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free toc' )
    CASE (ERRFLAG_UNABLE_TO_WRITE_LOG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to write log' )
    CASE (ERRFLAG_UNABLE_TO_READ_ATM_MESSAGE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read atm message' )
    CASE (ERRFLAG_UNABLE_TO_READ_WAM_MESSAGE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read wam message' )
    CASE (ERRFLAG_UNABLE_TO_READ_VAL_SP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read val sp' )
    CASE (ERRFLAG_UNABLE_TO_READ_VAL_DP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read val dp' )
    CASE (ERRFLAG_UNABLE_TO_WRITE_ATM_SP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to write atm sp' )
    CASE (ERRFLAG_UNABLE_TO_WRITE_ATM_DP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to write atm dp' )
    CASE (ERRFLAG_UNKNOWN_VAL_TYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown val type' )
    CASE (ERRFLAG_UNABLE_TO_CONVERT_REPRES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert repres' )
    CASE (ERRFLAG_UNABLE_TO_CONVERT_ILEVTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert ilevtype' )
    CASE (ERRFLAG_UNABLE_TO_CONVERT_CLEVTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert clevtype' )
    CASE (ERRFLAG_UNABLE_TO_MATCH_MESSAGE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to match message' )
    CASE (ERRFLAG_UNABLE_TO_FLUSH_STEP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to flush step' )
    CASE (ERRFLAG_UNABLE_TO_FLUSH_STEP_AND_RESTART)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to flush step and restart' )
    CASE (ERRFLAG_UNABLE_TO_LAST_STEP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to last step' )
    CASE (ERRFLAG_UNABLE_TO_DESTROY_OUTPUT_MANAGER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to destroy output manager' )
    CASE (ERRFLAG_UNKNOWN_TOC_TYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown toc type' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( 6_JPIB_K )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  STOP 1


END PROGRAM MULTIOM_FEED_PROG
#undef PP_FILE_NAME
#undef PP_SECTION_TYPE
#undef PP_SECTION_NAME
#undef PP_PROCEDURE_TYPE
#undef PP_PROCEDURE_NAME
