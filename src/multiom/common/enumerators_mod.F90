! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"


#define PP_FILE_NAME 'enumerators_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'ENUMERATORS_MOD'
MODULE ENUMERATORS_MOD

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K

IMPLICIT NONE

  ! Default visibility
  PRIVATE

  ! Enumerator for options
  INTEGER(KIND=JPIB_K), PARAMETER :: OPT_CACHE_NONE_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: OPT_CACHE_INTEMEDIATE_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: OPT_CACHE_FULL_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_CACHE_OPT_E=3_JPIB_K

  ! Enumerators for paramtype
  INTEGER(KIND=JPIB_K), PARAMETER :: PARAMTYPE_CHEMICAL_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PARAMTYPE_OPTICAL_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PARAMTYPE_CHEMICAL_OPTICAL_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PARAMTYPE_BASE_E=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PARAMTYPE_WAVE_SPECTRA_E=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PARAMTYPE_TILE_E=6_JPIB_K
  ! INTEGER(KIND=JPIB_K), PARAMETER :: PARAMTYPE_AEROSOL_E=7_JPIB_K


  ! Enumerators for prefixes
  INTEGER(KIND=JPIB_K), PARAMETER :: PREFIX_MODEL_LEVEL_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PREFIX_PRESSURE_LEVEL_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PREFIX_VORTICITY_LEVEL_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PREFIX_THETA_LEVEL_E=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PREFIX_SURFACE_E=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PREFIX_WAVE_INT_E=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PREFIX_WAVE_SPEC_E=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PREFIX_HEIGHT_ABOVE_GROUND_E=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PREFIX_AL_E=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_PREFIXES=9_JPIB_K

  ! Enumerators for levType
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_HHL_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_HPL_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_HL_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_ML_E=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_O2D_E=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_O3D_E=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_PL_E=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_PT_E=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_PV_E=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_SFC_E=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_SOL_E=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_AL_E=12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_WAM_INT_E=13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: LEVTYPE_WAM_SPEC_E=14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_LEVTYPES=14_JPIB_K

  ! Enumerators for class
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_0_E=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_OD_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_RD_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_ER_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_CS_E=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_E4_E=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_DM_E=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_PV_E=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_EL_E=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_TO_E=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_CO_E=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_EN_E=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_TI_E=12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_ME_E=13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_EI_E=14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_SR_E=15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_DT_E=16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_LA_E=17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_YT_E=18_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_MC_E=19_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_PE_E=20_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_EM_E=21_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_E2_E=22_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_EA_E=23_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_EP_E=24_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_RM_E=25_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_NR_E=26_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_S2_E=27_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_J5_E=28_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_UR_E=29_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_ET_E=30_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_C3_E=31_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_YP_E=32_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_L5_E=33_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_LW_E=34_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_CE_E=35_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_CR_E=36_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_RR_E=37_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_UL_E=38_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_GW_E=39_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_E6_E=40_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_L6_E=41_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_EF_E=42_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_GF_E=43_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_GG_E=44_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_ML_E=45_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_D1_E=46_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_O6_E=47_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_EH_E=48_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_GH_E=49_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_CI_E=50_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_AI_E=51_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_ED_E=52_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_NG_E=53_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_TE_E=99_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_AT_E=100_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_BE_E=101_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_HR_E=102_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_DK_E=103_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_FI_E=104_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_FR_E=105_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_DE_E=106_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_GR_E=107_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_HU_E=108_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_IS_E=109_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_IE_E=110_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_IT_E=111_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_NL_E=112_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_NO_E=113_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_PT_E=114_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_SI_E=115_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_ES_E=116_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_SE_E=117_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_CH_E=118_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_TR_E=119_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_UK_E=120_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_MS_E=121_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: CLASS_MA_E=199_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_CLASS=78_JPIB_K


  ! Enumerators for type
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_0_E=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FG_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_AN_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_IA_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OI_E=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_3V_E=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_4V_E=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_3G_E=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_4G_E=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FC_E=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_CF_E=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_PF_E=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_EF_E=12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_EA_E=13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_CM_E=14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_CS_E=15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FP_E=16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_EM_E=17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_ES_E=18_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FA_E=19_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_CL_E=20_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_SI_E=21_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_S3_E=22_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_ED_E=23_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_TU_E=24_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FF_E=25_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_E=26_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_EFI_E=27_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_EFIC_E=28_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_PB_E=29_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_EP_E=30_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_BF_E=31_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_CD_E=32_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_4I_E=33_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_GO_E=34_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_ME_E=35_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_PD_E=36_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_CI_E=37_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_SOT_E=38_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_EME_E=39_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_IM_E=40_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_SIM_E=42_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_WEM_E=43_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_WES_E=44_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_CR_E=45_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_SES_E=46_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_TAEM_E=47_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_TAES_E=48_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_SG_E=50_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_SF_E=52_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_PA_E=60_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_ICP_E=61_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_SV_E=62_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_AS_E=63_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_SVAR_E=64_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_CV_E=65_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OR_E=70_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FX_E=71_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FU_E=72_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_SFO_E=73_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_TPA_E=74_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_IF_E=75_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FCMEAN_E=80_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FCMAX_E=81_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FCMIN_E=82_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FCSTDEV_E=83_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_HCMEAN_E=86_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_SSD_E=87_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_GSD_E=88_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_GA_E=89_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_GAI_E=90_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_GBF_E=91_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_PFC_E=92_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_PPM_E=93_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_GWT_E=94_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_EST_E=95_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_MPP_E=96_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OB_E=256_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FB_E=257_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_AI_E=258_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_AF_E=259_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_AB_E=260_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_TF_E=261_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_MFB_E=262_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OFB_E=263_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OAI_E=264_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_SFB_E=265_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FSOIFB_E=266_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_FCDFB_E=267_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_TYPE=89_JPIB_K


  ! Enumerators for stream
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_0_E=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_FSOB_E=1022_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_FSOW_E=1023_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_DAHC_E=1024_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_OPER_E=1025_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_SCDA_E=1026_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_SCWV_E=1027_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_DCDA_E=1028_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_DCWV_E=1029_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_ENDA_E=1030_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EFHO_E=1032_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_ENFH_E=1033_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EFOV_E=1034_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_ENFO_E=1035_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_SENS_E=1036_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MAED_E=1037_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_AMAP_E=1038_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EFHC_E=1039_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EFHS_E=1040_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_TOGA_E=1041_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_CHER_E=1042_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MNTH_E=1043_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_SUPD_E=1044_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WAVE_E=1045_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_OCEA_E=1046_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_FGGE_E=1047_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EGRR_E=1050_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_KWBC_E=1051_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EDZW_E=1052_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_LFPW_E=1053_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_RJTD_E=1054_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_CWAO_E=1055_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_AMMC_E=1056_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EFAS_E=1057_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EFSE_E=1058_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EFCL_E=1059_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WFAS_E=1060_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WFCL_E=1061_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WFSE_E=1062_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EFRF_E=1063_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EFSR_E=1064_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WFRF_E=1065_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WFSR_E=1066_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MSDC_E=1070_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MODA_E=1071_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MONR_E=1072_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MNVR_E=1073_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MSDA_E=1074_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MDFA_E=1075_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_DACL_E=1076_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WEHS_E=1077_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EWHO_E=1078_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_ENWH_E=1079_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WAMO_E=1080_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WAEF_E=1081_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WASF_E=1082_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MAWV_E=1083_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EWHC_E=1084_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WVHC_E=1085_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WEOV_E=1086_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WAVM_E=1087_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EWDA_E=1088_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_DACW_E=1089_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_SEAS_E=1090_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_SFMM_E=1091_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_SWMM_E=1092_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MOFC_E=1093_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MOFM_E=1094_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WAMF_E=1095_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WMFM_E=1096_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_SMMA_E=1097_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_CLTE_E=1098_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_CLMN_E=1099_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_DAME_E=1100_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_SEAP_E=1110_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EEFH_E=1120_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EEHS_E=1121_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EEFO_E=1122_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WEEF_E=1123_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WEEH_E=1124_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WEES_E=1125_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MNFC_E=1200_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MNFH_E=1201_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MNFA_E=1202_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MNFW_E=1203_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MFHW_E=1204_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MFAW_E=1205_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MNFM_E=1206_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MFHM_E=1207_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MFAM_E=1208_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MFWM_E=1209_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MHWM_E=1210_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MAWM_E=1211_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MMSF_E=1220_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MSMM_E=1221_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WAMS_E=1222_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MSWM_E=1223_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MMSA_E=1224_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MMAF_E=1230_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MMAM_E=1231_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MMAW_E=1232_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MMWM_E=1233_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_ESMM_E=1240_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EHMM_E=1241_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EDMM_E=1242_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EDMO_E=1243_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EWMO_E=1244_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EWMM_E=1245_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_ESPD_E=1246_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_LWDA_E=1247_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_LWWV_E=1248_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_ELDA_E=1249_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_EWLA_E=1250_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_WAMD_E=1251_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_GFAS_E=1252_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_OCDA_E=1253_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_OLDA_E=1254_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_GFRA_E=1255_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_RFSD_E=1256_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_CNRM_E=2231_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_MPIC_E=2232_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: STREAM_UKMO_E=2233_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_STREAM=122_JPIB_K


  ! Enumerators for representations
  INTEGER(KIND=JPIB_K), PARAMETER :: REPRES_GAUSSIANGRID_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: REPRES_SPHERICALHARMONICS_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: REPRES_LATLONG_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_REPRES=3_JPIB_K

  ! Enumerators for models
  INTEGER(KIND=JPIB_K), PARAMETER :: MODEL_ATMOSPHERE_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: MODEL_OCEAN_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: MODEL_WAVE_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_MODELS=3_JPIB_K

  ! Enumerators for precision
  INTEGER(KIND=JPIB_K), PARAMETER :: PRECISION_SP_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PRECISION_DP_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_PRECISIONS=2_JPIB_K

  ! Grib editions
  INTEGER(KIND=JPIB_K), PARAMETER :: EDITION_GRIB1_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: EDITION_GRIB2_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_EDITIONS=2_JPIB_K

  ! Enumerators for packing type
  INTEGER(KIND=JPIB_K), PARAMETER :: PACKING_GRIB_SIMPLE_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PACKING_GRIB_CCSDS_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PACKING_GRIB_COMPLEX_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_PACKING=3_JPIB_K

  ! Enumerators for type of statisticsal process
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_INSTANT_E=-1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_AVERAGE_E=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_ACCUMUL_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_MAX_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_MIN_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_DIFF_FWD_E=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_RMS_E=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_STDDEV_E=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_COV_E=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_DIFF_BWD_E=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_RATIO_E=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_STD_ANOMALY_E=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_SUMMATION_E=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_SEVERITY_E=100_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_MODE_E=101_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_STATISTICAL_PROCESS_MISSING_E=255_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_TYPE_OF_STATISTICAL_PROCESS=16_JPIB_K

  ! Enumeators for type of time range
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_TIME_RANGE_INSTANT_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_TIME_RANGE_FROM_STEP0_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_TIME_RANGE_FROM_LASTPP_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: TYPE_OF_TIME_RANGE_FIXED_SIZE_E=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_TYPE_OF_TIME_RANGE=4_JPIB_K

  !> Enumerators for the integer filters to be used in filtering operations
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_INT_MATCH_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_INT_IGNORE_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_INT_GT_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_INT_GE_E=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_INT_LT_E=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_INT_LE_E=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_INT_HAS_E=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_INT_LACKS_E=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_FLT_INT=8_JPIB_K

  !> Enumerators for the operations between filters defined in this module
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_COMPOSE_ALL_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_COMPOSE_ANY_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_COMPOSE_NONE_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLT_COMPOSE_ONE_E=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_FLT_COMPOSE=4_JPIB_K

  !> Enumerators for origin/centre
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_AMMC=1_JPIB_K         ! Melbourne (WMC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_RUMS=4_JPIB_K         ! Moscow (WMC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_KWBC=7_JPIB_K         ! US National Weather Service - NCEP (WMC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_FAPR=24_JPIB_K        ! Pretoria (RSMC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_VABB=28_JPIB_K        ! New Delhi (IMD)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_DEMS=29_JPIB_K        ! New Delhi (NCMRWF)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_RJTD=34_JPIB_K        ! Japanese Meteorological Agency - Tokyo (RSMC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_BABJ=38_JPIB_K        ! Beijing (RSMC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_RKSL=40_JPIB_K        ! Seoul
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_SABM=41_JPIB_K        ! Buenos Aires (RSMC/RAFC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_SBSJ=46_JPIB_K        ! Brasilian Space Agency - INPE
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_CWAO=54_JPIB_K        ! Canadian Meteorological Service - Montreal (RSMC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_FNMO=58_JPIB_K        ! US Navy - Fleet Numerical Oceanography Center
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_NZKL=69_JPIB_K        ! Wellington (RSMC/RAFC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_EGRR=74_JPIB_K        ! U.K. Met Office - Exeter
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_EDZW=78_JPIB_K        ! Offenbach (RSMC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_CNMC=80_JPIB_K        ! Rome (RSMC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_ESWI=82_JPIB_K        ! Norrkoping
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_LFPW=84_JPIB_K        ! French Weather Service - Toulouse
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_LFPW_2=85_JPIB_K        ! French Weather Service - Toulouse
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_EFKL=86_JPIB_K        ! Helsinki
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_ENMI=88_JPIB_K        ! Oslo
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_EKMI=94_JPIB_K        ! Copenhagen
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_ECMF=98_JPIB_K        ! European Centre for Medium-Range Weather Forecasts
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_KNMI=99_JPIB_K        ! DeBilt, Netherlands
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_NASA=173_JPIB_K       ! US National Aeronautics and Space Administration (NASA)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_WIIX=195_JPIB_K       ! Indonesia (NMC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_NIWA=204_JPIB_K       ! National Institute of Water and Atmospheric Research (NIWA - New Zealand)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_BIRK=213_JPIB_K       ! Reykjavik
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_LEMM=214_JPIB_K       ! INM Madrid
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_LSSW=215_JPIB_K       ! Zurich
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_HABP=218_JPIB_K       ! Budapest
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_LOWM=224_JPIB_K       ! Austria
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_EBUM=227_JPIB_K       ! Belgium (NMC)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_EIDB=233_JPIB_K       ! Dublin
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_INGV=235_JPIB_K       ! INGV
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_CRFC=239_JPIB_K       ! CERFAX
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_COSMO=250_JPIB_K      ! COnsortium for Small scale MOdelling (COSMO)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_MPIM=252_JPIB_K       ! Max Planck Institute for Meteorology (MPI-M)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_EUMS=254_JPIB_K       ! EUMETSAT Operation Centre
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_CONSENSUS=255_JPIB_K  ! Consensus
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_ANSO=291_JPIB_K       ! Alliance of International Science Organizations (Beijing, China)
  INTEGER(kind=JPIB_K), PARAMETER :: ORIGIN_UFZ=292_JPIB_K        ! Helmholtz Centre for Environmental Research





  !> Binary operations for integer operations
  INTEGER(KIND=JPIB_K), PARAMETER :: INTOP_UNARY_NEG_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_INTOP_UNARY=2_JPIB_K

  !> Binary operations for integer operations
  INTEGER(KIND=JPIB_K), PARAMETER :: INTOP_BINARY_MUL_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: INTOP_BINARY_DIV_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: INTOP_BINARY_SUM_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: INTOP_BINARY_SUB_E=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: INTOP_BINARY_POW_E=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: INTOP_BINARY_MOD_E=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_INTOP_BINARY=6_JPIB_K


  !> Binary operations for integer operations
  INTEGER(KIND=JPIB_K), PARAMETER :: INTOP_FUNCTION_CALL_ABS_E =1001_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: INTOP_FUNCTION_CALL_SIGN_E =2001_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: INTOP_FUNCTION_CALL_STEPL_E=3001_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: INTOP_FUNCTION_CALL_STEPR_E=4001_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_INTOP_FUNCTION_CALL=3_JPIB_K





  !> Binary operations for integer operations
  INTEGER(KIND=JPIB_K), PARAMETER :: FLOATOP_UNARY_NEG_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_FLOATOP_UNARY=2_JPIB_K

  !> Binary operations for integer operations
  INTEGER(KIND=JPIB_K), PARAMETER :: FLOATOP_BINARY_MUL_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLOATOP_BINARY_DIV_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLOATOP_BINARY_SUM_E=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLOATOP_BINARY_SUB_E=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLOATOP_BINARY_POW_E=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLOATOP_BINARY_MOD_E=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_FLOATOP_BINARY=6_JPIB_K


  !> Binary operations for integer operations
  INTEGER(KIND=JPIB_K), PARAMETER :: FLOATOP_FUNCTION_CALL_ABS_E =1001_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLOATOP_FUNCTION_CALL_SIGN_E =2001_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLOATOP_FUNCTION_CALL_STEPL_E=3001_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: FLOATOP_FUNCTION_CALL_STEPR_E=4001_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_FLOATOP_FUNCTION_CALL=3_JPIB_K

  !> Data structures
  INTEGER(KIND=JPIB_K), PARAMETER :: FORTRAN_MESSAGE_SOURCE_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: PARAMETRIZATION_SOURCE_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_DATA_STRUCTURES=2_JPIB_K

  ! Undefined parameters
  INTEGER(KIND=JPIB_K), PARAMETER :: UNDEF_PARAM_E=-999999999_JPIB_K

  ! Enumerators for the type of the interfaces
  INTEGER(KIND=JPIB_K), PARAMETER :: ATM_MSG_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: WAM_MSG_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: N_INTERFACES=2_JPIB_K


  ! Enumerators for the type of the interfaces
  INTEGER(KIND=JPIB_K), PARAMETER :: VALUES_SP_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: VALUES_DP_E=2_JPIB_K

  ! Sink types
  INTEGER(KIND=JPIB_K), PARAMETER :: SINK_NONE_E=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: SINK_MESSAGE_TO_FILE_E=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: SINK_MESSAGE_TO_FDB_E=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: SINK_GRIB_HEADER_TO_MULTIO_E=3_JPIB_K

  !>
  !>
  !>  Whitelist of public symbols (parameters)

  ! Precision enumerators
  PUBLIC :: VALUES_SP_E
  PUBLIC :: VALUES_DP_E


  ! Cache options
  PUBLIC :: OPT_CACHE_NONE_E
  PUBLIC :: OPT_CACHE_INTEMEDIATE_E
  PUBLIC :: OPT_CACHE_FULL_E
  PUBLIC :: N_CACHE_OPT_E


  ! Enumerators for paramtypes
  PUBLIC :: PARAMTYPE_CHEMICAL_E
  PUBLIC :: PARAMTYPE_OPTICAL_E
  PUBLIC :: PARAMTYPE_CHEMICAL_OPTICAL_E
  PUBLIC :: PARAMTYPE_BASE_E
  PUBLIC :: PARAMTYPE_WAVE_SPECTRA_E
  PUBLIC :: PARAMTYPE_TILE_E
  ! PUBLIC :: PARAMTYPE_AEROSOL_E

  ! Enumerators for prefixes
  PUBLIC :: PREFIX_MODEL_LEVEL_E
  PUBLIC :: PREFIX_PRESSURE_LEVEL_E
  PUBLIC :: PREFIX_VORTICITY_LEVEL_E
  PUBLIC :: PREFIX_THETA_LEVEL_E
  PUBLIC :: PREFIX_SURFACE_E
  PUBLIC :: PREFIX_WAVE_INT_E
  PUBLIC :: PREFIX_WAVE_SPEC_E
  PUBLIC :: PREFIX_HEIGHT_ABOVE_GROUND_E
  PUBLIC :: PREFIX_AL_E
  PUBLIC :: N_PREFIXES

  ! Enumerators for levType
  PUBLIC :: LEVTYPE_HHL_E
  PUBLIC :: LEVTYPE_HPL_E
  PUBLIC :: LEVTYPE_HL_E
  PUBLIC :: LEVTYPE_ML_E
  PUBLIC :: LEVTYPE_O2D_E
  PUBLIC :: LEVTYPE_O3D_E
  PUBLIC :: LEVTYPE_PL_E
  PUBLIC :: LEVTYPE_PT_E
  PUBLIC :: LEVTYPE_PV_E
  PUBLIC :: LEVTYPE_SFC_E
  PUBLIC :: LEVTYPE_SOL_E
  PUBLIC :: LEVTYPE_AL_E
  PUBLIC :: LEVTYPE_WAM_INT_E
  PUBLIC :: LEVTYPE_WAM_SPEC_E
  PUBLIC :: N_LEVTYPES

  ! Enumerators for class
  PUBLIC :: CLASS_0_E
  PUBLIC :: CLASS_OD_E
  PUBLIC :: CLASS_RD_E
  PUBLIC :: CLASS_ER_E
  PUBLIC :: CLASS_CS_E
  PUBLIC :: CLASS_E4_E
  PUBLIC :: CLASS_DM_E
  PUBLIC :: CLASS_PV_E
  PUBLIC :: CLASS_EL_E
  PUBLIC :: CLASS_TO_E
  PUBLIC :: CLASS_CO_E
  PUBLIC :: CLASS_EN_E
  PUBLIC :: CLASS_TI_E
  PUBLIC :: CLASS_ME_E
  PUBLIC :: CLASS_EI_E
  PUBLIC :: CLASS_SR_E
  PUBLIC :: CLASS_DT_E
  PUBLIC :: CLASS_LA_E
  PUBLIC :: CLASS_YT_E
  PUBLIC :: CLASS_MC_E
  PUBLIC :: CLASS_PE_E
  PUBLIC :: CLASS_EM_E
  PUBLIC :: CLASS_E2_E
  PUBLIC :: CLASS_EA_E
  PUBLIC :: CLASS_EP_E
  PUBLIC :: CLASS_RM_E
  PUBLIC :: CLASS_NR_E
  PUBLIC :: CLASS_S2_E
  PUBLIC :: CLASS_J5_E
  PUBLIC :: CLASS_UR_E
  PUBLIC :: CLASS_ET_E
  PUBLIC :: CLASS_C3_E
  PUBLIC :: CLASS_YP_E
  PUBLIC :: CLASS_L5_E
  PUBLIC :: CLASS_LW_E
  PUBLIC :: CLASS_CE_E
  PUBLIC :: CLASS_CR_E
  PUBLIC :: CLASS_RR_E
  PUBLIC :: CLASS_UL_E
  PUBLIC :: CLASS_GW_E
  PUBLIC :: CLASS_E6_E
  PUBLIC :: CLASS_L6_E
  PUBLIC :: CLASS_EF_E
  PUBLIC :: CLASS_GF_E
  PUBLIC :: CLASS_GG_E
  PUBLIC :: CLASS_ML_E
  PUBLIC :: CLASS_D1_E
  PUBLIC :: CLASS_O6_E
  PUBLIC :: CLASS_EH_E
  PUBLIC :: CLASS_GH_E
  PUBLIC :: CLASS_CI_E
  PUBLIC :: CLASS_AI_E
  PUBLIC :: CLASS_ED_E
  PUBLIC :: CLASS_NG_E
  PUBLIC :: CLASS_TE_E
  PUBLIC :: CLASS_AT_E
  PUBLIC :: CLASS_BE_E
  PUBLIC :: CLASS_HR_E
  PUBLIC :: CLASS_DK_E
  PUBLIC :: CLASS_FI_E
  PUBLIC :: CLASS_FR_E
  PUBLIC :: CLASS_DE_E
  PUBLIC :: CLASS_GR_E
  PUBLIC :: CLASS_HU_E
  PUBLIC :: CLASS_IS_E
  PUBLIC :: CLASS_IE_E
  PUBLIC :: CLASS_IT_E
  PUBLIC :: CLASS_NL_E
  PUBLIC :: CLASS_NO_E
  PUBLIC :: CLASS_PT_E
  PUBLIC :: CLASS_SI_E
  PUBLIC :: CLASS_ES_E
  PUBLIC :: CLASS_SE_E
  PUBLIC :: CLASS_CH_E
  PUBLIC :: CLASS_TR_E
  PUBLIC :: CLASS_UK_E
  PUBLIC :: CLASS_MS_E
  PUBLIC :: CLASS_MA_E
  PUBLIC :: N_CLASS

  ! Enumerators for type
   PUBLIC :: TYPE_0_E
  PUBLIC :: TYPE_FG_E
  PUBLIC :: TYPE_AN_E
  PUBLIC :: TYPE_IA_E
  PUBLIC :: TYPE_OI_E
  PUBLIC :: TYPE_3V_E
  PUBLIC :: TYPE_4V_E
  PUBLIC :: TYPE_3G_E
  PUBLIC :: TYPE_4G_E
  PUBLIC :: TYPE_FC_E
  PUBLIC :: TYPE_CF_E
  PUBLIC :: TYPE_PF_E
  PUBLIC :: TYPE_EF_E
  PUBLIC :: TYPE_EA_E
  PUBLIC :: TYPE_CM_E
  PUBLIC :: TYPE_CS_E
  PUBLIC :: TYPE_FP_E
  PUBLIC :: TYPE_EM_E
  PUBLIC :: TYPE_ES_E
  PUBLIC :: TYPE_FA_E
  PUBLIC :: TYPE_CL_E
  PUBLIC :: TYPE_SI_E
  PUBLIC :: TYPE_S3_E
  PUBLIC :: TYPE_ED_E
  PUBLIC :: TYPE_TU_E
  PUBLIC :: TYPE_FF_E
  PUBLIC :: TYPE_OF_E
  PUBLIC :: TYPE_EFI_E
  PUBLIC :: TYPE_EFIC_E
  PUBLIC :: TYPE_PB_E
  PUBLIC :: TYPE_EP_E
  PUBLIC :: TYPE_BF_E
  PUBLIC :: TYPE_CD_E
  PUBLIC :: TYPE_4I_E
  PUBLIC :: TYPE_GO_E
  PUBLIC :: TYPE_ME_E
  PUBLIC :: TYPE_PD_E
  PUBLIC :: TYPE_CI_E
  PUBLIC :: TYPE_SOT_E
  PUBLIC :: TYPE_EME_E
  PUBLIC :: TYPE_IM_E
  PUBLIC :: TYPE_SIM_E
  PUBLIC :: TYPE_WEM_E
  PUBLIC :: TYPE_WES_E
  PUBLIC :: TYPE_CR_E
  PUBLIC :: TYPE_SES_E
  PUBLIC :: TYPE_TAEM_E
  PUBLIC :: TYPE_TAES_E
  PUBLIC :: TYPE_SG_E
  PUBLIC :: TYPE_SF_E
  PUBLIC :: TYPE_PA_E
  PUBLIC :: TYPE_ICP_E
  PUBLIC :: TYPE_SV_E
  PUBLIC :: TYPE_AS_E
  PUBLIC :: TYPE_SVAR_E
  PUBLIC :: TYPE_CV_E
  PUBLIC :: TYPE_OR_E
  PUBLIC :: TYPE_FX_E
  PUBLIC :: TYPE_FU_E
  PUBLIC :: TYPE_SFO_E
  PUBLIC :: TYPE_TPA_E
  PUBLIC :: TYPE_IF_E
  PUBLIC :: TYPE_FCMEAN_E
  PUBLIC :: TYPE_FCMAX_E
  PUBLIC :: TYPE_FCMIN_E
  PUBLIC :: TYPE_FCSTDEV_E
  PUBLIC :: TYPE_HCMEAN_E
  PUBLIC :: TYPE_SSD_E
  PUBLIC :: TYPE_GSD_E
  PUBLIC :: TYPE_GA_E
  PUBLIC :: TYPE_GAI_E
  PUBLIC :: TYPE_GBF_E
  PUBLIC :: TYPE_PFC_E
  PUBLIC :: TYPE_PPM_E
  PUBLIC :: TYPE_GWT_E
  PUBLIC :: TYPE_EST_E
  PUBLIC :: TYPE_MPP_E
  PUBLIC :: TYPE_OB_E
  PUBLIC :: TYPE_FB_E
  PUBLIC :: TYPE_AI_E
  PUBLIC :: TYPE_AF_E
  PUBLIC :: TYPE_AB_E
  PUBLIC :: TYPE_TF_E
  PUBLIC :: TYPE_MFB_E
  PUBLIC :: TYPE_OFB_E
  PUBLIC :: TYPE_OAI_E
  PUBLIC :: TYPE_SFB_E
  PUBLIC :: TYPE_FSOIFB_E
  PUBLIC :: TYPE_FCDFB_E
  PUBLIC :: N_TYPE


  ! Enumerators for stream
  PUBLIC :: STREAM_0_E
  PUBLIC :: STREAM_FSOB_E
  PUBLIC :: STREAM_FSOW_E
  PUBLIC :: STREAM_DAHC_E
  PUBLIC :: STREAM_OPER_E
  PUBLIC :: STREAM_SCDA_E
  PUBLIC :: STREAM_SCWV_E
  PUBLIC :: STREAM_DCDA_E
  PUBLIC :: STREAM_DCWV_E
  PUBLIC :: STREAM_ENDA_E
  PUBLIC :: STREAM_EFHO_E
  PUBLIC :: STREAM_ENFH_E
  PUBLIC :: STREAM_EFOV_E
  PUBLIC :: STREAM_ENFO_E
  PUBLIC :: STREAM_SENS_E
  PUBLIC :: STREAM_MAED_E
  PUBLIC :: STREAM_AMAP_E
  PUBLIC :: STREAM_EFHC_E
  PUBLIC :: STREAM_EFHS_E
  PUBLIC :: STREAM_TOGA_E
  PUBLIC :: STREAM_CHER_E
  PUBLIC :: STREAM_MNTH_E
  PUBLIC :: STREAM_SUPD_E
  PUBLIC :: STREAM_WAVE_E
  PUBLIC :: STREAM_OCEA_E
  PUBLIC :: STREAM_FGGE_E
  PUBLIC :: STREAM_EGRR_E
  PUBLIC :: STREAM_KWBC_E
  PUBLIC :: STREAM_EDZW_E
  PUBLIC :: STREAM_LFPW_E
  PUBLIC :: STREAM_RJTD_E
  PUBLIC :: STREAM_CWAO_E
  PUBLIC :: STREAM_AMMC_E
  PUBLIC :: STREAM_EFAS_E
  PUBLIC :: STREAM_EFSE_E
  PUBLIC :: STREAM_EFCL_E
  PUBLIC :: STREAM_WFAS_E
  PUBLIC :: STREAM_WFCL_E
  PUBLIC :: STREAM_WFSE_E
  PUBLIC :: STREAM_EFRF_E
  PUBLIC :: STREAM_EFSR_E
  PUBLIC :: STREAM_WFRF_E
  PUBLIC :: STREAM_WFSR_E
  PUBLIC :: STREAM_MSDC_E
  PUBLIC :: STREAM_MODA_E
  PUBLIC :: STREAM_MONR_E
  PUBLIC :: STREAM_MNVR_E
  PUBLIC :: STREAM_MSDA_E
  PUBLIC :: STREAM_MDFA_E
  PUBLIC :: STREAM_DACL_E
  PUBLIC :: STREAM_WEHS_E
  PUBLIC :: STREAM_EWHO_E
  PUBLIC :: STREAM_ENWH_E
  PUBLIC :: STREAM_WAMO_E
  PUBLIC :: STREAM_WAEF_E
  PUBLIC :: STREAM_WASF_E
  PUBLIC :: STREAM_MAWV_E
  PUBLIC :: STREAM_EWHC_E
  PUBLIC :: STREAM_WVHC_E
  PUBLIC :: STREAM_WEOV_E
  PUBLIC :: STREAM_WAVM_E
  PUBLIC :: STREAM_EWDA_E
  PUBLIC :: STREAM_DACW_E
  PUBLIC :: STREAM_SEAS_E
  PUBLIC :: STREAM_SFMM_E
  PUBLIC :: STREAM_SWMM_E
  PUBLIC :: STREAM_MOFC_E
  PUBLIC :: STREAM_MOFM_E
  PUBLIC :: STREAM_WAMF_E
  PUBLIC :: STREAM_WMFM_E
  PUBLIC :: STREAM_SMMA_E
  PUBLIC :: STREAM_CLTE_E
  PUBLIC :: STREAM_CLMN_E
  PUBLIC :: STREAM_DAME_E
  PUBLIC :: STREAM_SEAP_E
  PUBLIC :: STREAM_EEFH_E
  PUBLIC :: STREAM_EEHS_E
  PUBLIC :: STREAM_EEFO_E
  PUBLIC :: STREAM_WEEF_E
  PUBLIC :: STREAM_WEEH_E
  PUBLIC :: STREAM_WEES_E
  PUBLIC :: STREAM_MNFC_E
  PUBLIC :: STREAM_MNFH_E
  PUBLIC :: STREAM_MNFA_E
  PUBLIC :: STREAM_MNFW_E
  PUBLIC :: STREAM_MFHW_E
  PUBLIC :: STREAM_MFAW_E
  PUBLIC :: STREAM_MNFM_E
  PUBLIC :: STREAM_MFHM_E
  PUBLIC :: STREAM_MFAM_E
  PUBLIC :: STREAM_MFWM_E
  PUBLIC :: STREAM_MHWM_E
  PUBLIC :: STREAM_MAWM_E
  PUBLIC :: STREAM_MMSF_E
  PUBLIC :: STREAM_MSMM_E
  PUBLIC :: STREAM_WAMS_E
  PUBLIC :: STREAM_MSWM_E
  PUBLIC :: STREAM_MMSA_E
  PUBLIC :: STREAM_MMAF_E
  PUBLIC :: STREAM_MMAM_E
  PUBLIC :: STREAM_MMAW_E
  PUBLIC :: STREAM_MMWM_E
  PUBLIC :: STREAM_ESMM_E
  PUBLIC :: STREAM_EHMM_E
  PUBLIC :: STREAM_EDMM_E
  PUBLIC :: STREAM_EDMO_E
  PUBLIC :: STREAM_EWMO_E
  PUBLIC :: STREAM_EWMM_E
  PUBLIC :: STREAM_ESPD_E
  PUBLIC :: STREAM_LWDA_E
  PUBLIC :: STREAM_LWWV_E
  PUBLIC :: STREAM_ELDA_E
  PUBLIC :: STREAM_EWLA_E
  PUBLIC :: STREAM_WAMD_E
  PUBLIC :: STREAM_GFAS_E
  PUBLIC :: STREAM_OCDA_E
  PUBLIC :: STREAM_OLDA_E
  PUBLIC :: STREAM_GFRA_E
  PUBLIC :: STREAM_RFSD_E
  PUBLIC :: STREAM_CNRM_E
  PUBLIC :: STREAM_MPIC_E
  PUBLIC :: STREAM_UKMO_E
  PUBLIC :: N_STREAM


  ! Enumerators for representations
  PUBLIC :: REPRES_LATLONG_E
  PUBLIC :: REPRES_GAUSSIANGRID_E
  PUBLIC :: REPRES_SPHERICALHARMONICS_E
  PUBLIC :: N_REPRES

  ! Enumerators for models
  PUBLIC :: MODEL_ATMOSPHERE_E
  PUBLIC :: MODEL_OCEAN_E
  PUBLIC :: MODEL_WAVE_E
  PUBLIC :: N_MODELS

  ! Enumerators for precision
  PUBLIC :: PRECISION_SP_E
  PUBLIC :: PRECISION_DP_E
  PUBLIC :: N_PRECISIONS

  ! Grib editions
  PUBLIC :: EDITION_GRIB1_E
  PUBLIC :: EDITION_GRIB2_E
  PUBLIC :: N_EDITIONS

  ! Enumerators for packing type
  PUBLIC :: PACKING_GRIB_SIMPLE_E
  PUBLIC :: PACKING_GRIB_CCSDS_E
  PUBLIC :: PACKING_GRIB_COMPLEX_E
  PUBLIC :: N_PACKING


  ! Enumerators for type of statisticsal process
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_INSTANT_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_AVERAGE_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_ACCUMUL_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_MAX_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_MIN_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_DIFF_FWD_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_RMS_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_STDDEV_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_COV_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_DIFF_BWD_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_RATIO_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_STD_ANOMALY_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_SUMMATION_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_SEVERITY_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_MODE_E
  PUBLIC :: TYPE_OF_STATISTICAL_PROCESS_MISSING_E
  PUBLIC :: N_TYPE_OF_STATISTICAL_PROCESS

  ! Enumeators for type of time range
  PUBLIC :: TYPE_OF_TIME_RANGE_INSTANT_E
  PUBLIC :: TYPE_OF_TIME_RANGE_FROM_STEP0_E
  PUBLIC :: TYPE_OF_TIME_RANGE_FROM_LASTPP_E
  PUBLIC :: TYPE_OF_TIME_RANGE_FIXED_SIZE_E
  PUBLIC :: N_TYPE_OF_TIME_RANGE

  ! Enumerators for origin/centre
  PUBLIC :: ORIGIN_AMMC
  PUBLIC :: ORIGIN_RUMS
  PUBLIC :: ORIGIN_KWBC
  PUBLIC :: ORIGIN_FAPR
  PUBLIC :: ORIGIN_VABB
  PUBLIC :: ORIGIN_DEMS
  PUBLIC :: ORIGIN_RJTD
  PUBLIC :: ORIGIN_BABJ
  PUBLIC :: ORIGIN_RKSL
  PUBLIC :: ORIGIN_SABM
  PUBLIC :: ORIGIN_SBSJ
  PUBLIC :: ORIGIN_CWAO
  PUBLIC :: ORIGIN_FNMO
  PUBLIC :: ORIGIN_NZKL
  PUBLIC :: ORIGIN_EGRR
  PUBLIC :: ORIGIN_EDZW
  PUBLIC :: ORIGIN_CNMC
  PUBLIC :: ORIGIN_ESWI
  PUBLIC :: ORIGIN_LFPW
  PUBLIC :: ORIGIN_LFPW_2
  PUBLIC :: ORIGIN_EFKL
  PUBLIC :: ORIGIN_ENMI
  PUBLIC :: ORIGIN_EKMI
  PUBLIC :: ORIGIN_ECMF
  PUBLIC :: ORIGIN_KNMI
  PUBLIC :: ORIGIN_NASA
  PUBLIC :: ORIGIN_WIIX
  PUBLIC :: ORIGIN_NIWA
  PUBLIC :: ORIGIN_BIRK
  PUBLIC :: ORIGIN_LEMM
  PUBLIC :: ORIGIN_LSSW
  PUBLIC :: ORIGIN_HABP
  PUBLIC :: ORIGIN_LOWM
  PUBLIC :: ORIGIN_EBUM
  PUBLIC :: ORIGIN_EIDB
  PUBLIC :: ORIGIN_INGV
  PUBLIC :: ORIGIN_CRFC
  PUBLIC :: ORIGIN_COSMO
  PUBLIC :: ORIGIN_MPIM
  PUBLIC :: ORIGIN_EUMS
  PUBLIC :: ORIGIN_CONSENSUS
  PUBLIC :: ORIGIN_ANSO
  PUBLIC :: ORIGIN_UFZ

  ! Enumerators for the integer filters to be used in filtering operations
  PUBLIC :: FLT_INT_MATCH_E
  PUBLIC :: FLT_INT_IGNORE_E
  PUBLIC :: FLT_INT_GT_E
  PUBLIC :: FLT_INT_GE_E
  PUBLIC :: FLT_INT_LT_E
  PUBLIC :: FLT_INT_LE_E
  PUBLIC :: FLT_INT_HAS_E
  PUBLIC :: FLT_INT_LACKS_E
  PUBLIC :: N_FLT_INT

  ! Enumerators for the operations between filters defined in this module
  PUBLIC :: FLT_COMPOSE_ALL_E
  PUBLIC :: FLT_COMPOSE_ANY_E
  PUBLIC :: FLT_COMPOSE_NONE_E
  PUBLIC :: FLT_COMPOSE_ONE_E
  PUBLIC :: N_FLT_COMPOSE

  ! Integer binary operation
  PUBLIC :: INTOP_BINARY_MUL_E
  PUBLIC :: INTOP_BINARY_DIV_E
  PUBLIC :: INTOP_BINARY_SUM_E
  PUBLIC :: INTOP_BINARY_SUB_E
  PUBLIC :: INTOP_BINARY_POW_E
  PUBLIC :: INTOP_BINARY_MOD_E
  PUBLIC :: N_INTOP_BINARY

  ! Integer unary operation
  PUBLIC :: INTOP_UNARY_NEG_E
  PUBLIC :: N_INTOP_UNARY

  ! Integer function call
  PUBLIC :: INTOP_FUNCTION_CALL_ABS_E
  PUBLIC :: INTOP_FUNCTION_CALL_SIGN_E
  PUBLIC :: INTOP_FUNCTION_CALL_STEPL_E
  PUBLIC :: INTOP_FUNCTION_CALL_STEPR_E
  PUBLIC :: N_INTOP_FUNCTION_CALL

 ! Integer binary operation
  PUBLIC :: FLOATOP_BINARY_MUL_E
  PUBLIC :: FLOATOP_BINARY_DIV_E
  PUBLIC :: FLOATOP_BINARY_SUM_E
  PUBLIC :: FLOATOP_BINARY_SUB_E
  PUBLIC :: FLOATOP_BINARY_POW_E
  PUBLIC :: FLOATOP_BINARY_MOD_E
  PUBLIC :: N_FLOATOP_BINARY

  ! Integer unary operation
  PUBLIC :: FLOATOP_UNARY_NEG_E
  PUBLIC :: N_FLOATOP_UNARY

  ! Integer function call
  PUBLIC :: FLOATOP_FUNCTION_CALL_ABS_E
  PUBLIC :: FLOATOP_FUNCTION_CALL_SIGN_E
  PUBLIC :: FLOATOP_FUNCTION_CALL_STEPL_E
  PUBLIC :: FLOATOP_FUNCTION_CALL_STEPR_E
  PUBLIC :: N_FLOATOP_FUNCTION_CALL


  !> Data structures
  PUBLIC :: FORTRAN_MESSAGE_SOURCE_E
  PUBLIC :: PARAMETRIZATION_SOURCE_E
  PUBLIC :: N_DATA_STRUCTURES

  ! Undefined parameters
  PUBLIC :: UNDEF_PARAM_E

  ! Interfaces with ifs
  PUBLIC :: ATM_MSG_E
  PUBLIC :: WAM_MSG_E
  PUBLIC :: N_INTERFACES

  !>  Whitelist of public symbols (procedures)
  PUBLIC :: IPREFIX2CPREFIX
  PUBLIC :: CPREFIX2IPREFIX
  PUBLIC :: ILEVTYPE2CLEVTYPE
  PUBLIC :: CLEVTYPE2ILEVTYPE
  PUBLIC :: IREPRES2CREPRES
  PUBLIC :: CREPRES2IREPRES
  PUBLIC :: IMODEL2CMODEL
  PUBLIC :: CMODEL2IMODEL
  PUBLIC :: IPRECISION2CPRECISION
  PUBLIC :: CPRECISION2IPRECISION
  PUBLIC :: IEDITION2CEDITION
  PUBLIC :: CEDITION2IEDITION
  PUBLIC :: IPACKING2CPACKING
  PUBLIC :: CPACKING2IPACKING
  PUBLIC :: ITYPE_OF_STATISTICAL_PROCESS2CTYPE_OF_STATISTICAL_PROCESS
  PUBLIC :: CTYPE_OF_STATISTICAL_PROCESS2ITYPE_OF_STATISTICAL_PROCESS
  PUBLIC :: ITYPE_OF_TIME_RANGE2CTYPE_OF_TIME_RANGE
  PUBLIC :: CTYPE_OF_TIME_RANGE2ITYPE_OF_TIME_RANGE
  PUBLIC :: FLT_INT_IOP2COP
  PUBLIC :: FLT_INT_COP2IOP
  PUBLIC :: FLT_COMPOSE_COP2IOP
  PUBLIC :: FLT_COMPOSE_IOP2COP
  PUBLIC :: CCLASS2ICLASS
  PUBLIC :: ICLASS2CCLASS
  PUBLIC :: ITYPE2CTYPE
  PUBLIC :: CTYPE2ITYPE
  PUBLIC :: ISTREAM2CSTREAM
  PUBLIC :: CSTREAM2ISTREAM
  PUBLIC :: IDATASTRUCT2CDATASTRUCT
  PUBLIC :: CDATASTRUCT2IDATASTRUCT
  PUBLIC :: IINTOPBINARY2CINTOPBINARY
  PUBLIC :: CINTOPBINARY2IINTOPBINARY
  PUBLIC :: IINTOPUNARY2CINTOPUNARY
  PUBLIC :: CINTOPUNARY2IINTOPUNARY
  PUBLIC :: IINTOPFUNCCALL2CINTOPFUNCCALL
  PUBLIC :: CINTOPFUNCCALL2IINTOPFUNCCALL
  PUBLIC :: IFLOATOPBINARY2CFLOATOPBINARY
  PUBLIC :: CFLOATOPBINARY2IFLOATOPBINARY
  PUBLIC :: IFLOATOPUNARY2CFLOATOPUNARY
  PUBLIC :: CFLOATOPUNARY2IFLOATOPUNARY
  PUBLIC :: IFLOATOPFUNCCALL2CFLOATOPFUNCCALL
  PUBLIC :: CFLOATOPFUNCCALL2IFLOATOPFUNCCALL
  PUBLIC :: IIFACES2CIFACES
  PUBLIC :: CIFACES2IIFACES
  PUBLIC :: IPREFIX2IMSGTYPE
  PUBLIC :: IPREFIX2ILEVTYPE
  PUBLIC :: IPARAMTYPE2CPARAMTYPE
  PUBLIC :: CPARAMTYPE2IPARAMTYPE
  PUBLIC :: CORIGIN2IORIGIN
  PUBLIC :: IORIGIN2CORIGIN
  PUBLIC :: CINT2IINT
  PUBLIC :: IINT2CINT
  PUBLIC :: CFLOAT2IFLOAT
  PUBLIC :: IFLOAT2CFLOAT
  PUBLIC :: CSINK2ISINK
  PUBLIC :: ISINK2CSINK
  PUBLIC :: CTIME2ITIME

  ! Sinks
  PUBLIC :: SINK_NONE_E
  PUBLIC :: SINK_MESSAGE_TO_FILE_E
  PUBLIC :: SINK_MESSAGE_TO_FDB_E
  PUBLIC :: SINK_GRIB_HEADER_TO_MULTIO_E

CONTAINS

#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IPREFIX2IMSGTYPE'
PP_THREAD_SAFE FUNCTION IPREFIX2IMSGTYPE( KPREF, MSGTYPE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: KPREF
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: MSGTYPE
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PREFIX = 1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Extract the enum for message type from prefix
  SELECT CASE( KPREF )
  CASE ( PREFIX_MODEL_LEVEL_E, PREFIX_PRESSURE_LEVEL_E, &
&        PREFIX_VORTICITY_LEVEL_E, PREFIX_THETA_LEVEL_E, &
&        PREFIX_SURFACE_E, PREFIX_AL_E, PREFIX_HEIGHT_ABOVE_GROUND_E  )
    MSGTYPE = ATM_MSG_E
  CASE ( PREFIX_WAVE_INT_E, PREFIX_WAVE_SPEC_E )
    MSGTYPE = WAM_MSG_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PREFIX )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)

    CASE (ERRFLAG_UNKNOWN_PREFIX)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown prefix' )

    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )

    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IPREFIX2IMSGTYPE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'SUBROUTINE'
#define PP_PROCEDURE_NAME 'IPREFIX2ILEVTYPE'
FUNCTION IPREFIX2ILEVTYPE( IPREFIX, PARAM_ID, LEVEL, REPRES, ILEVTYPE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IPREFIX
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: PARAM_ID
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: LEVEL
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: REPRES
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: ILEVTYPE
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_LEVTYPE = 1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! NGRBRSN  - 33     - Snow density
  ! NGRBTSN  - 238    - Temperature of snow layer
  ! NGRBWSN  - 228038 - Snow liquid water (multi-layer)
  ! NGRBSD   - 228141 - Snow depth (multi-layer)
  ! NGRBSOT  -  260360 Soil temperature (multi-layer)
  ! NGRBSIT  -  262024 Sea ice temperature (multi-layer)
  ! NGRBVSW  -  260199 Volumetric soil moisture (multi-layer)

  SELECT CASE ( IPREFIX )

  CASE ( PREFIX_MODEL_LEVEL_E )
    ILEVTYPE = LEVTYPE_ML_E
  CASE ( PREFIX_PRESSURE_LEVEL_E )
    ILEVTYPE = LEVTYPE_PL_E
  CASE (PREFIX_HEIGHT_ABOVE_GROUND_E)
    ILEVTYPE = LEVTYPE_HL_E
  CASE ( PREFIX_VORTICITY_LEVEL_E )
    ILEVTYPE = LEVTYPE_PV_E
  CASE ( PREFIX_THETA_LEVEL_E )
    ILEVTYPE = LEVTYPE_PT_E
  CASE ( PREFIX_SURFACE_E )
    ! SELECT CASE (PARAM_ID)
    ! TODO: This logic is very weak and should be improved
    ! CASE ( NGRBSD, NGRBTSN, NGRBRSN, NGRBWSN, NGRBSOT, NGRBVSW, NGRBSIT )
    ! IF ( LEVEL .NE. 0 ) THEN
      ! Multilevel surfaces at level 0 are considered as surface
    !  ILEVTYPE = LEVTYPE_SOL_E
    ! ELSE
      ILEVTYPE = LEVTYPE_SFC_E
    ! END IF
    ! CASE DEFAULT
    !   ILEVTYPE = LEVTYPE_SFC_E
    ! END SELECT
  CASE (PREFIX_AL_E)
    ILEVTYPE = LEVTYPE_AL_E
  CASE ( PREFIX_WAVE_INT_E )
    ILEVTYPE = LEVTYPE_SFC_E
  CASE ( PREFIX_WAVE_SPEC_E )
    ILEVTYPE = LEVTYPE_SFC_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_LEVTYPE )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()
    ! HAndle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_LEVTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown levtype' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IPREFIX2ILEVTYPE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IIFACES2CIFACES'
PP_THREAD_SAFE FUNCTION IIFACES2CIFACES( IIFACES, CIFACES, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IIFACES
  CHARACTER(LEN=16),    INTENT(OUT)   :: CIFACES
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_IFACES=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CIFACES = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( IIFACES )

  CASE ( ATM_MSG_E )
    CIFACES = 'atm-msg'
  CASE ( WAM_MSG_E )
    CIFACES = 'wam-msg'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_IFACES )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_IFACES)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IIFACES
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown ifaces: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IIFACES2CIFACES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CIFACES2IIFACES'
PP_THREAD_SAFE FUNCTION CIFACES2IIFACES( CIFACES, IIFACES, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CIFACES
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IIFACES
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CIFACES)) :: LOC_CIFACES

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_IFACES=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IIFACES = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CIFACES, LOC_CIFACES, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CIFACES)) )

  CASE ( 'atm-msg' )
    IIFACES = ATM_MSG_E
  CASE ( 'wave-msg' )
    IIFACES = WAM_MSG_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_IFACES )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_IFACES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown ciface: '//TRIM(ADJUSTL(CIFACES)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CIFACES2IIFACES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ISINK2CSINK'
PP_THREAD_SAFE FUNCTION ISINK2CSINK( ISINK, CSINK, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: ISINK
  CHARACTER(LEN=16),    INTENT(OUT)   :: CSINK
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PREFIX=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CSINK = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( ISINK )

  CASE ( SINK_NONE_E )
    CSINK = 'none'
  CASE ( SINK_MESSAGE_TO_FILE_E )
    CSINK = 'message-to-file'
  CASE ( SINK_MESSAGE_TO_FDB_E )
    CSINK = 'message-to-fdb'
  CASE ( SINK_GRIB_HEADER_TO_MULTIO_E )
    CSINK = 'header-to-multio'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PREFIX )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_PREFIX)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) ISINK
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown isink: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION ISINK2CSINK
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CSINK2ISINK'
PP_THREAD_SAFE FUNCTION CSINK2ISINK( CSINK, ISINK, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CSINK
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: ISINK
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CSINK)) :: LOC_CSINK

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PREFIX=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  ISINK = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CSINK, LOC_CSINK, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CSINK)) )

  CASE ( 'none' )
    ISINK = SINK_NONE_E
  CASE ( 'message-to-file' )
    ISINK = SINK_MESSAGE_TO_FILE_E
  CASE ( 'message-to-fdb' )
    ISINK = SINK_MESSAGE_TO_FDB_E
  CASE ( 'header-to-multio' )
    ISINK = SINK_GRIB_HEADER_TO_MULTIO_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PREFIX )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_PREFIX)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown csink: '//TRIM(ADJUSTL(CSINK)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CSINK2ISINK
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IPREFIX2CPREFIX'
PP_THREAD_SAFE FUNCTION IPREFIX2CPREFIX( IPREFIX, CPREFIX, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IPREFIX
  CHARACTER(LEN=16),    INTENT(OUT)   :: CPREFIX
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PREFIX=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CPREFIX = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( IPREFIX )

  CASE ( PREFIX_MODEL_LEVEL_E )
    CPREFIX = 'm'
  CASE ( PREFIX_PRESSURE_LEVEL_E )
    CPREFIX = 'p'
  CASE ( PREFIX_VORTICITY_LEVEL_E )
    CPREFIX = 'v'
  CASE ( PREFIX_THETA_LEVEL_E )
    CPREFIX = 't'
  CASE ( PREFIX_SURFACE_E )
    CPREFIX = 's'
  CASE ( PREFIX_AL_E )
    CPREFIX = 'a'
  CASE ( PREFIX_WAVE_INT_E )
    CPREFIX = 'wv_int'
  CASE ( PREFIX_WAVE_SPEC_E )
    CPREFIX = 'wv_spec'
  CASE ( PREFIX_HEIGHT_ABOVE_GROUND_E )
    CPREFIX = 'h'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PREFIX )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_PREFIX)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IPREFIX
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown iprefix: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IPREFIX2CPREFIX
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CPREFIX2IPREFIX'
PP_THREAD_SAFE FUNCTION CPREFIX2IPREFIX( CPREFIX, IPREFIX, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CPREFIX
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IPREFIX
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CPREFIX)) :: LOC_CPREFIX

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PREFIX=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IPREFIX = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CPREFIX, LOC_CPREFIX, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CPREFIX)) )

  CASE ( 'ml', 'm' )
    IPREFIX = PREFIX_MODEL_LEVEL_E
  CASE ( 'pl', 'p' )
    IPREFIX = PREFIX_PRESSURE_LEVEL_E
  CASE ( 'pv', 'v' )
    IPREFIX = PREFIX_VORTICITY_LEVEL_E
  CASE ( 'th', 't' )
    IPREFIX = PREFIX_THETA_LEVEL_E
  CASE ( 'sf', 's', 'sfc' )
    IPREFIX = PREFIX_SURFACE_E
  CASE ( 'al', 'a' )
    IPREFIX = PREFIX_AL_E
  CASE ( 'wv_int' )
    IPREFIX = PREFIX_WAVE_INT_E
  CASE ( 'wv_spec' )
    IPREFIX = PREFIX_WAVE_SPEC_E
  CASE ( 'HL', 'h' )
    IPREFIX = PREFIX_HEIGHT_ABOVE_GROUND_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PREFIX )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_PREFIX)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cprefix: '//TRIM(ADJUSTL(CPREFIX)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CPREFIX2IPREFIX
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ILEVTYPE2CLEVTYPE'
PP_THREAD_SAFE FUNCTION ILEVTYPE2CLEVTYPE( ILEVTYPE, CLEVTYPE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: ILEVTYPE
  CHARACTER(LEN=16),    INTENT(OUT)   :: CLEVTYPE
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_LEVTYPE=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CLEVTYPE = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( ILEVTYPE )

  CASE ( LEVTYPE_HHL_E )
    CLEVTYPE = 'hhl'
  CASE ( LEVTYPE_HPL_E )
    CLEVTYPE = 'hpl'
  CASE ( LEVTYPE_HL_E )
    CLEVTYPE = 'hl'
  CASE ( LEVTYPE_ML_E )
    CLEVTYPE = 'ml'
  CASE ( LEVTYPE_O2D_E )
    CLEVTYPE = 'o2d'
  CASE ( LEVTYPE_O3D_E )
    CLEVTYPE = 'o3d'
  CASE ( LEVTYPE_PL_E )
    CLEVTYPE = 'pl'
  CASE ( LEVTYPE_PT_E )
    CLEVTYPE = 'pt'
  CASE ( LEVTYPE_PV_E )
    CLEVTYPE = 'pv'
  CASE ( LEVTYPE_SFC_E )
    CLEVTYPE = 'sfc'
  CASE ( LEVTYPE_SOL_E )
    CLEVTYPE = 'sol'
  CASE ( LEVTYPE_AL_E )
    CLEVTYPE = 'al'
  CASE ( LEVTYPE_WAM_INT_E )
    CLEVTYPE = 'wam_int'
  CASE ( LEVTYPE_WAM_SPEC_E )
    CLEVTYPE = 'wam_spec'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_LEVTYPE )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_LEVTYPE)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) ILEVTYPE
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown ilevtype: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION ILEVTYPE2CLEVTYPE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CLEVTYPE2ILEVTYPE'
PP_THREAD_SAFE FUNCTION CLEVTYPE2ILEVTYPE( CLEVTYPE, ILEVTYPE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CLEVTYPE
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: ILEVTYPE
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CLEVTYPE)) :: LOC_CLEVTYPE

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_LEVTYPE=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  ILEVTYPE = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CLEVTYPE, LOC_CLEVTYPE, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CLEVTYPE)) )
  CASE ( 'hhl' )
    ILEVTYPE = LEVTYPE_HHL_E
  CASE ( 'hpl' )
    ILEVTYPE = LEVTYPE_HPL_E
  CASE ( 'hl' )
    ILEVTYPE = LEVTYPE_HL_E
  CASE ( 'ml' )
    ILEVTYPE = LEVTYPE_ML_E
  CASE ( 'o2d' )
    ILEVTYPE = LEVTYPE_O2D_E
  CASE ( 'o3d' )
    ILEVTYPE = LEVTYPE_O3D_E
  CASE ( 'pl' )
    ILEVTYPE = LEVTYPE_PL_E
  CASE ( 'pt' )
    ILEVTYPE = LEVTYPE_PT_E
  CASE ( 'pv' )
    ILEVTYPE = LEVTYPE_PV_E
  CASE ( 'sfc' )
    ILEVTYPE = LEVTYPE_SFC_E
  CASE ( 'sol' )
    ILEVTYPE = LEVTYPE_SOL_E
  CASE ( 'al' )
    ILEVTYPE = LEVTYPE_AL_E
  CASE ( 'wam_int' )
    ILEVTYPE = LEVTYPE_WAM_INT_E
  CASE ( 'wam_spec' )
    ILEVTYPE = LEVTYPE_WAM_SPEC_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_LEVTYPE )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_LEVTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown clevtype: '//TRIM(ADJUSTL(CLEVTYPE)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CLEVTYPE2ILEVTYPE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IREPRES2CREPRES'
PP_THREAD_SAFE FUNCTION IREPRES2CREPRES( IREPRES, CREPRES, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IREPRES
  CHARACTER(LEN=16),    INTENT(OUT)   :: CREPRES
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_REPRES=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CREPRES = REPEAT(' ', 16)

  !> Select the repres
  SELECT CASE ( IREPRES )

  CASE ( REPRES_LATLONG_E )
    CREPRES = 'll'
  CASE ( REPRES_GAUSSIANGRID_E )
    CREPRES = 'gg'
  CASE ( REPRES_SPHERICALHARMONICS_E )
    CREPRES = 'sh'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_REPRES )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_REPRES)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IREPRES
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown irepres: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IREPRES2CREPRES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CREPRES2IREPRES'
PP_THREAD_SAFE FUNCTION CREPRES2IREPRES( CREPRES, IREPRES, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CREPRES
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IREPRES
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CREPRES)) :: LOC_CREPRES

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_REPRES=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IREPRES = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CREPRES, LOC_CREPRES, HOOKS )

  !> Select the repres
  SELECT CASE ( TRIM(ADJUSTL(LOC_CREPRES)) )

  CASE ( 'll', 'latlon' )
    IREPRES = REPRES_LATLONG_E
  CASE ( 'gg', 'gaussian-grid' )
    IREPRES = REPRES_GAUSSIANGRID_E
  CASE ( 'sh', 'spherical-harmonics' )
    IREPRES = REPRES_SPHERICALHARMONICS_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_REPRES )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_REPRES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown crepres: '//TRIM(ADJUSTL(CREPRES)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CREPRES2IREPRES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IMODEL2CMODEL'
PP_THREAD_SAFE FUNCTION IMODEL2CMODEL( IMODEL, CMODEL, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IMODEL
  CHARACTER(LEN=16),    INTENT(OUT)   :: CMODEL
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_MODEL=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CMODEL = REPEAT(' ', 16)

  !> Select the repres
  SELECT CASE ( IMODEL )

  CASE ( MODEL_ATMOSPHERE_E )
    CMODEL = 'atmosphere'
  CASE ( MODEL_OCEAN_E )
    CMODEL = 'ocean'
  CASE ( MODEL_WAVE_E )
    CMODEL = 'wave'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_MODEL )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_MODEL)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IMODEL
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown imodel: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IMODEL2CMODEL
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CMODEL2IMODEL'
PP_THREAD_SAFE FUNCTION CMODEL2IMODEL( CMODEL, IMODEL, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CMODEL
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IMODEL
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CMODEL)) :: LOC_CMODEL

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_MODEL=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IMODEL = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CMODEL, LOC_CMODEL, HOOKS )

  !> Select the repres
  SELECT CASE ( TRIM(ADJUSTL(LOC_CMODEL)) )

  CASE ( 'atmosphere' )
    IMODEL = MODEL_ATMOSPHERE_E
  CASE ( 'ocean' )
    IMODEL = MODEL_OCEAN_E
  CASE ( 'wave' )
    IMODEL = MODEL_WAVE_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_MODEL )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_MODEL)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cmodel: '//TRIM(ADJUSTL(CMODEL)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CMODEL2IMODEL
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IPRECISION2CPRECISION'
PP_THREAD_SAFE FUNCTION IPRECISION2CPRECISION( IPRECISION, CPRECISION, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IPRECISION
  CHARACTER(LEN=16),    INTENT(OUT)   :: CPRECISION
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PRECISION=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CPRECISION = REPEAT(' ', 16)

  !> Select the repres
  SELECT CASE ( IPRECISION )

  CASE ( PRECISION_DP_E )
    CPRECISION = 'dp'
  CASE ( PRECISION_SP_E )
    CPRECISION = 'sp'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PRECISION )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_PRECISION)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IPRECISION
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown iprecision: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IPRECISION2CPRECISION
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CPRECISION2IPRECISION'
PP_THREAD_SAFE FUNCTION CPRECISION2IPRECISION( CPRECISION, IPRECISION, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CPRECISION
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IPRECISION
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CPRECISION)) :: LOC_CPRECISION

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PRECISION=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IPRECISION = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CPRECISION, LOC_CPRECISION, HOOKS )


  !> Select the repres
  SELECT CASE ( TRIM(ADJUSTL(LOC_CPRECISION)) )

  CASE ( 'sp' )
    IPRECISION = PRECISION_SP_E
  CASE ( 'dp' )
    IPRECISION = PRECISION_DP_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PRECISION )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_PRECISION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cprecision: '//TRIM(ADJUSTL(CPRECISION)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CPRECISION2IPRECISION
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IEDITION2CEDITION'
PP_THREAD_SAFE FUNCTION IEDITION2CEDITION( IEDITION, CEDITION, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IEDITION
  CHARACTER(LEN=16),    INTENT(OUT)   :: CEDITION
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_EDITION=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CEDITION = REPEAT(' ', 16)

  !> Select the repres
  SELECT CASE ( IEDITION )

  CASE ( EDITION_GRIB1_E )
    CEDITION = 'grib1'
  CASE ( EDITION_GRIB2_E )
    CEDITION = 'grib2'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_EDITION )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_EDITION)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IEDITION
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown iedition: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IEDITION2CEDITION
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CEDITION2IEDITION'
PP_THREAD_SAFE FUNCTION CEDITION2IEDITION( CEDITION, IEDITION, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CEDITION
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IEDITION
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CEDITION)) :: LOC_CEDITION

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_EDITION=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IEDITION = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CEDITION, LOC_CEDITION, HOOKS )

  !> Select the repres
  SELECT CASE ( TRIM(ADJUSTL(LOC_CEDITION)) )

  CASE ( 'grib1' )
    IEDITION = EDITION_GRIB1_E
  CASE ( 'grib2' )
    IEDITION = EDITION_GRIB2_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_EDITION )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_EDITION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cedition: '//TRIM(ADJUSTL(CEDITION)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CEDITION2IEDITION
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IPACKING2CPACKING'
PP_THREAD_SAFE FUNCTION IPACKING2CPACKING( IPACKING, CPACKING, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IPACKING
  CHARACTER(LEN=16),    INTENT(OUT)   :: CPACKING
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PACKING=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CPACKING = REPEAT(' ', 16)

  !> Select the repres
  SELECT CASE ( IPACKING )

  CASE ( PACKING_GRIB_SIMPLE_E )
    CPACKING = 'simple'
  CASE ( PACKING_GRIB_CCSDS_E )
    CPACKING = 'ccsds'
  CASE ( PACKING_GRIB_COMPLEX_E )
    CPACKING = 'complex'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PACKING )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_PACKING)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IPACKING
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown ipacking: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IPACKING2CPACKING
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CPACKING2IPACKING'
PP_THREAD_SAFE FUNCTION CPACKING2IPACKING( CPACKING, IPACKING, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CPACKING
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IPACKING
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CPACKING)) :: LOC_CPACKING

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PACKING=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IPACKING = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CPACKING, LOC_CPACKING, HOOKS )


  !> Select the repres
  SELECT CASE ( TRIM(ADJUSTL(LOC_CPACKING)) )

  CASE ( 'simple' )
    IPACKING = PACKING_GRIB_SIMPLE_E
  CASE ( 'ccsds' )
    IPACKING = PACKING_GRIB_CCSDS_E
  CASE ( 'complex' )
    IPACKING = PACKING_GRIB_COMPLEX_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PACKING )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_PACKING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cpacking: '//TRIM(ADJUSTL(CPACKING)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CPACKING2IPACKING
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ITYPE_OF_STATISTICAL_PROCESS2CTYPE_OF_STATISTICAL_PROCESS'
PP_THREAD_SAFE FUNCTION ITYPE_OF_STATISTICAL_PROCESS2CTYPE_OF_STATISTICAL_PROCESS( ITYPE_OF_STATISTICAL_PROCESS, CTYPE_OF_STATISTICAL_PROCESS, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: ITYPE_OF_STATISTICAL_PROCESS
  CHARACTER(LEN=16),    INTENT(OUT)   :: CTYPE_OF_STATISTICAL_PROCESS
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_TYPE_OF_STATISTICAL_PROCESS=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CTYPE_OF_STATISTICAL_PROCESS = REPEAT(' ', 16)

  !> Select the repres
  SELECT CASE ( ITYPE_OF_STATISTICAL_PROCESS )
  CASE ( TYPE_OF_STATISTICAL_PROCESS_INSTANT_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'instant'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_AVERAGE_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'average'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_ACCUMUL_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'accumul'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_MAX_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'max'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_MIN_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'min'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_DIFF_FWD_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'diff-fwd'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_RMS_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'rms'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_STDDEV_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'stddev'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_COV_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'covariance'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_DIFF_BWD_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'diff-bwd'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_RATIO_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'ratio'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_STD_ANOMALY_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'std-anomaly'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_SUMMATION_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'summation'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_SEVERITY_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'severity'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_MODE_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'mode'
  CASE ( TYPE_OF_STATISTICAL_PROCESS_MISSING_E )
    CTYPE_OF_STATISTICAL_PROCESS = 'missing'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_TYPE_OF_STATISTICAL_PROCESS )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_TYPE_OF_STATISTICAL_PROCESS)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) ITYPE_OF_STATISTICAL_PROCESS
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown itypeOfStatisticaProcess: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION ITYPE_OF_STATISTICAL_PROCESS2CTYPE_OF_STATISTICAL_PROCESS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CTYPE_OF_STATISTICAL_PROCESS2ITYPE_OF_STATISTICAL_PROCESS'
PP_THREAD_SAFE FUNCTION CTYPE_OF_STATISTICAL_PROCESS2ITYPE_OF_STATISTICAL_PROCESS( CTYPE_OF_STATISTICAL_PROCESS, ITYPE_OF_STATISTICAL_PROCESS, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CTYPE_OF_STATISTICAL_PROCESS
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: ITYPE_OF_STATISTICAL_PROCESS
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CTYPE_OF_STATISTICAL_PROCESS)) :: LOC_CTYPE_OF_STATISTICAL_PROCESS

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_TYPE_OF_STATISTICAL_PROCESS=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  ITYPE_OF_STATISTICAL_PROCESS = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CTYPE_OF_STATISTICAL_PROCESS, LOC_CTYPE_OF_STATISTICAL_PROCESS, HOOKS )

  !> Select the repres
  SELECT CASE ( TRIM(ADJUSTL(LOC_CTYPE_OF_STATISTICAL_PROCESS)) )

  CASE ( 'instant' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_INSTANT_E
  CASE ( 'average' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_AVERAGE_E
  CASE ( 'accumul' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_ACCUMUL_E
  CASE ( 'max' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_MAX_E
  CASE ( 'min' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_MIN_E
  CASE ( 'diff-fwd' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_DIFF_FWD_E
  CASE ( 'rms' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_RMS_E
  CASE ( 'stddev' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_STDDEV_E
  CASE ( 'covariance' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_COV_E
  CASE ( 'diff-bwd' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_DIFF_BWD_E
  CASE ( 'ratio' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_RATIO_E
  CASE ( 'std-anomaly' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_STD_ANOMALY_E
  CASE ( 'summation' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_SUMMATION_E
  CASE ( 'severity' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_SEVERITY_E
  CASE ( 'mode' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_MODE_E
  CASE ( '' )
    ITYPE_OF_STATISTICAL_PROCESS = TYPE_OF_STATISTICAL_PROCESS_MISSING_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_TYPE_OF_STATISTICAL_PROCESS )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_TYPE_OF_STATISTICAL_PROCESS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown ctypeOfStatisticaProcess: '//TRIM(ADJUSTL(CTYPE_OF_STATISTICAL_PROCESS)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CTYPE_OF_STATISTICAL_PROCESS2ITYPE_OF_STATISTICAL_PROCESS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ITYPE_OF_TIME_RANGE2CTYPE_OF_TIME_RANGE'
PP_THREAD_SAFE FUNCTION ITYPE_OF_TIME_RANGE2CTYPE_OF_TIME_RANGE( ITYPE_OF_TIME_RANGE, CTYPE_OF_TIME_RANGE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: ITYPE_OF_TIME_RANGE
  CHARACTER(LEN=16),    INTENT(OUT)   :: CTYPE_OF_TIME_RANGE
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_TYPE_OF_TIME_RANGE=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CTYPE_OF_TIME_RANGE = REPEAT(' ', 16)

  !> Select the repres
  SELECT CASE ( ITYPE_OF_TIME_RANGE )

  CASE ( TYPE_OF_TIME_RANGE_INSTANT_E )
    CTYPE_OF_TIME_RANGE = 'instant'
  CASE ( TYPE_OF_TIME_RANGE_FROM_STEP0_E )
    CTYPE_OF_TIME_RANGE = 'from-step0'
  CASE ( TYPE_OF_TIME_RANGE_FROM_LASTPP_E )
    CTYPE_OF_TIME_RANGE = 'from-last-pp'
  CASE ( TYPE_OF_TIME_RANGE_FIXED_SIZE_E )
    CTYPE_OF_TIME_RANGE = 'fixed-size'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_TYPE_OF_TIME_RANGE )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_TYPE_OF_TIME_RANGE)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) ITYPE_OF_TIME_RANGE
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown itypeOfTimeRange: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION ITYPE_OF_TIME_RANGE2CTYPE_OF_TIME_RANGE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CTYPE_OF_TIME_RANGE2ITYPE_OF_TIME_RANGE'
PP_THREAD_SAFE FUNCTION CTYPE_OF_TIME_RANGE2ITYPE_OF_TIME_RANGE( CTYPE_OF_TIME_RANGE, ITYPE_OF_TIME_RANGE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CTYPE_OF_TIME_RANGE
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: ITYPE_OF_TIME_RANGE
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CTYPE_OF_TIME_RANGE)) :: LOC_CTYPE_OF_TIME_RANGE

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_TYPE_OF_TIME_RANGE=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  ITYPE_OF_TIME_RANGE = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CTYPE_OF_TIME_RANGE, LOC_CTYPE_OF_TIME_RANGE, HOOKS )

  !> Select the repres
  SELECT CASE ( TRIM(ADJUSTL(LOC_CTYPE_OF_TIME_RANGE)) )

  CASE ( 'instant' )
    ITYPE_OF_TIME_RANGE = TYPE_OF_TIME_RANGE_INSTANT_E
  CASE ( 'from-step0' )
    ITYPE_OF_TIME_RANGE = TYPE_OF_TIME_RANGE_FROM_STEP0_E
  CASE ( 'from-last-pp' )
    ITYPE_OF_TIME_RANGE = TYPE_OF_TIME_RANGE_FROM_LASTPP_E
  CASE ( 'fixed-size' )
    ITYPE_OF_TIME_RANGE = TYPE_OF_TIME_RANGE_FIXED_SIZE_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_TYPE_OF_TIME_RANGE )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_TYPE_OF_TIME_RANGE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown ctypeOfTimeRange: '//TRIM(ADJUSTL(CTYPE_OF_TIME_RANGE)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CTYPE_OF_TIME_RANGE2ITYPE_OF_TIME_RANGE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Converts a character operation (COP) to an integer operation (IOP).
!>
!> This function takes a string representing a character operation (`COP`) and
!> converts it into a corresponding integer operation (`IOP`). It uses hooks during
!> the conversion process to allow additional processing if needed.
!>
!> @param [in] COP   The character operation (`CHARACTER(LEN=*)`) to be converted.
!> @param [out] IOP  The resulting integer operation (`INTEGER(KIND=JPIB_K)`).
!> @param [inout] HOOKS  Structure (`HOOKS_T`) used for additional hooks or callbacks during the conversion process.
!>
!> @return Integer error code (`RET`) indicating success or failure of the conversion operation.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section local dependencies
!> @dependency [TYPE] DATAKINDS_DEF_MOD::JPIB_K
!> @dependency [TYPE] HOOKS_MOD::HOOKS_T
!>
!> @section special dependencies
!> @dependency [*] PP_DEBUG_USE_VARS::*
!> @dependency [*] PP_LOG_USE_VARS::*
!> @dependency [*] PP_TRACE_USE_VARS::*
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FLT_INT_COP2IOP'
FUNCTION FLT_INT_COP2IOP( COP, IOP, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: COP
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IOP
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(COP)) :: LOC_COP

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_OPERATION = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialize the output variable
  IOP = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( COP, LOC_COP, HOOKS )

  ! Apply operation
  SELECT CASE( TRIM(ADJUSTL(LOC_COP)) )

  CASE( 'match', 'eq', 'equal' )

    IOP = FLT_INT_MATCH_E

  CASE( 'ignore', 'ne', 'not-equal' )

    IOP = FLT_INT_IGNORE_E

  CASE( 'greater-than', 'gt' )

    IOP = FLT_INT_GT_E

  CASE( 'greater-equal', 'ge' )

    IOP = FLT_INT_GE_E

  CASE( 'lower-than', 'lt' )

    IOP = FLT_INT_LT_E

  CASE( 'lower-equal', 'le' )

    IOP = FLT_INT_LE_E

  CASE( 'has' )

    IOP = FLT_INT_HAS_E

  CASE( 'lacks' )

    IOP = FLT_INT_LACKS_E

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_OPERATION )

  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_OPERATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown operation' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FLT_INT_COP2IOP
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FLT_INT_IOP2COP'
FUNCTION FLT_INT_IOP2COP( IOP, COP, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IOP
  CHARACTER(LEN=16),    INTENT(OUT)   :: COP
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_OPERATION = 1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialize the output variable
  COP = REPEAT( ' ', 16 )

  ! Apply operation
  SELECT CASE( IOP )

  CASE( FLT_INT_MATCH_E )

    COP = 'match'

  CASE( FLT_INT_IGNORE_E )

    COP = 'ignore'

  CASE( FLT_INT_GT_E )

    COP = 'greater-than'

  CASE( FLT_INT_GE_E )

    COP = 'greater-equal'

  CASE( FLT_INT_LT_E )

    COP = 'lower-than'

  CASE( FLT_INT_LE_E )

    COP = 'lower-equal'

  CASE( FLT_INT_HAS_E )

    COP = 'has'

  CASE( FLT_INT_LACKS_E )

    COP = 'lacks'

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_OPERATION )

  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_OPERATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown operation' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FLT_INT_IOP2COP
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




!>
!> @brief Converts an integer operation code (IOP) to a character operation code (COP).
!>
!> This thread-safe function takes an integer representation of an operation code
!> (`IOP`) and converts it into its corresponding character operation code (`COP`).
!> The conversion process utilizes hooks for debugging, logging, and tracing
!> purposes.
!>
!> @param [in] IOP The integer representation of the operation code to be converted.
!> @param [out] COP The resulting character representation of the operation code
!>                  after conversion. The length of the character string is fixed at
!>                  16 characters.
!> @param [inout] HOOKS A structure for debugging, tracing, or logging purposes
!>                       that facilitates monitoring the conversion process.
!>
!> @return Integer error code (`RET`) indicating success or failure:
!>         - `0`: Success
!>         - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection local dependencies
!>   - @dependency [READ] HOOKS_MOD::HOOKS_T
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FLT_COMPOSE_IOP2COP'
PP_THREAD_SAFE FUNCTION FLT_COMPOSE_IOP2COP( IOP, COP, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)   :: IOP
  CHARACTER(LEN=16),    INTENT(OUT)  :: COP
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_OPERATION = 1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialize output variable
  COP = REPEAT(' ', 16)

  ! Apply operation
  SELECT CASE( IOP )

  CASE( FLT_COMPOSE_ALL_E )

    COP = 'all'

  CASE( FLT_COMPOSE_ANY_E )

    COP = 'any'

  CASE( FLT_COMPOSE_NONE_E )

    COP = 'none'

  CASE( FLT_COMPOSE_ONE_E )

    COP = 'one'

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_OPERATION )

  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_OPERATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown operation' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FLT_COMPOSE_IOP2COP
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'FLT_COMPOSE_COP2IOP'
PP_THREAD_SAFE FUNCTION FLT_COMPOSE_COP2IOP( COP, IOP, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: COP
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IOP
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(COP)) :: LOC_COP

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_OPERATION = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialize output variable
  IOP = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( COP, LOC_COP, HOOKS )

  ! Apply operation
  SELECT CASE( TRIM(ADJUSTL(LOC_COP)) )

  CASE( 'all' )

    IOP = FLT_COMPOSE_ALL_E

  CASE( 'any' )

    IOP = FLT_COMPOSE_ANY_E

  CASE( 'none' )

    IOP = FLT_COMPOSE_NONE_E

  CASE( 'one' )

    IOP = FLT_COMPOSE_ONE_E

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_OPERATION )

  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_OPERATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown operation:' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( ' - cop: '//TRIM(ADJUSTL(COP)) )
      PP_DEBUG_PUSH_MSG_TO_FRAME( ' - loc-cop: '//TRIM(ADJUSTL(LOC_COP)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION FLT_COMPOSE_COP2IOP
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CCLASS2ICLASS'
PP_THREAD_SAFE FUNCTION CCLASS2ICLASS( CCLASS, ICLASS, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CCLASS
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: ICLASS
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CCLASS)) :: LOC_CCLASS

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_CLASS=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  ICLASS = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CCLASS, LOC_CCLASS, HOOKS )

  !> Select the class
  SELECT CASE ( TRIM(ADJUSTL(LOC_CCLASS)) )
 CASE ('0')
    ICLASS = CLASS_0_E
  CASE ('od')
    ICLASS = CLASS_OD_E
  CASE ('rd')
    ICLASS = CLASS_RD_E
  CASE ('er')
    ICLASS = CLASS_ER_E
  CASE ('cs')
    ICLASS = CLASS_CS_E
  CASE ('e4')
    ICLASS = CLASS_E4_E
  CASE ('dm')
    ICLASS = CLASS_DM_E
  CASE ('pv')
    ICLASS = CLASS_PV_E
  CASE ('el')
    ICLASS = CLASS_EL_E
  CASE ('to')
    ICLASS = CLASS_TO_E
  CASE ('co')
    ICLASS = CLASS_CO_E
  CASE ('en')
    ICLASS = CLASS_EN_E
  CASE ('ti')
    ICLASS = CLASS_TI_E
  CASE ('me')
    ICLASS = CLASS_ME_E
  CASE ('ei')
    ICLASS = CLASS_EI_E
  CASE ('sr')
    ICLASS = CLASS_SR_E
  CASE ('dt')
    ICLASS = CLASS_DT_E
  CASE ('la')
    ICLASS = CLASS_LA_E
  CASE ('yt')
    ICLASS = CLASS_YT_E
  CASE ('mc')
    ICLASS = CLASS_MC_E
  CASE ('pe')
    ICLASS = CLASS_PE_E
  CASE ('em')
    ICLASS = CLASS_EM_E
  CASE ('e2')
    ICLASS = CLASS_E2_E
  CASE ('ea')
    ICLASS = CLASS_EA_E
  CASE ('ep')
    ICLASS = CLASS_EP_E
  CASE ('rm')
    ICLASS = CLASS_RM_E
  CASE ('nr')
    ICLASS = CLASS_NR_E
  CASE ('s2')
    ICLASS = CLASS_S2_E
  CASE ('j5')
    ICLASS = CLASS_J5_E
  CASE ('ur')
    ICLASS = CLASS_UR_E
  CASE ('et')
    ICLASS = CLASS_ET_E
  CASE ('c3')
    ICLASS = CLASS_C3_E
  CASE ('yp')
    ICLASS = CLASS_YP_E
  CASE ('l5')
    ICLASS = CLASS_L5_E
  CASE ('lw')
    ICLASS = CLASS_LW_E
  CASE ('ce')
    ICLASS = CLASS_CE_E
  CASE ('cr')
    ICLASS = CLASS_CR_E
  CASE ('rr')
    ICLASS = CLASS_RR_E
  CASE ('ul')
    ICLASS = CLASS_UL_E
  CASE ('gw')
    ICLASS = CLASS_GW_E
  CASE ('e6')
    ICLASS = CLASS_E6_E
  CASE ('l6')
    ICLASS = CLASS_L6_E
  CASE ('ef')
    ICLASS = CLASS_EF_E
  CASE ('gf')
    ICLASS = CLASS_GF_E
  CASE ('gg')
    ICLASS = CLASS_GG_E
  CASE ('ml')
    ICLASS = CLASS_ML_E
  CASE ('d1')
    ICLASS = CLASS_D1_E
  CASE ('o6')
    ICLASS = CLASS_O6_E
  CASE ('eh')
    ICLASS = CLASS_EH_E
  CASE ('gh')
    ICLASS = CLASS_GH_E
  CASE ('ci')
    ICLASS = CLASS_CI_E
  CASE ('ai')
    ICLASS = CLASS_AI_E
  CASE ('ed')
    ICLASS = CLASS_ED_E
  CASE ('ng')
    ICLASS = CLASS_NG_E
  CASE ('te')
    ICLASS = CLASS_TE_E
  CASE ('at')
    ICLASS = CLASS_AT_E
  CASE ('be')
    ICLASS = CLASS_BE_E
  CASE ('hr')
    ICLASS = CLASS_HR_E
  CASE ('dk')
    ICLASS = CLASS_DK_E
  CASE ('fi')
    ICLASS = CLASS_FI_E
  CASE ('fr')
    ICLASS = CLASS_FR_E
  CASE ('de')
    ICLASS = CLASS_DE_E
  CASE ('gr')
    ICLASS = CLASS_GR_E
  CASE ('hu')
    ICLASS = CLASS_HU_E
  CASE ('is')
    ICLASS = CLASS_IS_E
  CASE ('ie')
    ICLASS = CLASS_IE_E
  CASE ('it')
    ICLASS = CLASS_IT_E
  CASE ('nl')
    ICLASS = CLASS_NL_E
  CASE ('no')
    ICLASS = CLASS_NO_E
  CASE ('pt')
    ICLASS = CLASS_PT_E
  CASE ('si')
    ICLASS = CLASS_SI_E
  CASE ('es')
    ICLASS = CLASS_ES_E
  CASE ('se')
    ICLASS = CLASS_SE_E
  CASE ('ch')
    ICLASS = CLASS_CH_E
  CASE ('tr')
    ICLASS = CLASS_TR_E
  CASE ('uk')
    ICLASS = CLASS_UK_E
  CASE ('ms')
    ICLASS = CLASS_MS_E
  CASE ('ma')
    ICLASS = CLASS_MA_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_CLASS )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_CLASS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cclass: '//TRIM(ADJUSTL(CCLASS)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CCLASS2ICLASS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE

#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ICLASS2CCLASS'
PP_THREAD_SAFE FUNCTION ICLASS2CCLASS( ICLASS, CCLASS, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: ICLASS
  CHARACTER(LEN=2),     INTENT(OUT)   :: CCLASS
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_CLASS=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CCLASS = REPEAT(' ', 2)

  !> Select the class
  SELECT CASE ( ICLASS )
  CASE (CLASS_0_E)
    CCLASS = '0'
  CASE (CLASS_OD_E)
    CCLASS = 'od'
  CASE (CLASS_RD_E)
    CCLASS = 'rd'
  CASE (CLASS_ER_E)
    CCLASS = 'er'
  CASE (CLASS_CS_E)
    CCLASS = 'cs'
  CASE (CLASS_E4_E)
    CCLASS = 'e4'
  CASE (CLASS_DM_E)
    CCLASS = 'dm'
  CASE (CLASS_PV_E)
    CCLASS = 'pv'
  CASE (CLASS_EL_E)
    CCLASS = 'el'
  CASE (CLASS_TO_E)
    CCLASS = 'to'
  CASE (CLASS_CO_E)
    CCLASS = 'co'
  CASE (CLASS_EN_E)
    CCLASS = 'en'
  CASE (CLASS_TI_E)
    CCLASS = 'ti'
  CASE (CLASS_ME_E)
    CCLASS = 'me'
  CASE (CLASS_EI_E)
    CCLASS = 'ei'
  CASE (CLASS_SR_E)
    CCLASS = 'sr'
  CASE (CLASS_DT_E)
    CCLASS = 'dt'
  CASE (CLASS_LA_E)
    CCLASS = 'la'
  CASE (CLASS_YT_E)
    CCLASS = 'yt'
  CASE (CLASS_MC_E)
    CCLASS = 'mc'
  CASE (CLASS_PE_E)
    CCLASS = 'pe'
  CASE (CLASS_EM_E)
    CCLASS = 'em'
  CASE (CLASS_E2_E)
    CCLASS = 'e2'
  CASE (CLASS_EA_E)
    CCLASS = 'ea'
  CASE (CLASS_EP_E)
    CCLASS = 'ep'
  CASE (CLASS_RM_E)
    CCLASS = 'rm'
  CASE (CLASS_NR_E)
    CCLASS = 'nr'
  CASE (CLASS_S2_E)
    CCLASS = 's2'
  CASE (CLASS_J5_E)
    CCLASS = 'j5'
  CASE (CLASS_UR_E)
    CCLASS = 'ur'
  CASE (CLASS_ET_E)
    CCLASS = 'et'
  CASE (CLASS_C3_E)
    CCLASS = 'c3'
  CASE (CLASS_YP_E)
    CCLASS = 'yp'
  CASE (CLASS_L5_E)
    CCLASS = 'l5'
  CASE (CLASS_LW_E)
    CCLASS = 'lw'
  CASE (CLASS_CE_E)
    CCLASS = 'ce'
  CASE (CLASS_CR_E)
    CCLASS = 'cr'
  CASE (CLASS_RR_E)
    CCLASS = 'rr'
  CASE (CLASS_UL_E)
    CCLASS = 'ul'
  CASE (CLASS_GW_E)
    CCLASS = 'gw'
  CASE (CLASS_E6_E)
    CCLASS = 'e6'
  CASE (CLASS_L6_E)
    CCLASS = 'l6'
  CASE (CLASS_EF_E)
    CCLASS = 'ef'
  CASE (CLASS_GF_E)
    CCLASS = 'gf'
  CASE (CLASS_GG_E)
    CCLASS = 'gg'
  CASE (CLASS_ML_E)
    CCLASS = 'ml'
  CASE (CLASS_D1_E)
    CCLASS = 'd1'
  CASE (CLASS_O6_E)
    CCLASS = 'o6'
  CASE (CLASS_EH_E)
    CCLASS = 'eh'
  CASE (CLASS_GH_E)
    CCLASS = 'gh'
  CASE (CLASS_CI_E)
    CCLASS = 'ci'
  CASE (CLASS_AI_E)
    CCLASS = 'ai'
  CASE (CLASS_ED_E)
    CCLASS = 'ed'
  CASE (CLASS_NG_E)
    CCLASS = 'ng'
  CASE (CLASS_TE_E)
    CCLASS = 'te'
  CASE (CLASS_AT_E)
    CCLASS = 'at'
  CASE (CLASS_BE_E)
    CCLASS = 'be'
  CASE (CLASS_HR_E)
    CCLASS = 'hr'
  CASE (CLASS_DK_E)
    CCLASS = 'dk'
  CASE (CLASS_FI_E)
    CCLASS = 'fi'
  CASE (CLASS_FR_E)
    CCLASS = 'fr'
  CASE (CLASS_DE_E)
    CCLASS = 'de'
  CASE (CLASS_GR_E)
    CCLASS = 'gr'
  CASE (CLASS_HU_E)
    CCLASS = 'hu'
  CASE (CLASS_IS_E)
    CCLASS = 'is'
  CASE (CLASS_IE_E)
    CCLASS = 'ie'
  CASE (CLASS_IT_E)
    CCLASS = 'it'
  CASE (CLASS_NL_E)
    CCLASS = 'nl'
  CASE (CLASS_NO_E)
    CCLASS = 'no'
  CASE (CLASS_PT_E)
    CCLASS = 'pt'
  CASE (CLASS_SI_E)
    CCLASS = 'si'
  CASE (CLASS_ES_E)
    CCLASS = 'es'
  CASE (CLASS_SE_E)
    CCLASS = 'se'
  CASE (CLASS_CH_E)
    CCLASS = 'ch'
  CASE (CLASS_TR_E)
    CCLASS = 'tr'
  CASE (CLASS_UK_E)
    CCLASS = 'uk'
  CASE (CLASS_MS_E)
    CCLASS = 'ms'
  CASE (CLASS_MA_E)
    CCLASS = 'ma'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_CLASS )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_CLASS)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) ICLASS
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown iclass: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION ICLASS2CCLASS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CTYPE2ITYPE'
PP_THREAD_SAFE FUNCTION CTYPE2ITYPE( CTYPE, ITYPE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CTYPE
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: ITYPE
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CTYPE)) :: LOC_CTYPE

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_TYPE=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  ITYPE = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CTYPE, LOC_CTYPE, HOOKS )

  !> Select the class
  SELECT CASE ( TRIM(ADJUSTL(LOC_CTYPE)) )
  CASE ('0')
    ITYPE = TYPE_0_E
  CASE ('fg')
    ITYPE = TYPE_FG_E
  CASE ('an','analysis')
    ITYPE = TYPE_AN_E
  CASE ('ia')
    ITYPE = TYPE_IA_E
  CASE ('oi')
    ITYPE = TYPE_OI_E
  CASE ('3v')
    ITYPE = TYPE_3V_E
  CASE ('4v')
    ITYPE = TYPE_4V_E
  CASE ('3g')
    ITYPE = TYPE_3G_E
  CASE ('4g')
    ITYPE = TYPE_4G_E
  CASE ('fc', 'forecast')
    ITYPE = TYPE_FC_E
  CASE ('cf')
    ITYPE = TYPE_CF_E
  CASE ('pf')
    ITYPE = TYPE_PF_E
  CASE ('ef')
    ITYPE = TYPE_EF_E
  CASE ('ea')
    ITYPE = TYPE_EA_E
  CASE ('cm')
    ITYPE = TYPE_CM_E
  CASE ('cs')
    ITYPE = TYPE_CS_E
  CASE ('fp')
    ITYPE = TYPE_FP_E
  CASE ('em')
    ITYPE = TYPE_EM_E
  CASE ('es')
    ITYPE = TYPE_ES_E
  CASE ('fa')
    ITYPE = TYPE_FA_E
  CASE ('cl')
    ITYPE = TYPE_CL_E
  CASE ('si')
    ITYPE = TYPE_SI_E
  CASE ('s3')
    ITYPE = TYPE_S3_E
  CASE ('ed')
    ITYPE = TYPE_ED_E
  CASE ('tu')
    ITYPE = TYPE_TU_E
  CASE ('ff')
    ITYPE = TYPE_FF_E
  CASE ('of')
    ITYPE = TYPE_OF_E
  CASE ('efi')
    ITYPE = TYPE_EFI_E
  CASE ('efic')
    ITYPE = TYPE_EFIC_E
  CASE ('pb')
    ITYPE = TYPE_PB_E
  CASE ('ep')
    ITYPE = TYPE_EP_E
  CASE ('bf')
    ITYPE = TYPE_BF_E
  CASE ('cd')
    ITYPE = TYPE_CD_E
  CASE ('4i')
    ITYPE = TYPE_4I_E
  CASE ('go')
    ITYPE = TYPE_GO_E
  CASE ('me')
    ITYPE = TYPE_ME_E
  CASE ('pd')
    ITYPE = TYPE_PD_E
  CASE ('ci')
    ITYPE = TYPE_CI_E
  CASE ('sot')
    ITYPE = TYPE_SOT_E
  CASE ('eme')
    ITYPE = TYPE_EME_E
  CASE ('im')
    ITYPE = TYPE_IM_E
  CASE ('sim')
    ITYPE = TYPE_SIM_E
  CASE ('wem')
    ITYPE = TYPE_WEM_E
  CASE ('wes')
    ITYPE = TYPE_WES_E
  CASE ('cr')
    ITYPE = TYPE_CR_E
  CASE ('ses')
    ITYPE = TYPE_SES_E
  CASE ('taem')
    ITYPE = TYPE_TAEM_E
  CASE ('taes')
    ITYPE = TYPE_TAES_E
  CASE ('sg')
    ITYPE = TYPE_SG_E
  CASE ('sf')
    ITYPE = TYPE_SF_E
  CASE ('pa')
    ITYPE = TYPE_PA_E
  CASE ('icp')
    ITYPE = TYPE_ICP_E
  CASE ('sv')
    ITYPE = TYPE_SV_E
  CASE ('as')
    ITYPE = TYPE_AS_E
  CASE ('svar')
    ITYPE = TYPE_SVAR_E
  CASE ('cv')
    ITYPE = TYPE_CV_E
  CASE ('or')
    ITYPE = TYPE_OR_E
  CASE ('fx')
    ITYPE = TYPE_FX_E
  CASE ('fu')
    ITYPE = TYPE_FU_E
  CASE ('sfo')
    ITYPE = TYPE_SFO_E
  CASE ('tpa')
    ITYPE = TYPE_TPA_E
  CASE ('if')
    ITYPE = TYPE_IF_E
  CASE ('fcmean')
    ITYPE = TYPE_FCMEAN_E
  CASE ('fcmax')
    ITYPE = TYPE_FCMAX_E
  CASE ('fcmin')
    ITYPE = TYPE_FCMIN_E
  CASE ('fcstdev')
    ITYPE = TYPE_FCSTDEV_E
  CASE ('hcmean')
    ITYPE = TYPE_HCMEAN_E
  CASE ('ssd')
    ITYPE = TYPE_SSD_E
  CASE ('gsd')
    ITYPE = TYPE_GSD_E
  CASE ('ga')
    ITYPE = TYPE_GA_E
  CASE ('gai')
    ITYPE = TYPE_GAI_E
  CASE ('gbf')
    ITYPE = TYPE_GBF_E
  CASE ('pfc')
    ITYPE = TYPE_PFC_E
  CASE ('ppm')
    ITYPE = TYPE_PPM_E
  CASE ('gwt')
    ITYPE = TYPE_GWT_E
  CASE ('est')
    ITYPE = TYPE_EST_E
  CASE ('mpp')
    ITYPE = TYPE_MPP_E
  CASE ('ob')
    ITYPE = TYPE_OB_E
  CASE ('fb')
    ITYPE = TYPE_FB_E
  CASE ('ai')
    ITYPE = TYPE_AI_E
  CASE ('af')
    ITYPE = TYPE_AF_E
  CASE ('ab')
    ITYPE = TYPE_AB_E
  CASE ('tf')
    ITYPE = TYPE_TF_E
  CASE ('mfb')
    ITYPE = TYPE_MFB_E
  CASE ('ofb')
    ITYPE = TYPE_OFB_E
  CASE ('oai')
    ITYPE = TYPE_OAI_E
  CASE ('sfb')
    ITYPE = TYPE_SFB_E
  CASE ('fsoifb')
    ITYPE = TYPE_FSOIFB_E
  CASE ('fcdfb')
    ITYPE = TYPE_FCDFB_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_TYPE )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_TYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cclass: '//TRIM(ADJUSTL(CTYPE)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CTYPE2ITYPE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE

#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ITYPE2CTYPE'
PP_THREAD_SAFE FUNCTION ITYPE2CTYPE( ITYPE, CTYPE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: ITYPE
  CHARACTER(LEN=8),     INTENT(OUT)   :: CTYPE
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_TYPE=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CTYPE = REPEAT(' ', 8)

  !> Select the class
  SELECT CASE ( ITYPE )
  CASE (TYPE_0_E)
    CTYPE = '0'
  CASE (TYPE_FG_E)
    CTYPE = 'fg'
  CASE (TYPE_AN_E)
    CTYPE = 'an'
  CASE (TYPE_IA_E)
    CTYPE = 'ia'
  CASE (TYPE_OI_E)
    CTYPE = 'oi'
  CASE (TYPE_3V_E)
    CTYPE = '3v'
  CASE (TYPE_4V_E)
    CTYPE = '4v'
  CASE (TYPE_3G_E)
    CTYPE = '3g'
  CASE (TYPE_4G_E)
    CTYPE = '4g'
  CASE (TYPE_FC_E)
    CTYPE = 'fc'
  CASE (TYPE_CF_E)
    CTYPE = 'cf'
  CASE (TYPE_PF_E)
    CTYPE = 'pf'
  CASE (TYPE_EF_E)
    CTYPE = 'ef'
  CASE (TYPE_EA_E)
    CTYPE = 'ea'
  CASE (TYPE_CM_E)
    CTYPE = 'cm'
  CASE (TYPE_CS_E)
    CTYPE = 'cs'
  CASE (TYPE_FP_E)
    CTYPE = 'fp'
  CASE (TYPE_EM_E)
    CTYPE = 'em'
  CASE (TYPE_ES_E)
    CTYPE = 'es'
  CASE (TYPE_FA_E)
    CTYPE = 'fa'
  CASE (TYPE_CL_E)
    CTYPE = 'cl'
  CASE (TYPE_SI_E)
    CTYPE = 'si'
  CASE (TYPE_S3_E)
    CTYPE = 's3'
  CASE (TYPE_ED_E)
    CTYPE = 'ed'
  CASE (TYPE_TU_E)
    CTYPE = 'tu'
  CASE (TYPE_FF_E)
    CTYPE = 'ff'
  CASE (TYPE_OF_E)
    CTYPE = 'of'
  CASE (TYPE_EFI_E)
    CTYPE = 'efi'
  CASE (TYPE_EFIC_E)
    CTYPE = 'efic'
  CASE (TYPE_PB_E)
    CTYPE = 'pb'
  CASE (TYPE_EP_E)
    CTYPE = 'ep'
  CASE (TYPE_BF_E)
    CTYPE = 'bf'
  CASE (TYPE_CD_E)
    CTYPE = 'cd'
  CASE (TYPE_4I_E)
    CTYPE = '4i'
  CASE (TYPE_GO_E)
    CTYPE = 'go'
  CASE (TYPE_ME_E)
    CTYPE = 'me'
  CASE (TYPE_PD_E)
    CTYPE = 'pd'
  CASE (TYPE_CI_E)
    CTYPE = 'ci'
  CASE (TYPE_SOT_E)
    CTYPE = 'sot'
  CASE (TYPE_EME_E)
    CTYPE = 'eme'
  CASE (TYPE_IM_E)
    CTYPE = 'im'
  CASE (TYPE_SIM_E)
    CTYPE = 'sim'
  CASE (TYPE_WEM_E)
    CTYPE = 'wem'
  CASE (TYPE_WES_E)
    CTYPE = 'wes'
  CASE (TYPE_CR_E)
    CTYPE = 'cr'
  CASE (TYPE_SES_E)
    CTYPE = 'ses'
  CASE (TYPE_TAEM_E)
    CTYPE = 'taem'
  CASE (TYPE_TAES_E)
    CTYPE = 'taes'
  CASE (TYPE_SG_E)
    CTYPE = 'sg'
  CASE (TYPE_SF_E)
    CTYPE = 'sf'
  CASE (TYPE_PA_E)
    CTYPE = 'pa'
  CASE (TYPE_ICP_E)
    CTYPE = 'icp'
  CASE (TYPE_SV_E)
    CTYPE = 'sv'
  CASE (TYPE_AS_E)
    CTYPE = 'as'
  CASE (TYPE_SVAR_E)
    CTYPE = 'svar'
  CASE (TYPE_CV_E)
    CTYPE = 'cv'
  CASE (TYPE_OR_E)
    CTYPE = 'or'
  CASE (TYPE_FX_E)
    CTYPE = 'fx'
  CASE (TYPE_FU_E)
    CTYPE = 'fu'
  CASE (TYPE_SFO_E)
    CTYPE = 'sfo'
  CASE (TYPE_TPA_E)
    CTYPE = 'tpa'
  CASE (TYPE_IF_E)
    CTYPE = 'if'
  CASE (TYPE_FCMEAN_E)
    CTYPE = 'fcmean'
  CASE (TYPE_FCMAX_E)
    CTYPE = 'fcmax'
  CASE (TYPE_FCMIN_E)
    CTYPE = 'fcmin'
  CASE (TYPE_FCSTDEV_E)
    CTYPE = 'fcstdev'
  CASE (TYPE_HCMEAN_E)
    CTYPE = 'hcmean'
  CASE (TYPE_SSD_E)
    CTYPE = 'ssd'
  CASE (TYPE_GSD_E)
    CTYPE = 'gsd'
  CASE (TYPE_GA_E)
    CTYPE = 'ga'
  CASE (TYPE_GAI_E)
    CTYPE = 'gai'
  CASE (TYPE_GBF_E)
    CTYPE = 'gbf'
  CASE (TYPE_PFC_E)
    CTYPE = 'pfc'
  CASE (TYPE_PPM_E)
    CTYPE = 'ppm'
  CASE (TYPE_GWT_E)
    CTYPE = 'gwt'
  CASE (TYPE_EST_E)
    CTYPE = 'est'
  CASE (TYPE_MPP_E)
    CTYPE = 'mpp'
  CASE (TYPE_OB_E)
    CTYPE = 'ob'
  CASE (TYPE_FB_E)
    CTYPE = 'fb'
  CASE (TYPE_AI_E)
    CTYPE = 'ai'
  CASE (TYPE_AF_E)
    CTYPE = 'af'
  CASE (TYPE_AB_E)
    CTYPE = 'ab'
  CASE (TYPE_TF_E)
    CTYPE = 'tf'
  CASE (TYPE_MFB_E)
    CTYPE = 'mfb'
  CASE (TYPE_OFB_E)
    CTYPE = 'ofb'
  CASE (TYPE_OAI_E)
    CTYPE = 'oai'
  CASE (TYPE_SFB_E)
    CTYPE = 'sfb'
  CASE (TYPE_FSOIFB_E)
    CTYPE = 'fsoifb'
  CASE (TYPE_FCDFB_E)
    CTYPE = 'fcdfb'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_TYPE )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_TYPE)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) ITYPE
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown iclass: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION ITYPE2CTYPE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CSTREAM2ISTREAM'
PP_THREAD_SAFE FUNCTION CSTREAM2ISTREAM( CSTREAM, ISTREAM, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CSTREAM
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: ISTREAM
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CSTREAM)) :: LOC_CSTREAM

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_STREAM=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  ISTREAM = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CSTREAM, LOC_CSTREAM, HOOKS )

  !> Select the class
  SELECT CASE ( TRIM(ADJUSTL(LOC_CSTREAM)) )
  CASE ('0')
    ISTREAM = STREAM_0_E
  CASE ('fsob')
    ISTREAM = STREAM_FSOB_E
  CASE ('fsow')
    ISTREAM = STREAM_FSOW_E
  CASE ('dahc')
    ISTREAM = STREAM_DAHC_E
  CASE ('oper')
    ISTREAM = STREAM_OPER_E
  CASE ('scda')
    ISTREAM = STREAM_SCDA_E
  CASE ('scwv')
    ISTREAM = STREAM_SCWV_E
  CASE ('dcda')
    ISTREAM = STREAM_DCDA_E
  CASE ('dcwv')
    ISTREAM = STREAM_DCWV_E
  CASE ('enda')
    ISTREAM = STREAM_ENDA_E
  CASE ('efho')
    ISTREAM = STREAM_EFHO_E
  CASE ('enfh')
    ISTREAM = STREAM_ENFH_E
  CASE ('efov')
    ISTREAM = STREAM_EFOV_E
  CASE ('enfo')
    ISTREAM = STREAM_ENFO_E
  CASE ('sens')
    ISTREAM = STREAM_SENS_E
  CASE ('maed')
    ISTREAM = STREAM_MAED_E
  CASE ('amap')
    ISTREAM = STREAM_AMAP_E
  CASE ('efhc')
    ISTREAM = STREAM_EFHC_E
  CASE ('efhs')
    ISTREAM = STREAM_EFHS_E
  CASE ('toga')
    ISTREAM = STREAM_TOGA_E
  CASE ('cher')
    ISTREAM = STREAM_CHER_E
  CASE ('mnth')
    ISTREAM = STREAM_MNTH_E
  CASE ('supd')
    ISTREAM = STREAM_SUPD_E
  CASE ('wave')
    ISTREAM = STREAM_WAVE_E
  CASE ('ocea')
    ISTREAM = STREAM_OCEA_E
  CASE ('fgge')
    ISTREAM = STREAM_FGGE_E
  CASE ('egrr')
    ISTREAM = STREAM_EGRR_E
  CASE ('kwbc')
    ISTREAM = STREAM_KWBC_E
  CASE ('edzw')
    ISTREAM = STREAM_EDZW_E
  CASE ('lfpw')
    ISTREAM = STREAM_LFPW_E
  CASE ('rjtd')
    ISTREAM = STREAM_RJTD_E
  CASE ('cwao')
    ISTREAM = STREAM_CWAO_E
  CASE ('ammc')
    ISTREAM = STREAM_AMMC_E
  CASE ('efas')
    ISTREAM = STREAM_EFAS_E
  CASE ('efse')
    ISTREAM = STREAM_EFSE_E
  CASE ('efcl')
    ISTREAM = STREAM_EFCL_E
  CASE ('wfas')
    ISTREAM = STREAM_WFAS_E
  CASE ('wfcl')
    ISTREAM = STREAM_WFCL_E
  CASE ('wfse')
    ISTREAM = STREAM_WFSE_E
  CASE ('efrf')
    ISTREAM = STREAM_EFRF_E
  CASE ('efsr')
    ISTREAM = STREAM_EFSR_E
  CASE ('wfrf')
    ISTREAM = STREAM_WFRF_E
  CASE ('wfsr')
    ISTREAM = STREAM_WFSR_E
  CASE ('msdc')
    ISTREAM = STREAM_MSDC_E
  CASE ('moda')
    ISTREAM = STREAM_MODA_E
  CASE ('monr')
    ISTREAM = STREAM_MONR_E
  CASE ('mnvr')
    ISTREAM = STREAM_MNVR_E
  CASE ('msda')
    ISTREAM = STREAM_MSDA_E
  CASE ('mdfa')
    ISTREAM = STREAM_MDFA_E
  CASE ('dacl')
    ISTREAM = STREAM_DACL_E
  CASE ('wehs')
    ISTREAM = STREAM_WEHS_E
  CASE ('ewho')
    ISTREAM = STREAM_EWHO_E
  CASE ('enwh')
    ISTREAM = STREAM_ENWH_E
  CASE ('wamo')
    ISTREAM = STREAM_WAMO_E
  CASE ('waef')
    ISTREAM = STREAM_WAEF_E
  CASE ('wasf')
    ISTREAM = STREAM_WASF_E
  CASE ('mawv')
    ISTREAM = STREAM_MAWV_E
  CASE ('ewhc')
    ISTREAM = STREAM_EWHC_E
  CASE ('wvhc')
    ISTREAM = STREAM_WVHC_E
  CASE ('weov')
    ISTREAM = STREAM_WEOV_E
  CASE ('wavm')
    ISTREAM = STREAM_WAVM_E
  CASE ('ewda')
    ISTREAM = STREAM_EWDA_E
  CASE ('dacw')
    ISTREAM = STREAM_DACW_E
  CASE ('seas')
    ISTREAM = STREAM_SEAS_E
  CASE ('sfmm')
    ISTREAM = STREAM_SFMM_E
  CASE ('swmm')
    ISTREAM = STREAM_SWMM_E
  CASE ('mofc')
    ISTREAM = STREAM_MOFC_E
  CASE ('mofm')
    ISTREAM = STREAM_MOFM_E
  CASE ('wamf')
    ISTREAM = STREAM_WAMF_E
  CASE ('wmfm')
    ISTREAM = STREAM_WMFM_E
  CASE ('smma')
    ISTREAM = STREAM_SMMA_E
  CASE ('clte')
    ISTREAM = STREAM_CLTE_E
  CASE ('clmn')
    ISTREAM = STREAM_CLMN_E
  CASE ('dame')
    ISTREAM = STREAM_DAME_E
  CASE ('seap')
    ISTREAM = STREAM_SEAP_E
  CASE ('eefh')
    ISTREAM = STREAM_EEFH_E
  CASE ('eehs')
    ISTREAM = STREAM_EEHS_E
  CASE ('eefo')
    ISTREAM = STREAM_EEFO_E
  CASE ('weef')
    ISTREAM = STREAM_WEEF_E
  CASE ('weeh')
    ISTREAM = STREAM_WEEH_E
  CASE ('wees')
    ISTREAM = STREAM_WEES_E
  CASE ('mnfc')
    ISTREAM = STREAM_MNFC_E
  CASE ('mnfh')
    ISTREAM = STREAM_MNFH_E
  CASE ('mnfa')
    ISTREAM = STREAM_MNFA_E
  CASE ('mnfw')
    ISTREAM = STREAM_MNFW_E
  CASE ('mfhw')
    ISTREAM = STREAM_MFHW_E
  CASE ('mfaw')
    ISTREAM = STREAM_MFAW_E
  CASE ('mnfm')
    ISTREAM = STREAM_MNFM_E
  CASE ('mfhm')
    ISTREAM = STREAM_MFHM_E
  CASE ('mfam')
    ISTREAM = STREAM_MFAM_E
  CASE ('mfwm')
    ISTREAM = STREAM_MFWM_E
  CASE ('mhwm')
    ISTREAM = STREAM_MHWM_E
  CASE ('mawm')
    ISTREAM = STREAM_MAWM_E
  CASE ('mmsf')
    ISTREAM = STREAM_MMSF_E
  CASE ('msmm')
    ISTREAM = STREAM_MSMM_E
  CASE ('wams')
    ISTREAM = STREAM_WAMS_E
  CASE ('mswm')
    ISTREAM = STREAM_MSWM_E
  CASE ('mmsa')
    ISTREAM = STREAM_MMSA_E
  CASE ('mmaf')
    ISTREAM = STREAM_MMAF_E
  CASE ('mmam')
    ISTREAM = STREAM_MMAM_E
  CASE ('mmaw')
    ISTREAM = STREAM_MMAW_E
  CASE ('mmwm')
    ISTREAM = STREAM_MMWM_E
  CASE ('esmm')
    ISTREAM = STREAM_ESMM_E
  CASE ('ehmm')
    ISTREAM = STREAM_EHMM_E
  CASE ('edmm')
    ISTREAM = STREAM_EDMM_E
  CASE ('edmo')
    ISTREAM = STREAM_EDMO_E
  CASE ('ewmo')
    ISTREAM = STREAM_EWMO_E
  CASE ('ewmm')
    ISTREAM = STREAM_EWMM_E
  CASE ('espd')
    ISTREAM = STREAM_ESPD_E
  CASE ('lwda')
    ISTREAM = STREAM_LWDA_E
  CASE ('lwwv')
    ISTREAM = STREAM_LWWV_E
  CASE ('elda')
    ISTREAM = STREAM_ELDA_E
  CASE ('ewla')
    ISTREAM = STREAM_EWLA_E
  CASE ('wamd')
    ISTREAM = STREAM_WAMD_E
  CASE ('gfas')
    ISTREAM = STREAM_GFAS_E
  CASE ('ocda')
    ISTREAM = STREAM_OCDA_E
  CASE ('olda')
    ISTREAM = STREAM_OLDA_E
  CASE ('gfra')
    ISTREAM = STREAM_GFRA_E
  CASE ('rfsd')
    ISTREAM = STREAM_RFSD_E
  CASE ('cnrm')
    ISTREAM = STREAM_CNRM_E
  CASE ('mpic')
    ISTREAM = STREAM_MPIC_E
  CASE ('ukmo')
    ISTREAM = STREAM_UKMO_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_STREAM )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_STREAM)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cclass: '//TRIM(ADJUSTL(CSTREAM)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CSTREAM2ISTREAM
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE

#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ISTREAM2CSTREAM'
PP_THREAD_SAFE FUNCTION ISTREAM2CSTREAM( ISTREAM, CSTREAM, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: ISTREAM
  CHARACTER(LEN=8),     INTENT(OUT)   :: CSTREAM
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_STREAM=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CSTREAM = REPEAT(' ', 8)

  !> Select the class
  SELECT CASE ( ISTREAM )
  CASE (STREAM_0_E)
    CSTREAM = '0'
  CASE (STREAM_FSOB_E)
    CSTREAM = 'fsob'
  CASE (STREAM_FSOW_E)
    CSTREAM = 'fsow'
  CASE (STREAM_DAHC_E)
    CSTREAM = 'dahc'
  CASE (STREAM_OPER_E)
    CSTREAM = 'oper'
  CASE (STREAM_SCDA_E)
    CSTREAM = 'scda'
  CASE (STREAM_SCWV_E)
    CSTREAM = 'scwv'
  CASE (STREAM_DCDA_E)
    CSTREAM = 'dcda'
  CASE (STREAM_DCWV_E)
    CSTREAM = 'dcwv'
  CASE (STREAM_ENDA_E)
    CSTREAM = 'enda'
  CASE (STREAM_EFHO_E)
    CSTREAM = 'efho'
  CASE (STREAM_ENFH_E)
    CSTREAM = 'enfh'
  CASE (STREAM_EFOV_E)
    CSTREAM = 'efov'
  CASE (STREAM_ENFO_E)
    CSTREAM = 'enfo'
  CASE (STREAM_SENS_E)
    CSTREAM = 'sens'
  CASE (STREAM_MAED_E)
    CSTREAM = 'maed'
  CASE (STREAM_AMAP_E)
    CSTREAM = 'amap'
  CASE (STREAM_EFHC_E)
    CSTREAM = 'efhc'
  CASE (STREAM_EFHS_E)
    CSTREAM = 'efhs'
  CASE (STREAM_TOGA_E)
    CSTREAM = 'toga'
  CASE (STREAM_CHER_E)
    CSTREAM = 'cher'
  CASE (STREAM_MNTH_E)
    CSTREAM = 'mnth'
  CASE (STREAM_SUPD_E)
    CSTREAM = 'supd'
  CASE (STREAM_WAVE_E)
    CSTREAM = 'wave'
  CASE (STREAM_OCEA_E)
    CSTREAM = 'ocea'
  CASE (STREAM_FGGE_E)
    CSTREAM = 'fgge'
  CASE (STREAM_EGRR_E)
    CSTREAM = 'egrr'
  CASE (STREAM_KWBC_E)
    CSTREAM = 'kwbc'
  CASE (STREAM_EDZW_E)
    CSTREAM = 'edzw'
  CASE (STREAM_LFPW_E)
    CSTREAM = 'lfpw'
  CASE (STREAM_RJTD_E)
    CSTREAM = 'rjtd'
  CASE (STREAM_CWAO_E)
    CSTREAM = 'cwao'
  CASE (STREAM_AMMC_E)
    CSTREAM = 'ammc'
  CASE (STREAM_EFAS_E)
    CSTREAM = 'efas'
  CASE (STREAM_EFSE_E)
    CSTREAM = 'efse'
  CASE (STREAM_EFCL_E)
    CSTREAM = 'efcl'
  CASE (STREAM_WFAS_E)
    CSTREAM = 'wfas'
  CASE (STREAM_WFCL_E)
    CSTREAM = 'wfcl'
  CASE (STREAM_WFSE_E)
    CSTREAM = 'wfse'
  CASE (STREAM_EFRF_E)
    CSTREAM = 'efrf'
  CASE (STREAM_EFSR_E)
    CSTREAM = 'efsr'
  CASE (STREAM_WFRF_E)
    CSTREAM = 'wfrf'
  CASE (STREAM_WFSR_E)
    CSTREAM = 'wfsr'
  CASE (STREAM_MSDC_E)
    CSTREAM = 'msdc'
  CASE (STREAM_MODA_E)
    CSTREAM = 'moda'
  CASE (STREAM_MONR_E)
    CSTREAM = 'monr'
  CASE (STREAM_MNVR_E)
    CSTREAM = 'mnvr'
  CASE (STREAM_MSDA_E)
    CSTREAM = 'msda'
  CASE (STREAM_MDFA_E)
    CSTREAM = 'mdfa'
  CASE (STREAM_DACL_E)
    CSTREAM = 'dacl'
  CASE (STREAM_WEHS_E)
    CSTREAM = 'wehs'
  CASE (STREAM_EWHO_E)
    CSTREAM = 'ewho'
  CASE (STREAM_ENWH_E)
    CSTREAM = 'enwh'
  CASE (STREAM_WAMO_E)
    CSTREAM = 'wamo'
  CASE (STREAM_WAEF_E)
    CSTREAM = 'waef'
  CASE (STREAM_WASF_E)
    CSTREAM = 'wasf'
  CASE (STREAM_MAWV_E)
    CSTREAM = 'mawv'
  CASE (STREAM_EWHC_E)
    CSTREAM = 'ewhc'
  CASE (STREAM_WVHC_E)
    CSTREAM = 'wvhc'
  CASE (STREAM_WEOV_E)
    CSTREAM = 'weov'
  CASE (STREAM_WAVM_E)
    CSTREAM = 'wavm'
  CASE (STREAM_EWDA_E)
    CSTREAM = 'ewda'
  CASE (STREAM_DACW_E)
    CSTREAM = 'dacw'
  CASE (STREAM_SEAS_E)
    CSTREAM = 'seas'
  CASE (STREAM_SFMM_E)
    CSTREAM = 'sfmm'
  CASE (STREAM_SWMM_E)
    CSTREAM = 'swmm'
  CASE (STREAM_MOFC_E)
    CSTREAM = 'mofc'
  CASE (STREAM_MOFM_E)
    CSTREAM = 'mofm'
  CASE (STREAM_WAMF_E)
    CSTREAM = 'wamf'
  CASE (STREAM_WMFM_E)
    CSTREAM = 'wmfm'
  CASE (STREAM_SMMA_E)
    CSTREAM = 'smma'
  CASE (STREAM_CLTE_E)
    CSTREAM = 'clte'
  CASE (STREAM_CLMN_E)
    CSTREAM = 'clmn'
  CASE (STREAM_DAME_E)
    CSTREAM = 'dame'
  CASE (STREAM_SEAP_E)
    CSTREAM = 'seap'
  CASE (STREAM_EEFH_E)
    CSTREAM = 'eefh'
  CASE (STREAM_EEHS_E)
    CSTREAM = 'eehs'
  CASE (STREAM_EEFO_E)
    CSTREAM = 'eefo'
  CASE (STREAM_WEEF_E)
    CSTREAM = 'weef'
  CASE (STREAM_WEEH_E)
    CSTREAM = 'weeh'
  CASE (STREAM_WEES_E)
    CSTREAM = 'wees'
  CASE (STREAM_MNFC_E)
    CSTREAM = 'mnfc'
  CASE (STREAM_MNFH_E)
    CSTREAM = 'mnfh'
  CASE (STREAM_MNFA_E)
    CSTREAM = 'mnfa'
  CASE (STREAM_MNFW_E)
    CSTREAM = 'mnfw'
  CASE (STREAM_MFHW_E)
    CSTREAM = 'mfhw'
  CASE (STREAM_MFAW_E)
    CSTREAM = 'mfaw'
  CASE (STREAM_MNFM_E)
    CSTREAM = 'mnfm'
  CASE (STREAM_MFHM_E)
    CSTREAM = 'mfhm'
  CASE (STREAM_MFAM_E)
    CSTREAM = 'mfam'
  CASE (STREAM_MFWM_E)
    CSTREAM = 'mfwm'
  CASE (STREAM_MHWM_E)
    CSTREAM = 'mhwm'
  CASE (STREAM_MAWM_E)
    CSTREAM = 'mawm'
  CASE (STREAM_MMSF_E)
    CSTREAM = 'mmsf'
  CASE (STREAM_MSMM_E)
    CSTREAM = 'msmm'
  CASE (STREAM_WAMS_E)
    CSTREAM = 'wams'
  CASE (STREAM_MSWM_E)
    CSTREAM = 'mswm'
  CASE (STREAM_MMSA_E)
    CSTREAM = 'mmsa'
  CASE (STREAM_MMAF_E)
    CSTREAM = 'mmaf'
  CASE (STREAM_MMAM_E)
    CSTREAM = 'mmam'
  CASE (STREAM_MMAW_E)
    CSTREAM = 'mmaw'
  CASE (STREAM_MMWM_E)
    CSTREAM = 'mmwm'
  CASE (STREAM_ESMM_E)
    CSTREAM = 'esmm'
  CASE (STREAM_EHMM_E)
    CSTREAM = 'ehmm'
  CASE (STREAM_EDMM_E)
    CSTREAM = 'edmm'
  CASE (STREAM_EDMO_E)
    CSTREAM = 'edmo'
  CASE (STREAM_EWMO_E)
    CSTREAM = 'ewmo'
  CASE (STREAM_EWMM_E)
    CSTREAM = 'ewmm'
  CASE (STREAM_ESPD_E)
    CSTREAM = 'espd'
  CASE (STREAM_LWDA_E)
    CSTREAM = 'lwda'
  CASE (STREAM_LWWV_E)
    CSTREAM = 'lwwv'
  CASE (STREAM_ELDA_E)
    CSTREAM = 'elda'
  CASE (STREAM_EWLA_E)
    CSTREAM = 'ewla'
  CASE (STREAM_WAMD_E)
    CSTREAM = 'wamd'
  CASE (STREAM_GFAS_E)
    CSTREAM = 'gfas'
  CASE (STREAM_OCDA_E)
    CSTREAM = 'ocda'
  CASE (STREAM_OLDA_E)
    CSTREAM = 'olda'
  CASE (STREAM_GFRA_E)
    CSTREAM = 'gfra'
  CASE (STREAM_RFSD_E)
    CSTREAM = 'rfsd'
  CASE (STREAM_CNRM_E)
    CSTREAM = 'cnrm'
  CASE (STREAM_MPIC_E)
    CSTREAM = 'mpic'
  CASE (STREAM_UKMO_E)
    CSTREAM = 'ukmo'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_STREAM )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_STREAM)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) ISTREAM
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown iclass: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION ISTREAM2CSTREAM
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IDATASTRUCT2CDATASTRUCT'
PP_THREAD_SAFE FUNCTION IDATASTRUCT2CDATASTRUCT( IDATASTRUCT, CDATASTRUCT, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IDATASTRUCT
  CHARACTER(LEN=16),    INTENT(OUT)   :: CDATASTRUCT
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_MSGINTFLD_UNARY=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CDATASTRUCT = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( IDATASTRUCT )
  CASE ( FORTRAN_MESSAGE_SOURCE_E )
    CDATASTRUCT = 'msg'
  CASE ( PARAMETRIZATION_SOURCE_E )
    CDATASTRUCT = 'par'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_MSGINTFLD_UNARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=1024) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_MSGINTFLD_UNARY)
      TMPSTR = REPEAT(' ', 1024)
      WRITE(TMPSTR,*) IDATASTRUCT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown idatastruct: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IDATASTRUCT2CDATASTRUCT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CDATASTRUCT2IDATASTRUCT'
PP_THREAD_SAFE FUNCTION CDATASTRUCT2IDATASTRUCT( CDATASTRUCT, IDATASTRUCT, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CDATASTRUCT
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IDATASTRUCT
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CDATASTRUCT)) :: LOC_CDATASTRUCT

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_MSGINTFLD_UNARY=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IDATASTRUCT = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CDATASTRUCT, LOC_CDATASTRUCT, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CDATASTRUCT)) )
  CASE ( 'msg' )
    IDATASTRUCT = FORTRAN_MESSAGE_SOURCE_E
  CASE ( 'par' )
    IDATASTRUCT = PARAMETRIZATION_SOURCE_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_MSGINTFLD_UNARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_MSGINTFLD_UNARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cintop_unary: '//TRIM(ADJUSTL(CDATASTRUCT)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CDATASTRUCT2IDATASTRUCT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE









#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IINTOPBINARY2CINTOPBINARY'
PP_THREAD_SAFE FUNCTION IINTOPBINARY2CINTOPBINARY( IINTOPBINARY, CINTOPBINARY, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IINTOPBINARY
  CHARACTER(LEN=16),    INTENT(OUT)   :: CINTOPBINARY
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_INTOP_BINARY=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CINTOPBINARY = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( IINTOPBINARY )

  CASE ( INTOP_BINARY_MUL_E )
    CINTOPBINARY = 'mul'
  CASE ( INTOP_BINARY_DIV_E )
    CINTOPBINARY = 'div'
  CASE ( INTOP_BINARY_SUM_E )
    CINTOPBINARY = 'sum'
  CASE ( INTOP_BINARY_SUB_E )
    CINTOPBINARY = 'sub'
  CASE ( INTOP_BINARY_POW_E )
    CINTOPBINARY = 'pow'
  CASE ( INTOP_BINARY_MOD_E )
    CINTOPBINARY = 'mod'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_INTOP_BINARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_INTOP_BINARY)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IINTOPBINARY
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown iintop_binary: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IINTOPBINARY2CINTOPBINARY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CINTOPBINARY2IINTOPBINARY'
PP_THREAD_SAFE FUNCTION CINTOPBINARY2IINTOPBINARY( CINTOPBINARY, IINTOPBINARY, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CINTOPBINARY
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IINTOPBINARY
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CINTOPBINARY)) :: LOC_CINTOPBINARY

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_INTOP_BINARY=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IINTOPBINARY = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CINTOPBINARY, LOC_CINTOPBINARY, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CINTOPBINARY)) )
  CASE ( 'mul' )
    IINTOPBINARY = INTOP_BINARY_MUL_E
  CASE ( 'div' )
    IINTOPBINARY = INTOP_BINARY_DIV_E
  CASE ( 'sum' )
    IINTOPBINARY = INTOP_BINARY_SUM_E
  CASE ( 'sub' )
    IINTOPBINARY = INTOP_BINARY_SUB_E
  CASE ( 'pow' )
    IINTOPBINARY = INTOP_BINARY_POW_E
  CASE ( 'mod' )
    IINTOPBINARY = INTOP_BINARY_MOD_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_INTOP_BINARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_INTOP_BINARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cintop_binary: '//TRIM(ADJUSTL(CINTOPBINARY)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CINTOPBINARY2IINTOPBINARY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IINTOPUNARY2CINTOPUNARY'
PP_THREAD_SAFE FUNCTION IINTOPUNARY2CINTOPUNARY( IINTOPUNARY, CINTOPUNARY, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IINTOPUNARY
  CHARACTER(LEN=16),    INTENT(OUT)   :: CINTOPUNARY
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_INTOP_UNARY=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CINTOPUNARY = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( IINTOPUNARY )

  CASE ( INTOP_UNARY_NEG_E )
    CINTOPUNARY = 'neg'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_INTOP_UNARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_INTOP_UNARY)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IINTOPUNARY
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown iintop_unary: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IINTOPUNARY2CINTOPUNARY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CINTOPUNARY2IINTOPUNARY'
PP_THREAD_SAFE FUNCTION CINTOPUNARY2IINTOPUNARY( CINTOPUNARY, IINTOPUNARY, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CINTOPUNARY
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IINTOPUNARY
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CINTOPUNARY)) :: LOC_CINTOPUNARY

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_INTOP_UNARY=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IINTOPUNARY = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CINTOPUNARY, LOC_CINTOPUNARY, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CINTOPUNARY)) )
  CASE ( 'neg' )
    IINTOPUNARY = INTOP_UNARY_NEG_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_INTOP_UNARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_INTOP_UNARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cintop_unary: '//TRIM(ADJUSTL(CINTOPUNARY)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CINTOPUNARY2IINTOPUNARY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IINTOPFUNCCALL2CINTOPFUNCCALL'
PP_THREAD_SAFE FUNCTION IINTOPFUNCCALL2CINTOPFUNCCALL( IINTOPFUNCCALL, CINTOPFUNCCALL, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IINTOPFUNCCALL
  CHARACTER(LEN=16),    INTENT(OUT)   :: CINTOPFUNCCALL
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_INTOP_UNARY=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CINTOPFUNCCALL = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( IINTOPFUNCCALL )

  CASE ( INTOP_FUNCTION_CALL_STEPL_E )
    CINTOPFUNCCALL = 'stepl'
  CASE ( INTOP_FUNCTION_CALL_STEPR_E )
    CINTOPFUNCCALL = 'stepr'
  CASE ( INTOP_FUNCTION_CALL_ABS_E )
    CINTOPFUNCCALL = 'abs'
  CASE ( INTOP_FUNCTION_CALL_SIGN_E )
    CINTOPFUNCCALL = 'sign'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_INTOP_UNARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_INTOP_UNARY)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IINTOPFUNCCALL
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown iintop_function_call: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IINTOPFUNCCALL2CINTOPFUNCCALL
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CINTOPFUNCCALL2IINTOPFUNCCALL'
PP_THREAD_SAFE FUNCTION CINTOPFUNCCALL2IINTOPFUNCCALL( CINTOPFUNCCALL, IINTOPFUNCCALL, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CINTOPFUNCCALL
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IINTOPFUNCCALL
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CINTOPFUNCCALL)) :: LOC_CINTOPFUNCCALL

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_INTOP_UNARY=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IINTOPFUNCCALL = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CINTOPFUNCCALL, LOC_CINTOPFUNCCALL, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CINTOPFUNCCALL)) )
  CASE ( 'stepl' )
    IINTOPFUNCCALL = INTOP_FUNCTION_CALL_STEPL_E
  CASE ( 'stepr' )
    IINTOPFUNCCALL = INTOP_FUNCTION_CALL_STEPR_E
  CASE ( 'abs' )
    IINTOPFUNCCALL = INTOP_FUNCTION_CALL_ABS_E
  CASE ( 'sign' )
    IINTOPFUNCCALL = INTOP_FUNCTION_CALL_SIGN_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_INTOP_UNARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_INTOP_UNARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cintop_function_call: '//TRIM(ADJUSTL(CINTOPFUNCCALL)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CINTOPFUNCCALL2IINTOPFUNCCALL
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IFLOATOPBINARY2CFLOATOPBINARY'
PP_THREAD_SAFE FUNCTION IFLOATOPBINARY2CFLOATOPBINARY( IFLOATOPBINARY, CFLOATOPBINARY, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IFLOATOPBINARY
  CHARACTER(LEN=16),    INTENT(OUT)   :: CFLOATOPBINARY
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_FLOATOP_BINARY=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CFLOATOPBINARY = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( IFLOATOPBINARY )

  CASE ( FLOATOP_BINARY_MUL_E )
    CFLOATOPBINARY = 'mul'
  CASE ( FLOATOP_BINARY_DIV_E )
    CFLOATOPBINARY = 'div'
  CASE ( FLOATOP_BINARY_SUM_E )
    CFLOATOPBINARY = 'sum'
  CASE ( FLOATOP_BINARY_SUB_E )
    CFLOATOPBINARY = 'sub'
  CASE ( FLOATOP_BINARY_POW_E )
    CFLOATOPBINARY = 'pow'
  CASE ( FLOATOP_BINARY_MOD_E )
    CFLOATOPBINARY = 'mod'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_FLOATOP_BINARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_FLOATOP_BINARY)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IFLOATOPBINARY
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown ifloatop_binary: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IFLOATOPBINARY2CFLOATOPBINARY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CFLOATOPBINARY2IFLOATOPBINARY'
PP_THREAD_SAFE FUNCTION CFLOATOPBINARY2IFLOATOPBINARY( CFLOATOPBINARY, IFLOATOPBINARY, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CFLOATOPBINARY
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IFLOATOPBINARY
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CFLOATOPBINARY)) :: LOC_CFLOATOPBINARY

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_FLOATOP_BINARY=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IFLOATOPBINARY = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CFLOATOPBINARY, LOC_CFLOATOPBINARY, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CFLOATOPBINARY)) )
  CASE ( 'mul' )
    IFLOATOPBINARY = FLOATOP_BINARY_MUL_E
  CASE ( 'div' )
    IFLOATOPBINARY = FLOATOP_BINARY_DIV_E
  CASE ( 'sum' )
    IFLOATOPBINARY = FLOATOP_BINARY_SUM_E
  CASE ( 'sub' )
    IFLOATOPBINARY = FLOATOP_BINARY_SUB_E
  CASE ( 'pow' )
    IFLOATOPBINARY = FLOATOP_BINARY_POW_E
  CASE ( 'mod' )
    IFLOATOPBINARY = FLOATOP_BINARY_MOD_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_FLOATOP_BINARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_FLOATOP_BINARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cfloatop_binary: '//TRIM(ADJUSTL(CFLOATOPBINARY)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CFLOATOPBINARY2IFLOATOPBINARY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IFLOATOPUNARY2CFLOATOPUNARY'
PP_THREAD_SAFE FUNCTION IFLOATOPUNARY2CFLOATOPUNARY( IFLOATOPUNARY, CFLOATOPUNARY, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IFLOATOPUNARY
  CHARACTER(LEN=16),    INTENT(OUT)   :: CFLOATOPUNARY
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_FLOATOP_UNARY=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CFLOATOPUNARY = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( IFLOATOPUNARY )

  CASE ( FLOATOP_UNARY_NEG_E )
    CFLOATOPUNARY = 'neg'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_FLOATOP_UNARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_FLOATOP_UNARY)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IFLOATOPUNARY
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown ifloatop_unary: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IFLOATOPUNARY2CFLOATOPUNARY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CFLOATOPUNARY2IFLOATOPUNARY'
PP_THREAD_SAFE FUNCTION CFLOATOPUNARY2IFLOATOPUNARY( CFLOATOPUNARY, IFLOATOPUNARY, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CFLOATOPUNARY
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IFLOATOPUNARY
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CFLOATOPUNARY)) :: LOC_CFLOATOPUNARY

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_FLOATOP_UNARY=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IFLOATOPUNARY = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CFLOATOPUNARY, LOC_CFLOATOPUNARY, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CFLOATOPUNARY)) )
  CASE ( 'neg' )
    IFLOATOPUNARY = FLOATOP_UNARY_NEG_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_FLOATOP_UNARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_FLOATOP_UNARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cfloatop_unary: '//TRIM(ADJUSTL(CFLOATOPUNARY)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CFLOATOPUNARY2IFLOATOPUNARY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IFLOATOPFUNCCALL2CFLOATOPFUNCCALL'
PP_THREAD_SAFE FUNCTION IFLOATOPFUNCCALL2CFLOATOPFUNCCALL( IFLOATOPFUNCCALL, CFLOATOPFUNCCALL, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IFLOATOPFUNCCALL
  CHARACTER(LEN=16),    INTENT(OUT)   :: CFLOATOPFUNCCALL
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_FLOATOP_UNARY=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CFLOATOPFUNCCALL = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( IFLOATOPFUNCCALL )

  CASE ( FLOATOP_FUNCTION_CALL_STEPL_E )
    CFLOATOPFUNCCALL = 'stepl'
  CASE ( FLOATOP_FUNCTION_CALL_STEPR_E )
    CFLOATOPFUNCCALL = 'stepr'
  CASE ( FLOATOP_FUNCTION_CALL_ABS_E )
    CFLOATOPFUNCCALL = 'abs'
  CASE ( FLOATOP_FUNCTION_CALL_SIGN_E )
    CFLOATOPFUNCCALL = 'sign'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_FLOATOP_UNARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_FLOATOP_UNARY)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IFLOATOPFUNCCALL
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown ifloatop_function_call: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IFLOATOPFUNCCALL2CFLOATOPFUNCCALL
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CFLOATOPFUNCCALL2IFLOATOPFUNCCALL'
PP_THREAD_SAFE FUNCTION CFLOATOPFUNCCALL2IFLOATOPFUNCCALL( CFLOATOPFUNCCALL, IFLOATOPFUNCCALL, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CFLOATOPFUNCCALL
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IFLOATOPFUNCCALL
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CFLOATOPFUNCCALL)) :: LOC_CFLOATOPFUNCCALL

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_FLOATOP_UNARY=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IFLOATOPFUNCCALL = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CFLOATOPFUNCCALL, LOC_CFLOATOPFUNCCALL, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CFLOATOPFUNCCALL)) )
  CASE ( 'stepl' )
    IFLOATOPFUNCCALL = FLOATOP_FUNCTION_CALL_STEPL_E
  CASE ( 'stepr' )
    IFLOATOPFUNCCALL = FLOATOP_FUNCTION_CALL_STEPR_E
  CASE ( 'abs' )
    IFLOATOPFUNCCALL = FLOATOP_FUNCTION_CALL_ABS_E
  CASE ( 'sign' )
    IFLOATOPFUNCCALL = FLOATOP_FUNCTION_CALL_SIGN_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_FLOATOP_UNARY )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_FLOATOP_UNARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cfloatop_function_call: '//TRIM(ADJUSTL(CFLOATOPFUNCCALL)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CFLOATOPFUNCCALL2IFLOATOPFUNCCALL
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE







#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IPARAMTYPE2CPARAMTYPE'
PP_THREAD_SAFE FUNCTION IPARAMTYPE2CPARAMTYPE( IPARAMTYPE, CPARAMTYPE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IPARAMTYPE
  CHARACTER(LEN=16),    INTENT(OUT)   :: CPARAMTYPE
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_IPARAMTYPE=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CPARAMTYPE = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( IPARAMTYPE )
  CASE ( PARAMTYPE_CHEMICAL_E )
    CPARAMTYPE = 'chemical'
  CASE ( PARAMTYPE_OPTICAL_E )
    CPARAMTYPE = 'optical'
  CASE ( PARAMTYPE_CHEMICAL_OPTICAL_E )
    CPARAMTYPE = 'chemical-optical'
  ! CASE ( PARAMTYPE_AEROSOL_E )
  !   CPARAMTYPE = 'aerosol'
  CASE ( PARAMTYPE_BASE_E )
    CPARAMTYPE = 'base'
  CASE ( PARAMTYPE_WAVE_SPECTRA_E )
    CPARAMTYPE = 'wave-spectra'
  CASE ( PARAMTYPE_TILE_E )
    CPARAMTYPE = 'tile'
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_IPARAMTYPE )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_IPARAMTYPE)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IPARAMTYPE
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown ifloatop_function_call: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IPARAMTYPE2CPARAMTYPE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CPARAMTYPE2IPARAMTYPE'
PP_THREAD_SAFE FUNCTION CPARAMTYPE2IPARAMTYPE( CPARAMTYPE, IPARAMTYPE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CPARAMTYPE
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IPARAMTYPE
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CPARAMTYPE)) :: LOC_CPARAMTYPE

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_CPARAMTYPE=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IPARAMTYPE = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CPARAMTYPE, LOC_CPARAMTYPE, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CPARAMTYPE)) )
  CASE ( 'chemical' )
    IPARAMTYPE = PARAMTYPE_CHEMICAL_E
  CASE ( 'optical' )
    IPARAMTYPE = PARAMTYPE_OPTICAL_E
  CASE ( 'chemical-optical' )
    IPARAMTYPE = PARAMTYPE_CHEMICAL_OPTICAL_E
  ! CASE ( 'aerosol' )
  !   IPARAMTYPE = PARAMTYPE_AEROSOL_E
  CASE ( 'base' )
    IPARAMTYPE = PARAMTYPE_BASE_E
  CASE ( 'wave-spectra' )
    IPARAMTYPE = PARAMTYPE_WAVE_SPECTRA_E
  CASE ( 'tile' )
    IPARAMTYPE = PARAMTYPE_TILE_E
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_CPARAMTYPE )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
    CASE (ERRFLAG_UNKNOWN_CPARAMTYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown cfloatop_function_call: '//TRIM(ADJUSTL(CPARAMTYPE)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CPARAMTYPE2IPARAMTYPE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE






#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IORIGIN2CORIGIN'
PP_THREAD_SAFE FUNCTION IORIGIN2CORIGIN( IORIGIN, CORIGIN, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: LOG_UTILS_MOD,     ONLY: TO_STRING
  USE :: LOG_UTILS_MOD,     ONLY: MAX_STR_LEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IORIGIN
  CHARACTER(LEN=16),    INTENT(OUT)   :: CORIGIN
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=MAX_STR_LEN) :: CTEMP

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONVERT_ERROR=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CORIGIN = REPEAT(' ', 16)

  !> Select the prefix
  SELECT CASE ( IORIGIN )

  case ( ORIGIN_AMMC )
    CORIGIN =  'ammc'
  case ( ORIGIN_RUMS )
    CORIGIN =  'rums'
  case ( ORIGIN_KWBC )
    CORIGIN =  'kwbc'
  case ( ORIGIN_FAPR )
    CORIGIN =  'fapr'
  case ( ORIGIN_VABB )
    CORIGIN =  'vabb'
  case ( ORIGIN_DEMS )
    CORIGIN =  'dems'
  case ( ORIGIN_RJTD )
    CORIGIN =  'rjtd'
  case ( ORIGIN_BABJ )
    CORIGIN =  'babj'
  case ( ORIGIN_RKSL )
    CORIGIN =  'rksl'
  case ( ORIGIN_SABM )
    CORIGIN =  'sabm'
  case ( ORIGIN_SBSJ )
    CORIGIN =  'sbsj'
  case ( ORIGIN_CWAO )
    CORIGIN =  'cwao'
  case ( ORIGIN_FNMO )
    CORIGIN =  'fnmo'
  case ( ORIGIN_NZKL )
    CORIGIN =  'nzkl'
  case ( ORIGIN_EGRR )
    CORIGIN =  'egrr'
  case ( ORIGIN_EDZW )
    CORIGIN =  'edzw'
  case ( ORIGIN_CNMC )
    CORIGIN =  'cnmc'
  case ( ORIGIN_ESWI )
    CORIGIN =  'eswi'
  case ( ORIGIN_LFPW )
    CORIGIN =  'lfpw'
  case ( ORIGIN_LFPW_2 )
    CORIGIN =  'lfpw'
  case ( ORIGIN_EFKL )
    CORIGIN =  'efkl'
  case ( ORIGIN_ENMI )
    CORIGIN =  'enmi'
  case ( ORIGIN_EKMI )
    CORIGIN =  'ekmi'
  case ( ORIGIN_ECMF )
    CORIGIN =  'ecmf'
  case ( ORIGIN_KNMI )
    CORIGIN =  'knmi'
  case ( ORIGIN_NASA )
    CORIGIN =  'nasa'
  case ( ORIGIN_WIIX )
    CORIGIN =  'wiix'
  case ( ORIGIN_NIWA )
    CORIGIN =  'niwa'
  case ( ORIGIN_BIRK )
    CORIGIN =  'birk'
  case ( ORIGIN_LEMM )
    CORIGIN =  'lemm'
  case ( ORIGIN_LSSW )
    CORIGIN =  'lssw'
  case ( ORIGIN_HABP )
    CORIGIN =  'habp'
  case ( ORIGIN_LOWM )
    CORIGIN =  'lowm'
  case ( ORIGIN_EBUM )
    CORIGIN =  'ebum'
  case ( ORIGIN_EIDB )
    CORIGIN =  'eidb'
  case ( ORIGIN_INGV )
    CORIGIN =  'ingv'
  case ( ORIGIN_CRFC )
    CORIGIN =  'crfc'
  case ( ORIGIN_COSMO )
    CORIGIN =  'cosmo'
  case ( ORIGIN_MPIM )
    CORIGIN =  'mpim'
  case ( ORIGIN_EUMS )
    CORIGIN =  'eums'
  case ( ORIGIN_CONSENSUS )
    CORIGIN =  'consensus'
  case ( ORIGIN_ANSO )
    CORIGIN =  'anso'
  case ( ORIGIN_UFZ )
    CORIGIN =  'ufz'
  CASE DEFAULT
    PP_TRYCALL(ERRFLAG_CONVERT_ERROR) TO_STRING(IORIGIN, CTEMP, HOOKS)
    PP_DEBUG_CRITICAL_COND_THROW( LEN_TRIM(CTEMP).GT.16_JPIB_K, ERRFLAG_CONVERT_ERROR )
    CORIGIN=CTEMP
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CONVERT_ERROR)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IORIGIN
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'could not convert iorigin: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IORIGIN2CORIGIN
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CORIGIN2IORIGIN'
PP_THREAD_SAFE FUNCTION CORIGIN2IORIGIN( CORIGIN, IORIGIN, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GENERAL_UTILS_MOD, ONLY: TOLOWER
  USE :: CONFIGURATION_UTILS_MOD, ONLY: STRING_TO_INTEGER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CORIGIN
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IORIGIN
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CORIGIN)) :: LOC_CORIGIN

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_ORIGIN=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_STR=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IORIGIN = UNDEF_PARAM_E

  !> Convert prefix to lowercase
  PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_LC) TOLOWER( CORIGIN, LOC_CORIGIN, HOOKS )

  !> Select the prefix
  SELECT CASE ( TRIM(ADJUSTL(LOC_CORIGIN)) )

  case ( 'ammc' )
    IORIGIN = ORIGIN_AMMC
  case ( 'rums' )
    IORIGIN = ORIGIN_RUMS
  case ( 'kwbc' )
    IORIGIN = ORIGIN_KWBC
  case ( 'fapr' )
    IORIGIN = ORIGIN_FAPR
  case ( 'vabb' )
    IORIGIN = ORIGIN_VABB
  case ( 'dems' )
    IORIGIN = ORIGIN_DEMS
  case ( 'rjtd' )
    IORIGIN = ORIGIN_RJTD
  case ( 'babj' )
    IORIGIN = ORIGIN_BABJ
  case ( 'rksl' )
    IORIGIN = ORIGIN_RKSL
  case ( 'sabm' )
    IORIGIN = ORIGIN_SABM
  case ( 'sbsj' )
    IORIGIN = ORIGIN_SBSJ
  case ( 'cwao' )
    IORIGIN = ORIGIN_CWAO
  case ( 'fnmo' )
    IORIGIN = ORIGIN_FNMO
  case ( 'nzkl' )
    IORIGIN = ORIGIN_NZKL
  case ( 'egrr' )
    IORIGIN = ORIGIN_EGRR
  case ( 'edzw' )
    IORIGIN = ORIGIN_EDZW
  case ( 'cnmc' )
    IORIGIN = ORIGIN_CNMC
  case ( 'eswi' )
    IORIGIN = ORIGIN_ESWI
  case ( 'lfpw' )
    IORIGIN = ORIGIN_LFPW
  case ( 'efkl' )
    IORIGIN = ORIGIN_EFKL
  case ( 'enmi' )
    IORIGIN = ORIGIN_ENMI
  case ( 'ekmi' )
    IORIGIN = ORIGIN_EKMI
  case ( 'ecmf' )
    IORIGIN = ORIGIN_ECMF
  case ( 'knmi' )
    IORIGIN = ORIGIN_KNMI
  case ( 'nasa' )
    IORIGIN = ORIGIN_NASA
  case ( 'wiix' )
    IORIGIN = ORIGIN_WIIX
  case ( 'niwa' )
    IORIGIN = ORIGIN_NIWA
  case ( 'birk' )
    IORIGIN = ORIGIN_BIRK
  case ( 'lemm' )
    IORIGIN = ORIGIN_LEMM
  case ( 'lssw' )
    IORIGIN = ORIGIN_LSSW
  case ( 'habp' )
    IORIGIN = ORIGIN_HABP
  case ( 'lowm' )
    IORIGIN = ORIGIN_LOWM
  case ( 'ebum' )
    IORIGIN = ORIGIN_EBUM
  case ( 'eidb' )
    IORIGIN = ORIGIN_EIDB
  case ( 'ingv' )
    IORIGIN = ORIGIN_INGV
  case ( 'crfc' )
    IORIGIN = ORIGIN_CRFC
  case ( 'cosmo' )
    IORIGIN = ORIGIN_COSMO
  case ( 'mpim' )
    IORIGIN = ORIGIN_MPIM
  case ( 'eums' )
    IORIGIN = ORIGIN_EUMS
  case ( 'consensus' )
    IORIGIN = ORIGIN_CONSENSUS
  case ( 'anso' )
    IORIGIN = ORIGIN_ANSO
  case ( 'ufz' )
    IORIGIN = ORIGIN_UFZ
  CASE DEFAULT

    PP_TRYCALL( ERRFLAG_UNABLE_TO_CONVERT_STR ) STRING_TO_INTEGER(CORIGIN, IORIGIN, HOOKS)

  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to lowercase' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'corigin: '//TRIM(ADJUSTL(CORIGIN)) )
    CASE (ERRFLAG_UNABLE_TO_CONVERT_STR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to integer' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'corigin: '//TRIM(ADJUSTL(CORIGIN)) )
    CASE (ERRFLAG_UNKNOWN_ORIGIN)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown corigin: '//TRIM(ADJUSTL(CORIGIN)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CORIGIN2IORIGIN
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IINT2CINT'
PP_THREAD_SAFE FUNCTION IINT2CINT( IINT, CINT, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: LOG_UTILS_MOD,     ONLY: TO_STRING
  USE :: LOG_UTILS_MOD,     ONLY: MAX_STR_LEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  INTEGER(KIND=JPIB_K), INTENT(IN)    :: IINT
  CHARACTER(LEN=16),    INTENT(OUT)   :: CINT
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=MAX_STR_LEN) :: CTEMP

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONVERT_ERROR=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CTEMP = REPEAT(' ', MAX_STR_LEN)
  CINT = REPEAT(' ', 16)


  ! TODO ADJUSTL in TO_STRING
  PP_TRYCALL(ERRFLAG_CONVERT_ERROR) TO_STRING(IINT, CTEMP, HOOKS)
  PP_DEBUG_CRITICAL_COND_THROW( LEN_TRIM(CTEMP).GT.16_JPIB_K, ERRFLAG_CONVERT_ERROR )
  CINT=TRIM(CTEMP)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CONVERT_ERROR)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IINT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'could not convert int: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IINT2CINT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CINT2IINT'
PP_THREAD_SAFE FUNCTION CINT2IINT( CINT, IINT, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: CONFIGURATION_UTILS_MOD, ONLY: STRING_TO_INTEGER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CINT
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: IINT
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CINT)) :: LOC_CINT

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_STR=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IINT = UNDEF_PARAM_E


  PP_TRYCALL( ERRFLAG_UNABLE_TO_CONVERT_STR ) STRING_TO_INTEGER(CINT, IINT, HOOKS)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_STR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to integer' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'cint: '//TRIM(ADJUSTL(CINT)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CINT2IINT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'IFLOAT2CFLOAT'
PP_THREAD_SAFE FUNCTION IFLOAT2CFLOAT( IFLOAT, CFLOAT, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPRD_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: LOG_UTILS_MOD,     ONLY: TO_STRING
  USE :: LOG_UTILS_MOD,     ONLY: MAX_STR_LEN

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  REAL(KIND=JPRD_K),    INTENT(IN)    :: IFLOAT
  CHARACTER(LEN=16),    INTENT(OUT)   :: CFLOAT
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=MAX_STR_LEN) :: CTEMP

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONVERT_ERROR=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  CTEMP = REPEAT(' ', MAX_STR_LEN)
  CFLOAT = REPEAT(' ', 16)


  ! TODO ADJUSTL in TO_STRING
  PP_TRYCALL(ERRFLAG_CONVERT_ERROR) TO_STRING(IFLOAT, CTEMP, HOOKS)
  PP_DEBUG_CRITICAL_COND_THROW( LEN_TRIM(CTEMP).GT.16_JPIB_K, ERRFLAG_CONVERT_ERROR )
  CFLOAT=TRIM(CTEMP)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK
    CHARACTER(LEN=16) :: TMPSTR

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CONVERT_ERROR)
      TMPSTR = REPEAT(' ', 16)
      WRITE(TMPSTR,*) IFLOAT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'could not convert float: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION IFLOAT2CFLOAT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CFLOAT2IFLOAT'
PP_THREAD_SAFE FUNCTION CFLOAT2IFLOAT( CFLOAT, IFLOAT, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPRD_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: CONFIGURATION_UTILS_MOD, ONLY: STRING_TO_REAL64

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CFLOAT
  REAL(KIND=JPRD_K),    INTENT(OUT)   :: IFLOAT
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET
  INTEGER(KIND=JPIB_K) :: ERR

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CFLOAT)) :: LOC_CFLOAT

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_STR=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  IFLOAT = UNDEF_PARAM_E

  ! READ(CFLOAT,'(F11.4)',IOSTAT=ERR) IFLOAT

  PP_TRYCALL( ERRFLAG_UNABLE_TO_CONVERT_STR ) STRING_TO_REAL64(CFLOAT, IFLOAT, HOOKS)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_STR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to integer' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'cfloat: '//TRIM(ADJUSTL(CFLOAT)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CFLOAT2IFLOAT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'CTIME2ITIME'
PP_THREAD_SAFE FUNCTION CTIME2ITIME( CTIME, ITIME, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: CONFIGURATION_UTILS_MOD, ONLY: STRING_TO_INTEGER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: CTIME
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: ITIME
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  CHARACTER(LEN=LEN_TRIM(CTIME)) :: STEMP
  INTEGER(KIND=JPIB_K)           :: I
  INTEGER(KIND=JPIB_K)           :: L

  !> Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_STR=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Initialization of the output variable
  ITIME = UNDEF_PARAM_E
  
  ! Time can begin with multiple 0, i.e. 0000
  STEMP = TRIM(CTIME)
  L=LEN(STEMP)
  DO I=1,L
    IF (STEMP(I:I).EQ.'0') THEN
      if (I.NE.L) THEN
        STEMP(I:I) = ' ' 
      END IF
    ELSE
      EXIT
    END IF
  END DO


  PP_TRYCALL( ERRFLAG_UNABLE_TO_CONVERT_STR ) STRING_TO_INTEGER(STEMP, ITIME, HOOKS)
    
  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_CONVERT_STR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to convert to integer' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'ctime: '//TRIM(ADJUSTL(CTIME)) )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION CTIME2ITIME
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




END MODULE ENUMERATORS_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME
