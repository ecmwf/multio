! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"


#define PP_FILE_NAME 'parametrization_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'PARAMETRIZATION_MOD'
MODULE PARAMETRIZATION_MOD

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPRD_K
  USE :: ENUMERATORS_MOD,   ONLY: UNDEF_PARAM_E
  USE :: ENUMERATORS_MOD,   ONLY: SINK_MESSAGE_TO_FILE_E

  USE :: GEOMETRY_PAR_MOD,            ONLY: GEOMETRY_PAR_T
  USE :: SATELLITE_PAR_MOD,           ONLY: SATELLITE_PAR_T
  USE :: WAVE_PAR_MOD,                ONLY: WAVE_PAR_T
  USE :: LEVEL_PAR_MOD,               ONLY: LEVEL_PAR_T
  USE :: ENSEMBLE_PAR_MOD,            ONLY: ENSEMBLE_PAR_T
  USE :: BITMAP_PAR_MOD,              ONLY: BITMAP_PAR_T
  USE :: ANALYSIS_PAR_MOD,            ONLY: ANALYSIS_PAR_T
  USE :: TIME_PAR_MOD,                ONLY: TIME_PAR_T
  USE :: DATA_REPRESENTATION_PAR_MOD, ONLY: DATA_REPRESENTATION_PAR_T

IMPLICIT NONE

!> Default visibility of the module
PRIVATE


  !> Collection of all information I am not able to fit into mars
  TYPE :: PARAMETRIZATION_T

    ! Tables version
    INTEGER(KIND=JPIB_K) :: TABLES_VERSION=UNDEF_PARAM_E
    INTEGER(KIND=JPIB_K) :: GENERATING_PROCESS_IDENTIFIER=UNDEF_PARAM_E
    INTEGER(KIND=JPIB_K) :: TYPE_OF_PROCESSED_DATA=UNDEF_PARAM_E
    INTEGER(KIND=JPIB_K) :: SINK_TYPE=SINK_MESSAGE_TO_FILE_E

    !> Allow encoding statistical fields with step 0 and no timerange, which are only emitted to provide initial conditions
    INTEGER(KIND=JPIB_K) :: ENCODE_STEP_ZERO=UNDEF_PARAM_E

    !> Scale factors for the values (used to change units)
    REAL(KIND=JPRD_K)    :: VALUES_SCALE_FACTOR=1.0_JPRD_K


    ! Configorations to be discussed and eventually to be integrated in the MARS keywords
    TYPE(TIME_PAR_T)                :: TIME
    TYPE(LEVEL_PAR_T)               :: LEVELS
    TYPE(BITMAP_PAR_T)              :: BITMAP
    TYPE(ENSEMBLE_PAR_T)            :: ENSEMBLE
    TYPE(ANALYSIS_PAR_T)            :: ANALYSIS
    TYPE(WAVE_PAR_T)                :: WAVE
    TYPE(SATELLITE_PAR_T)           :: SATELLITE
    TYPE(DATA_REPRESENTATION_PAR_T) :: DATA_REPRESENTATION
    TYPE(GEOMETRY_PAR_T)            :: GEOMETRY

  CONTAINS

    !> Copy from another object
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: INIT           => PARAMETRIZATION_INIT
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: FREE           => PARAMETRIZATION_FREE
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: COPY_FROM      => PARAMETRIZATION_COPY_FROM
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: READ_FROM_YAML => READ_PARAMETRIZATION_FROM_YAML

    !> Set fields by field ID
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: SET_INT    => PARAMETRIZATION_SET_INT
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: SET_STRING => PARAMETRIZATION_SET_STRING
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: SET_FLOAT  => PARAMETRIZATION_SET_FLOAT
    GENERIC :: SET => SET_INT
    GENERIC :: SET => SET_STRING
    GENERIC :: SET => SET_FLOAT

    !> Set fields by field ID
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: GET_INT    => PARAMETRIZATION_GET_INT
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: GET_STRING => PARAMETRIZATION_GET_STRING
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: GET_FLOAT  => PARAMETRIZATION_GET_FLOAT
    GENERIC :: GET => GET_INT
    GENERIC :: GET => GET_STRING
    GENERIC :: GET => GET_FLOAT

    !> print
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: PRINT  => PARAMETRIZATION_PRINT
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: TO_JSON => PARAMETRIZATION_TO_JSON
    PROCEDURE, NON_OVERRIDABLE, PUBLIC, PASS :: WRITE_TO_YAML => PARAMETRIZATION_TO_YAML

  END TYPE

  !> Whitelist of public symbols (types)
  PUBLIC :: PARAMETRIZATION_T

CONTAINS


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_INIT'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_INIT( THIS, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T), INTENT(INOUT) :: THIS
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INIT_TIME=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INIT_GEOMETRY=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INIT_LEVELS=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INIT_ENSEMBLE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INIT_ANALYSIS=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INIT_WAVE=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INIT_SATELLITE=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INIT_DATA_REPRESENTATION=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INIT_BITMAP=8_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Tables version
  THIS%TABLES_VERSION=UNDEF_PARAM_E
  THIS%GENERATING_PROCESS_IDENTIFIER=UNDEF_PARAM_E
  THIS%TYPE_OF_PROCESSED_DATA=UNDEF_PARAM_E
  THIS%SINK_TYPE=1_JPIB_K

  ! Scale factors for the values (used to change units)
  THIS%VALUES_SCALE_FACTOR=1.0_JPRD_K

  ! Encode step zero
  THIS%ENCODE_STEP_ZERO=UNDEF_PARAM_E

  ! INIT the geometry
  PP_TRYCALL(ERRFLAG_INIT_TIME) THIS%TIME%INIT( HOOKS )

  ! INIT the geometry
  PP_TRYCALL(ERRFLAG_INIT_GEOMETRY) THIS%GEOMETRY%INIT( HOOKS )

  ! INIT the levels
  PP_TRYCALL(ERRFLAG_INIT_LEVELS) THIS%LEVELS%INIT( HOOKS )

  ! INIT the ensemble
  PP_TRYCALL(ERRFLAG_INIT_ENSEMBLE) THIS%ENSEMBLE%INIT( HOOKS )

  ! INIT the ensemble
  PP_TRYCALL(ERRFLAG_INIT_ANALYSIS) THIS%ANALYSIS%INIT( HOOKS )

  ! INIT the wave
  PP_TRYCALL(ERRFLAG_INIT_WAVE) THIS%WAVE%INIT( HOOKS )

  ! INIT the satellite
  PP_TRYCALL(ERRFLAG_INIT_SATELLITE) THIS%SATELLITE%INIT( HOOKS )

  ! INIT the data-representation
  PP_TRYCALL(ERRFLAG_INIT_DATA_REPRESENTATION) THIS%DATA_REPRESENTATION%INIT( HOOKS )

  ! INIT the bitmap
  PP_TRYCALL(ERRFLAG_INIT_BITMAP) THIS%BITMAP%INIT( HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_INIT_TIME)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to init time' )
    CASE(ERRFLAG_INIT_GEOMETRY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to init geometry' )
    CASE(ERRFLAG_INIT_LEVELS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to init levels' )
    CASE(ERRFLAG_INIT_ENSEMBLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to init ensemble' )
    CASE(ERRFLAG_INIT_ANALYSIS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to init analysis' )
    CASE(ERRFLAG_INIT_WAVE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to init wave' )
    CASE(ERRFLAG_INIT_SATELLITE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to init satellite' )
    CASE(ERRFLAG_INIT_DATA_REPRESENTATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to init data-representation' )
    CASE(ERRFLAG_INIT_BITMAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to init bitmap' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_INIT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_FREE'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_FREE( THIS, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T), INTENT(INOUT) :: THIS
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_TIME=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_GEOMETRY=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_LEVELS=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_ENSEMBLE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_ANALYSIS=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_WAVE=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_SATELLITE=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_DATA_REPRESENTATION=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_BITMAP=8_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Tables version
  THIS%TABLES_VERSION=UNDEF_PARAM_E
  THIS%GENERATING_PROCESS_IDENTIFIER=UNDEF_PARAM_E
  THIS%TYPE_OF_PROCESSED_DATA=UNDEF_PARAM_E
  THIS%SINK_TYPE=1_JPIB_K

  ! Scale factors for the values (used to change units)
  THIS%VALUES_SCALE_FACTOR=1.0_JPRD_K

  THIS%ENCODE_STEP_ZERO=UNDEF_PARAM_E

  ! Free the geometry
  PP_TRYCALL(ERRFLAG_FREE_TIME) THIS%TIME%FREE( HOOKS )

  ! Free the geometry
  PP_TRYCALL(ERRFLAG_FREE_GEOMETRY) THIS%GEOMETRY%FREE( HOOKS )

  ! Free the levels
  PP_TRYCALL(ERRFLAG_FREE_LEVELS) THIS%LEVELS%FREE( HOOKS )

  ! Free the ensemble
  PP_TRYCALL(ERRFLAG_FREE_ENSEMBLE) THIS%ENSEMBLE%FREE( HOOKS )

  ! Free the ensemble
  PP_TRYCALL(ERRFLAG_FREE_ANALYSIS) THIS%ANALYSIS%FREE( HOOKS )

  ! Free the wave
  PP_TRYCALL(ERRFLAG_FREE_WAVE) THIS%WAVE%FREE( HOOKS )

  ! Free the satellite
  PP_TRYCALL(ERRFLAG_FREE_SATELLITE) THIS%SATELLITE%FREE( HOOKS )

  ! Free the data-representation
  PP_TRYCALL(ERRFLAG_FREE_DATA_REPRESENTATION) THIS%DATA_REPRESENTATION%FREE( HOOKS )

  ! Free the bitmap
  PP_TRYCALL(ERRFLAG_FREE_BITMAP) THIS%BITMAP%FREE( HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_FREE_TIME)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free time' )
    CASE(ERRFLAG_FREE_GEOMETRY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free geometry' )
    CASE(ERRFLAG_FREE_LEVELS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free levels' )
    CASE(ERRFLAG_FREE_ENSEMBLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free ensemble' )
    CASE(ERRFLAG_FREE_ANALYSIS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free analysis' )
    CASE(ERRFLAG_FREE_WAVE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free wave' )
    CASE(ERRFLAG_FREE_SATELLITE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free satellite' )
    CASE(ERRFLAG_FREE_DATA_REPRESENTATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free data-representation' )
    CASE(ERRFLAG_FREE_BITMAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free bitmap' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_FREE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_COPY_FROM'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_COPY_FROM( THIS, OTHER, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T), INTENT(INOUT) :: THIS
  CLASS(PARAMETRIZATION_T), INTENT(IN)    :: OTHER
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_COPY_TIME=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_COPY_LEVELS=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_COPY_ENSEMBLE=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_COPY_ANALYSIS=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_COPY_WAVE=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_COPY_SATELLITE=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_COPY_GEOMETRY=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_COPY_DATA_REPRESENTATION=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_COPY_BITMAP=8_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Copy the scale factors
  THIS%VALUES_SCALE_FACTOR = OTHER%VALUES_SCALE_FACTOR

  ! Copy the non categorized values (table version)
  THIS%TABLES_VERSION = OTHER%TABLES_VERSION
  THIS%GENERATING_PROCESS_IDENTIFIER = OTHER%GENERATING_PROCESS_IDENTIFIER
  THIS%TYPE_OF_PROCESSED_DATA = OTHER%TYPE_OF_PROCESSED_DATA
  THIS%SINK_TYPE = OTHER%SINK_TYPE

  ! Copy the scale factor of the values
  THIS%VALUES_SCALE_FACTOR = OTHER%VALUES_SCALE_FACTOR

  THIS%ENCODE_STEP_ZERO = OTHER%ENCODE_STEP_ZERO

  ! Copy the time
  PP_TRYCALL(ERRFLAG_COPY_TIME) THIS%TIME%COPY_FROM( OTHER%TIME, HOOKS )

  ! Copy the levels
  PP_TRYCALL(ERRFLAG_COPY_LEVELS) THIS%LEVELS%COPY_FROM( OTHER%LEVELS, HOOKS )

  ! Copy the ensemble
  PP_TRYCALL(ERRFLAG_COPY_ENSEMBLE) THIS%ENSEMBLE%COPY_FROM( OTHER%ENSEMBLE, HOOKS )

  ! Copy the ensemble
  PP_TRYCALL(ERRFLAG_COPY_ANALYSIS) THIS%ANALYSIS%COPY_FROM( OTHER%ANALYSIS, HOOKS )

  ! Copy the wave
  PP_TRYCALL(ERRFLAG_COPY_WAVE) THIS%WAVE%COPY_FROM( OTHER%WAVE, HOOKS )

  ! Copy the satellite
  PP_TRYCALL(ERRFLAG_COPY_SATELLITE) THIS%SATELLITE%COPY_FROM( OTHER%SATELLITE, HOOKS )

  ! Copy the geometry
  PP_TRYCALL(ERRFLAG_COPY_GEOMETRY) THIS%GEOMETRY%COPY_FROM( OTHER%GEOMETRY, HOOKS )

  ! Copy the data-representation
  PP_TRYCALL(ERRFLAG_COPY_DATA_REPRESENTATION) THIS%DATA_REPRESENTATION%COPY_FROM( OTHER%DATA_REPRESENTATION, HOOKS )

  ! Copy the data-representation
  PP_TRYCALL(ERRFLAG_COPY_BITMAP) THIS%BITMAP%COPY_FROM( OTHER%BITMAP, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_COPY_TIME)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to copy time' )
    CASE(ERRFLAG_COPY_LEVELS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to copy levels' )
    CASE(ERRFLAG_COPY_ENSEMBLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to copy ensemble' )
    CASE(ERRFLAG_COPY_ANALYSIS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to copy analysis' )
    CASE(ERRFLAG_COPY_WAVE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to copy wave' )
    CASE(ERRFLAG_COPY_SATELLITE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to copy satellite' )
    CASE(ERRFLAG_COPY_GEOMETRY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to copy geometry' )
    CASE(ERRFLAG_COPY_DATA_REPRESENTATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to copy data-representation' )
    CASE(ERRFLAG_COPY_BITMAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to copy bitmap' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_COPY_FROM
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_PRINT'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_PRINT( THIS, UNIT, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPRD_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: GRIB_ENCODER_OPTIONS_MOD,        ONLY: GRIB_ENCODER_OPTIONS_T
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: N_PARINTFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: IPARINTFLDS2CPARINTFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: N_PARSTRFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: IPARSTRINGFLDS2CPARSTRINGFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: N_PARFLOATFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: IPARFLOATFLDS2CPARFLOATFLDS

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: UNIT
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local parameters
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: ITMP
  REAL(KIND=JPRD_K)    :: RTMP
  CHARACTER(LEN=64)    :: CKEY
  CHARACTER(LEN=8)     :: CTMP
  INTEGER(KIND=JPIB_K) :: WRITE_STAT

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPARINTFLDS2CPARINTFLDS=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET_INT=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPARSTRINGFLDS2CPARSTRINGFLDS=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET_STRING=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPARFLOATFLDS2CPARFLOATFLDS=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET_FLOAT=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IOSTATUS_NOT_ZERO=7_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) '** PARAMETRIZATION PRINT'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )

  ! Integer members
  IF ( N_PARINTFLDS .GT. 0 ) THEN
    WRITE(UNIT,*) '+ Integer members'
    DO I = 1, N_PARINTFLDS
      PP_TRYCALL(ERRFLAG_IPARINTFLDS2CPARINTFLDS) IPARINTFLDS2CPARINTFLDS( I, CKEY, HOOKS )
      PP_TRYCALL(ERRFLAG_GET_INT) THIS%GET_INT( I, ITMP, HOOKS )
      WRITE(UNIT,'(A3,A20,A3,I32)',IOSTAT=WRITE_STAT) ' - ', TRIM(ADJUSTL(CKEY)) ,' : ', ITMP
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
    ENDDO
  ENDIF

  ! String members
  IF ( N_PARSTRFLDS .GT. 0 ) THEN
    WRITE(UNIT,*) '+ String members'
    DO I = 1, N_PARSTRFLDS
      PP_TRYCALL(ERRFLAG_IPARSTRINGFLDS2CPARSTRINGFLDS) IPARSTRINGFLDS2CPARSTRINGFLDS( I, CKEY, HOOKS )
      PP_TRYCALL(ERRFLAG_GET_STRING) THIS%GET_STRING( I, CTMP, HOOKS )
      WRITE(UNIT,'(A3,A20,A3,A8)',IOSTAT=WRITE_STAT) ' - ', TRIM(ADJUSTL(CKEY)) ,' : ', CTMP
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
    ENDDO
  ENDIF

  ! Float members
  IF ( N_PARFLOATFLDS .GT. 0 ) THEN
    WRITE(UNIT,*) '+ Float members'
    DO I = 1, N_PARFLOATFLDS
      PP_TRYCALL(ERRFLAG_IPARFLOATFLDS2CPARFLOATFLDS) IPARFLOATFLDS2CPARFLOATFLDS( I, CKEY, HOOKS )
      PP_TRYCALL(ERRFLAG_GET_FLOAT) THIS%GET_FLOAT( I, RTMP, HOOKS )
      WRITE(UNIT,'(A3,A20,A3,F11.4)',IOSTAT=WRITE_STAT) ' - ', TRIM(ADJUSTL(CKEY)) ,' : ', RTMP
      PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
    ENDDO
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_IPARINTFLDS2CPARINTFLDS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert integer field ID to string' )
    CASE(ERRFLAG_GET_INT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get integer field' )
    CASE(ERRFLAG_IPARSTRINGFLDS2CPARSTRINGFLDS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert string field ID to string' )
    CASE(ERRFLAG_GET_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get string field' )
    CASE(ERRFLAG_IOSTATUS_NOT_ZERO)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'IO status is not zero' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_PRINT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_TO_JSON'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_TO_JSON( THIS, JSON, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPRD_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: GRIB_ENCODER_OPTIONS_MOD,        ONLY: GRIB_ENCODER_OPTIONS_T
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: N_PARINTFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: IPARINTFLDS2CPARINTFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: N_PARSTRFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: IPARSTRINGFLDS2CPARSTRINGFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: N_PARFLOATFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: IPARFLOATFLDS2CPARFLOATFLDS

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T),      INTENT(INOUT) :: THIS
  CHARACTER(LEN=:), ALLOCATABLE, INTENT(INOUT) :: JSON
  TYPE(HOOKS_T),                 INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local parameters
  INTEGER(KIND=JPIB_K) :: L
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: SZ
  INTEGER(KIND=JPIB_K) :: LO
  INTEGER(KIND=JPIB_K) :: HI
  INTEGER(KIND=JPIB_K) :: CNT
  INTEGER(KIND=JPIB_K) :: N_FIELDS
  INTEGER(KIND=JPIB_K) :: ITMP
  REAL(KIND=JPRD_K)    :: RTMP
  CHARACTER(LEN=64)    :: CKEY
  CHARACTER(LEN=32)    :: CTMP
  CHARACTER(LEN=1024)  :: JSON_ITEM
  CHARACTER(LEN=1)     :: SEP
  INTEGER(KIND=JPIB_K) :: WRITE_STAT
  INTEGER(KIND=JPIB_K) :: ALLOC_STATE
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATE
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPARINTFLDS2CPARINTFLDS=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET_INT=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPARSTRINGFLDS2CPARSTRINGFLDS=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET_STRING=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IPARFLOATFLDS2CPARFLOATFLDS=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GET_FLOAT=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOC_ERROR=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_ERROR=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IOSTATUS_NOT_ZERO=9_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  CNT = 0
  N_FIELDS = N_PARINTFLDS + N_PARSTRFLDS + N_PARFLOATFLDS

  ! Count the number of characters needed for the JSON string
  SZ = 17
  LO = 1
  HI = LO + SZ - 1
  IF ( N_PARINTFLDS .GT. 0 ) THEN
    DO I = 1, N_PARINTFLDS

      CTMP=REPEAT(' ',32)
      CKEY=REPEAT(' ',16)
      PP_TRYCALL(ERRFLAG_IPARINTFLDS2CPARINTFLDS) IPARINTFLDS2CPARINTFLDS( I, CKEY, HOOKS )
      PP_TRYCALL(ERRFLAG_GET_INT) THIS%GET_INT( I, ITMP, HOOKS )
      WRITE(CTMP,*,IOSTAT=WRITE_STAT) ITMP
      SZ = 1 + LEN_TRIM(ADJUSTL(CKEY)) + 1 + LEN_TRIM(ADJUSTL(CTMP)) + 1
      LO = HI + 1
      HI = LO + SZ - 1
    ENDDO
  ENDIF

  ! String members
  IF ( N_PARSTRFLDS .GT. 0 ) THEN
    DO I = 1, N_PARSTRFLDS
      CTMP=REPEAT(' ',32)
      CKEY=REPEAT(' ',16)
      PP_TRYCALL(ERRFLAG_IPARSTRINGFLDS2CPARSTRINGFLDS) IPARSTRINGFLDS2CPARSTRINGFLDS( I, CKEY, HOOKS )
      PP_TRYCALL(ERRFLAG_GET_STRING) THIS%GET_STRING( I, CTMP, HOOKS )
      SZ = 1 + LEN_TRIM(ADJUSTL(CKEY)) + 1 + LEN_TRIM(ADJUSTL(CTMP)) + 1
      LO = HI + 1
      HI = LO + SZ - 1
    ENDDO
  ENDIF

  ! Float members
  IF ( N_PARFLOATFLDS .GT. 0 ) THEN
    DO I = 1, N_PARFLOATFLDS
      CTMP=REPEAT(' ',32)
      CKEY=REPEAT(' ',16)
      PP_TRYCALL(ERRFLAG_IPARFLOATFLDS2CPARFLOATFLDS) IPARFLOATFLDS2CPARFLOATFLDS( I, CKEY, HOOKS )
      PP_TRYCALL(ERRFLAG_GET_FLOAT) THIS%GET_FLOAT( I, RTMP, HOOKS )
      WRITE(CTMP,*,IOSTAT=WRITE_STAT) RTMP
      SZ = 1 + LEN_TRIM(ADJUSTL(CKEY)) + 1 + LEN_TRIM(ADJUSTL(CTMP)) + 1
      LO = HI + 1
      HI = LO + SZ - 1
    ENDDO
  ENDIF

  ! Close the JSON object
  ! Size equal to one for the closing bracket no null character is needed
  ! since it is alreday include in the string
  SZ = 1
  LO = HI + 1
  HI = LO + SZ - 1

  ! Free the json string
  IF ( ALLOCATED(JSON) ) THEN
    DEALLOCATE(JSON, STAT=DEALLOC_STATE, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATE .NE. 0, ERRFLAG_DEALLOC_ERROR )
  ENDIF

  ! Allocate the JSON string
  L = HI
  ALLOCATE(CHARACTER(LEN=L) :: JSON, STAT=ALLOC_STATE, ERRMSG=ERRMSG)
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATE .NE. 0, ERRFLAG_ALLOC_ERROR )

  ! Fill the JSON string
  JSON = REPEAT(' ', L)
  SZ = 17
  LO = 1
  HI = LO + SZ - 1
  JSON(LO:HI) = 'parametrization={'
  IF ( N_PARINTFLDS .GT. 0 ) THEN
    DO I = 1, N_PARINTFLDS
      CNT = CNT + 1
      IF ( CNT .GE. N_FIELDS ) THEN
        SEP = ' '
      ELSE
        SEP = ','
      ENDIF
      CTMP=REPEAT(' ',32)
      CKEY=REPEAT(' ',16)
      PP_TRYCALL(ERRFLAG_IPARINTFLDS2CPARINTFLDS) IPARINTFLDS2CPARINTFLDS( I, CKEY, HOOKS )
      PP_TRYCALL(ERRFLAG_GET_INT) THIS%GET_INT( I, ITMP, HOOKS )
      WRITE(CTMP,*,IOSTAT=WRITE_STAT) ITMP
      SZ = 1 + LEN_TRIM(ADJUSTL(CKEY)) + 1 + LEN_TRIM(ADJUSTL(CTMP)) + 1
      LO = HI + 1
      HI = LO + SZ - 1
      JSON_ITEM = REPEAT(' ', 1024)
      WRITE(JSON_ITEM, '(A1,A,A1,A,A1)') ' ', TRIM(ADJUSTL(CKEY)) ,':', TRIM(ADJUSTL(CTMP)), SEP
      JSON(LO:HI) = TRIM(JSON_ITEM)
    ENDDO
  ENDIF

  ! String members
  IF ( N_PARSTRFLDS .GT. 0 ) THEN
    DO I = 1, N_PARSTRFLDS
      CNT = CNT + 1
      IF ( CNT .GE. N_FIELDS ) THEN
        SEP = ' '
      ELSE
        SEP = ','
      ENDIF
      CTMP=REPEAT(' ',32)
      CKEY=REPEAT(' ',16)
      PP_TRYCALL(ERRFLAG_IPARSTRINGFLDS2CPARSTRINGFLDS) IPARSTRINGFLDS2CPARSTRINGFLDS( I, CKEY, HOOKS )
      PP_TRYCALL(ERRFLAG_GET_STRING) THIS%GET_STRING( I, CTMP, HOOKS )
      SZ = 1 + LEN_TRIM(ADJUSTL(CKEY)) + 1 + LEN_TRIM(ADJUSTL(CTMP)) + 1
      LO = HI + 1
      HI = LO + SZ - 1
      JSON_ITEM = REPEAT(' ', 1024)
      WRITE(JSON_ITEM, '(A1,A,A1,A,A1)') ' ', TRIM(ADJUSTL(CKEY)) ,':', TRIM(ADJUSTL(CTMP)), SEP
      JSON(LO:HI) = TRIM(JSON_ITEM)
    ENDDO
  ENDIF

  ! Float members
  IF ( N_PARFLOATFLDS .GT. 0 ) THEN
    DO I = 1, N_PARFLOATFLDS
      CNT = CNT + 1
      IF ( CNT .GE. N_FIELDS ) THEN
        SEP = ' '
      ELSE
        SEP = ','
      ENDIF
      CTMP=REPEAT(' ',32)
      CKEY=REPEAT(' ',16)
      PP_TRYCALL(ERRFLAG_IPARFLOATFLDS2CPARFLOATFLDS) IPARFLOATFLDS2CPARFLOATFLDS( I, CKEY, HOOKS )
      PP_TRYCALL(ERRFLAG_GET_FLOAT) THIS%GET_FLOAT( I, RTMP, HOOKS )
      WRITE(CTMP,*,IOSTAT=WRITE_STAT) RTMP
      SZ = 1 + LEN_TRIM(ADJUSTL(CKEY)) + 1 + LEN_TRIM(ADJUSTL(CTMP)) + 1
      LO = HI + 1
      HI = LO + SZ - 1
      JSON_ITEM = REPEAT(' ', 1024)
      WRITE(JSON_ITEM, '(A1,A,A1,A,A1)') ' ', TRIM(ADJUSTL(CKEY)) ,':', TRIM(ADJUSTL(CTMP)), SEP
      JSON(LO:HI) = TRIM(JSON_ITEM)
    ENDDO
  ENDIF

  ! Close the JSON object
  LO = LEN_TRIM(JSON) + 1
  HI = LO + 1
  JSON(LO:HI) = ' }'

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_IPARINTFLDS2CPARINTFLDS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert integer field ID to string' )
    CASE(ERRFLAG_GET_INT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get integer field' )
    CASE(ERRFLAG_IPARSTRINGFLDS2CPARSTRINGFLDS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert string field ID to string' )
    CASE(ERRFLAG_GET_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get string field' )
    CASE(ERRFLAG_IOSTATUS_NOT_ZERO)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'IO status is not zero' )
    CASE(ERRFLAG_ALLOC_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Allocation error' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error message: '//ERRMSG )
        DEALLOCATE( ERRMSG, STAT=DEALLOC_STATE )
      ENDIF
    CASE(ERRFLAG_DEALLOC_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Deallocation error' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error message: '//ERRMSG )
        DEALLOCATE( ERRMSG, STAT=DEALLOC_STATE )
      ENDIF
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_TO_JSON
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_SET_INT'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_SET_INT( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_TABLES_VERSION_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_GENERATING_PROCESS_IDENTIFIER_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_TYPE_OF_PROCESSED_DATA_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_DATA_REPRESENTATION_BITS_PER_VALUE_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_ENCODE_STEP_ZERO_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_TIME_INITIAL_STEP_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_TIME_LENGTH_OF_TIME_STEP_IN_SECONDS_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_TIME_LENGTH_OF_TIME_RANGE_IN_SECONDS_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_BITMAP_NUMBER_OF_MISSING_VALUES_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_ENSEMBLE_TYPE_OF_ENSEMBLE_FORECAST_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_ENSEMBLE_NUMBER_OF_FORECASTS_IN_ENSEMBLE_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_ANALYSIS_LENGTH_OF_TIME_WINDOW_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_SATELLITE_SATELLITE_SERIES_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_SATELLITE_SCALED_FACTOR_OF_CENTRAL_VAWENUMBER_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_SATELLITE_SCALED_VALUE_OF_CENTRAL_VAWENUMBER_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_SINK_TYPE_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PAR=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_SET_PAR=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Set the value based on the ID
  SELECT CASE ( ID )
  CASE ( PARINTFLD_TABLES_VERSION_E )
    THIS%TABLES_VERSION = VALUE
  CASE ( PARINTFLD_GENERATING_PROCESS_IDENTIFIER_E )
    THIS%GENERATING_PROCESS_IDENTIFIER = VALUE
  CASE ( PARINTFLD_TYPE_OF_PROCESSED_DATA_E )
    THIS%TYPE_OF_PROCESSED_DATA = VALUE
  CASE ( PARINTFLD_SINK_TYPE_E )
    THIS%SINK_TYPE = VALUE
  CASE ( PARINTFLD_ENCODE_STEP_ZERO_E  )
    THIS%ENCODE_STEP_ZERO = VALUE
  CASE ( PARINTFLD_TIME_INITIAL_STEP_E )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) THIS%TIME%SET_INITIAL_STEP( VALUE, HOOKS )
  CASE ( PARINTFLD_TIME_LENGTH_OF_TIME_STEP_IN_SECONDS_E )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) THIS%TIME%SET_LENGTH_OF_TIME_STEP_IN_SECONDS( VALUE, HOOKS )
  CASE ( PARINTFLD_TIME_LENGTH_OF_TIME_RANGE_IN_SECONDS_E )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) THIS%TIME%SET_LENGTH_OF_TIME_RANGE_IN_SECONDS( VALUE, HOOKS )
  CASE ( PARINTFLD_BITMAP_NUMBER_OF_MISSING_VALUES_E )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) THIS%BITMAP%SET_NUMBER_OF_MISSING_VALUES( VALUE, HOOKS )
  ! CASE ( PARINTFLD_ENSEMBLE_TYPE_OF_ENSEMBLE_FORECAST_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) THIS%ENSEMBLE%SET_TYPE_OF_ENSEMBLE_FORECAST( VALUE, HOOKS )
  ! CASE ( PARINTFLD_ENSEMBLE_NUMBER_OF_FORECASTS_IN_ENSEMBLE_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) THIS%ENSEMBLE%SET_NUMBER_OF_FORECASTS_IN_ENSEMBLE( VALUE, HOOKS )
  ! CASE ( PARINTFLD_ANALYSIS_LENGTH_OF_TIME_WINDOW_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) THIS%ANALYSIS%SET_LENGTH_OF_TIME_WINDOW( VALUE, HOOKS )
  ! CASE ( PARINTFLD_SATELLITE_SATELLITE_SERIES_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) THIS%SATELLITE%SET_SATELLITE_SERIES( VALUE, HOOKS )
  ! CASE ( PARINTFLD_SATELLITE_SCALED_FACTOR_OF_CENTRAL_VAWENUMBER_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) THIS%SATELLITE%SET_SCALED_FACTOR_OF_CENTRAL_VAWENUMBER( VALUE, HOOKS )
  ! CASE ( PARINTFLD_SATELLITE_SCALED_VALUE_OF_CENTRAL_VAWENUMBER_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) THIS%SATELLITE%SET_SCALED_VALUE_OF_CENTRAL_VAWENUMBER( VALUE, HOOKS )
  CASE ( PARINTFLD_DATA_REPRESENTATION_BITS_PER_VALUE_E )
      THIS%DATA_REPRESENTATION%BITS_PER_VALUE_ = VALUE
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) THIS%DATA_REPRESENTATION%SET_BITS_PER_VALUE( VALUE, HOOKS )
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PAR )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown parameter' )
    CASE (ERRFLAG_UNABLE_TO_SET_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to set parameter' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_SET_INT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_SET_STRING'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_SET_STRING( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  CHARACTER(LEN=*),         INTENT(IN)    :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PAR=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Set the value based on the ID
  PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PAR )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown parameter' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_SET_STRING
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_SET_FLOAT'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_SET_FLOAT( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPRD_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARFLOATFLD_SCALEFACTOR_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  REAL(KIND=JPRD_K),        INTENT(IN)    :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PAR=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Set the value based on the ID
  SELECT CASE ( ID )
  CASE ( PARFLOATFLD_SCALEFACTOR_E )
    THIS%VALUES_SCALE_FACTOR = VALUE
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PAR )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown parameter' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_SET_FLOAT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_GET_INT'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_GET_INT( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_TABLES_VERSION_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_ENCODE_STEP_ZERO_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_TIME_INITIAL_STEP_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_TIME_LENGTH_OF_TIME_STEP_IN_SECONDS_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_TIME_LENGTH_OF_TIME_RANGE_IN_SECONDS_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_BITMAP_NUMBER_OF_MISSING_VALUES_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_ENSEMBLE_TYPE_OF_ENSEMBLE_FORECAST_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_ENSEMBLE_NUMBER_OF_FORECASTS_IN_ENSEMBLE_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_ANALYSIS_LENGTH_OF_TIME_WINDOW_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_SATELLITE_SATELLITE_SERIES_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_SATELLITE_SCALED_FACTOR_OF_CENTRAL_VAWENUMBER_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_SATELLITE_SCALED_VALUE_OF_CENTRAL_VAWENUMBER_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_DATA_REPRESENTATION_BITS_PER_VALUE_E
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARINTFLD_SINK_TYPE_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  INTEGER(KIND=JPIB_K),     INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PAR=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_PAR=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Get the value based on the ID
  SELECT CASE ( ID )
  CASE ( PARINTFLD_TABLES_VERSION_E )
    VALUE = THIS%TABLES_VERSION
  CASE ( PARINTFLD_SINK_TYPE_E )
    VALUE = THIS%SINK_TYPE
  CASE ( PARINTFLD_ENCODE_STEP_ZERO_E )
    VALUE = THIS%ENCODE_STEP_ZERO
  CASE ( PARINTFLD_TIME_INITIAL_STEP_E )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) THIS%TIME%GET_INITIAL_STEP( VALUE, HOOKS )
  CASE ( PARINTFLD_TIME_LENGTH_OF_TIME_STEP_IN_SECONDS_E )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) THIS%TIME%GET_LENGTH_OF_TIME_STEP_IN_SECONDS( VALUE, HOOKS )
  CASE ( PARINTFLD_TIME_LENGTH_OF_TIME_RANGE_IN_SECONDS_E )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) THIS%TIME%GET_LENGTH_OF_TIME_RANGE_IN_SECONDS( VALUE, HOOKS )
  CASE ( PARINTFLD_BITMAP_NUMBER_OF_MISSING_VALUES_E )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) THIS%BITMAP%GET_NUMBER_OF_MISSING_VALUES( VALUE, HOOKS )
  ! CASE ( PARINTFLD_ENSEMBLE_TYPE_OF_ENSEMBLE_FORECAST_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) THIS%ENSEMBLE%GET_TYPE_OF_ENSEMBLE_FORECAST( VALUE, HOOKS )
  ! CASE ( PARINTFLD_ENSEMBLE_NUMBER_OF_FORECASTS_IN_ENSEMBLE_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) THIS%ENSEMBLE%GET_NUMBER_OF_FORECASTS_IN_ENSEMBLE( VALUE, HOOKS )
  ! CASE ( PARINTFLD_ANALYSIS_LENGTH_OF_TIME_WINDOW_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) THIS%ANALYSIS%GET_LENGTH_OF_TIME_WINDOW( VALUE, HOOKS )
  ! CASE ( PARINTFLD_SATELLITE_SATELLITE_SERIES_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) THIS%SATELLITE%GET_SATELLITE_SERIES( VALUE, HOOKS )
  ! CASE ( PARINTFLD_SATELLITE_SCALED_FACTOR_OF_CENTRAL_VAWENUMBER_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) THIS%SATELLITE%GET_SCALED_FACTOR_OF_CENTRAL_VAWENUMBER( VALUE, HOOKS )
  ! CASE ( PARINTFLD_SATELLITE_SCALED_VALUE_OF_CENTRAL_VAWENUMBER_E )
  !   PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) THIS%SATELLITE%GET_SCALED_VALUE_OF_CENTRAL_VAWENUMBER( VALUE, HOOKS )
  CASE ( PARINTFLD_DATA_REPRESENTATION_BITS_PER_VALUE_E )
    VALUE = THIS%DATA_REPRESENTATION%BITS_PER_VALUE_
    ! PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) THIS%DATA_REPRESENTATION%GET_BITS_PER_VALUE( VALUE, HOOKS )
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PAR )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown parameter' )
    CASE (ERRFLAG_UNABLE_TO_GET_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to set parameter' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_GET_INT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_GET_STRING'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_GET_STRING( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  CHARACTER(LEN=4),         INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PAR=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  VALUE=REPEAT('*',4)

  PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PAR )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown parameter' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_GET_STRING
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_GET_FLOAT'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_GET_FLOAT( THIS, ID, VALUE, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPRD_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: PARFLOATFLD_SCALEFACTOR_E


  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: ID
  REAL(KIND=JPRD_K),        INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_PAR=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  SELECT CASE ( ID )
  CASE ( PARFLOATFLD_SCALEFACTOR_E )
    VALUE = THIS%VALUES_SCALE_FACTOR
  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_PAR )
  END SELECT

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNKNOWN_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unknown parameter' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_GET_FLOAT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'READ_PARAMETRIZATION_FROM_YAML'
PP_THREAD_SAFE FUNCTION READ_PARAMETRIZATION_FROM_YAML( PARAMETRIZATION, CONFIG, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPRD_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_INTEGER
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_FLOAT
  USE :: ENUMERATORS_MOD,     ONLY: UNDEF_PARAM_E

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T),   INTENT(INOUT) :: PARAMETRIZATION
  TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CONFIG
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  TYPE(YAML_CONFIGURATION_T) :: PARAMETRIZATION_CONFIGURATION
  INTEGER(KIND=JPIB_K) :: TEMPINT
  LOGICAL :: HAS_PARAMETRIZATION
  LOGICAL :: HAS_KEY

  !> Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_SUBCFG=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_TIME=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_GEOMETRY=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_LEVELS=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_ENSEMBLE=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_ANALYSIS=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_WAVE=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_SATELLITE=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DELETE_CONFIGURATION=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_DATA_REPRESENTATION=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_BITMAP=12_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Read the encoder configuration
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CONFIG, 'parametrization', HAS_PARAMETRIZATION, HOOKS )


  !> Read representations
  IF ( HAS_PARAMETRIZATION  ) THEN

    !> Read all the subconfigurations
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_SUBCFG) YAML_GET_SUBCONFIGURATION( CONFIG, 'parametrization', PARAMETRIZATION_CONFIGURATION, HOOKS )

    !> Read the scale factor of the values (should be always 1.0)
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( PARAMETRIZATION_CONFIGURATION, 'values-scale-factor', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_FLOAT( PARAMETRIZATION_CONFIGURATION, 'values-scale-factor', PARAMETRIZATION%VALUES_SCALE_FACTOR, HOOKS )
    ELSE
      PARAMETRIZATION%VALUES_SCALE_FACTOR = 1.0_JPRD_K
    ENDIF

    !> Read 'encode step zero'
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( PARAMETRIZATION_CONFIGURATION, 'encode-step-zero', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( PARAMETRIZATION_CONFIGURATION, 'encode-step-zero', PARAMETRIZATION%ENCODE_STEP_ZERO, HOOKS )
    ELSE
      PARAMETRIZATION%ENCODE_STEP_ZERO = 0_JPIB_K
    ENDIF

    ! Read the table version parameters
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( PARAMETRIZATION_CONFIGURATION, 'tables-version', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( PARAMETRIZATION_CONFIGURATION, 'tables-versions', PARAMETRIZATION%TABLES_VERSION, HOOKS )
    ELSE
      PARAMETRIZATION%TABLES_VERSION = UNDEF_PARAM_E
    ENDIF

    ! Read the generating process identifier parameters
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( PARAMETRIZATION_CONFIGURATION, 'generating-process-identifier', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( PARAMETRIZATION_CONFIGURATION, 'generating-process-identifier', PARAMETRIZATION%GENERATING_PROCESS_IDENTIFIER, HOOKS )
    ELSE
      PARAMETRIZATION%GENERATING_PROCESS_IDENTIFIER = UNDEF_PARAM_E
    ENDIF
    
    ! Read the `typeOfProcessedData` parameters
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( PARAMETRIZATION_CONFIGURATION, 'type-of-processed-data', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( PARAMETRIZATION_CONFIGURATION, 'type-of-processed-data', PARAMETRIZATION%TYPE_OF_PROCESSED_DATA, HOOKS )
    ELSE
      PARAMETRIZATION%TYPE_OF_PROCESSED_DATA = UNDEF_PARAM_E
    ENDIF

    ! Read the generating process identifier parameters
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( PARAMETRIZATION_CONFIGURATION, 'sink-type', HAS_KEY, HOOKS )
    IF ( HAS_KEY ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_READ_INTEGER( PARAMETRIZATION_CONFIGURATION, 'sink-type', PARAMETRIZATION%SINK_TYPE, HOOKS )
    ELSE
      PARAMETRIZATION%TABLES_VERSION = UNDEF_PARAM_E
    ENDIF

    ! Read nested types
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_TIME)                PARAMETRIZATION%TIME%READ_FROM_YAML( PARAMETRIZATION_CONFIGURATION, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_GEOMETRY)            PARAMETRIZATION%GEOMETRY%READ_FROM_YAML( PARAMETRIZATION_CONFIGURATION, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_LEVELS)              PARAMETRIZATION%LEVELS%READ_FROM_YAML( PARAMETRIZATION_CONFIGURATION, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_ENSEMBLE)            PARAMETRIZATION%ENSEMBLE%READ_FROM_YAML( PARAMETRIZATION_CONFIGURATION, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_ANALYSIS)            PARAMETRIZATION%ANALYSIS%READ_FROM_YAML( PARAMETRIZATION_CONFIGURATION, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_WAVE)                PARAMETRIZATION%WAVE%READ_FROM_YAML( PARAMETRIZATION_CONFIGURATION, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_SATELLITE)           PARAMETRIZATION%SATELLITE%READ_FROM_YAML( PARAMETRIZATION_CONFIGURATION, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_DATA_REPRESENTATION) PARAMETRIZATION%DATA_REPRESENTATION%READ_FROM_YAML( PARAMETRIZATION_CONFIGURATION, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_BITMAP)              PARAMETRIZATION%BITMAP%READ_FROM_YAML( PARAMETRIZATION_CONFIGURATION, HOOKS )

    !> Destroy the configuration object
    PP_TRYCALL(ERRFLAG_UNABLE_TO_DELETE_CONFIGURATION) YAML_DELETE_CONFIGURATION( PARAMETRIZATION_CONFIGURATION, HOOKS )

  ENDIF


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read parametrization configuration' )
    CASE(ERRFLAG_UNABLE_TO_READ_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read subconfigurations' )
    CASE(ERRFLAG_UNABLE_TO_READ_TIME)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read time' )
    CASE(ERRFLAG_UNABLE_TO_READ_GEOMETRY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read geometry' )
    CASE(ERRFLAG_UNABLE_TO_READ_LEVELS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read levels' )
    CASE(ERRFLAG_UNABLE_TO_READ_ENSEMBLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read ensemble' )
    CASE(ERRFLAG_UNABLE_TO_READ_ANALYSIS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read analysis' )
    CASE(ERRFLAG_UNABLE_TO_READ_WAVE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read wave' )
    CASE(ERRFLAG_UNABLE_TO_READ_SATELLITE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read satellite' )
    CASE(ERRFLAG_UNABLE_TO_READ_DATA_REPRESENTATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read data representation' )
    CASE(ERRFLAG_UNABLE_TO_DELETE_CONFIGURATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to delete configuration' )
    CASE(ERRFLAG_UNABLE_TO_READ_BITMAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to read bitmap' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION READ_PARAMETRIZATION_FROM_YAML
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'PARAMETRIZATION_TO_YAML'
PP_THREAD_SAFE FUNCTION PARAMETRIZATION_TO_YAML( THIS, UNIT, OFFSET, HOOKS ) RESULT(RET)

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,               ONLY: JPRD_K
  USE :: HOOKS_MOD,                       ONLY: HOOKS_T
  USE :: GRIB_ENCODER_OPTIONS_MOD,        ONLY: GRIB_ENCODER_OPTIONS_T
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: N_PARINTFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: IPARINTFLDS2CPARINTFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: N_PARSTRFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: IPARSTRINGFLDS2CPARSTRINGFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: N_PARFLOATFLDS
  USE :: PARAMETRIZATION_ENUMERATORS_MOD, ONLY: IPARFLOATFLDS2CPARFLOATFLDS

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(PARAMETRIZATION_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: UNIT
  INTEGER(KIND=JPIB_K),     INTENT(IN)    :: OFFSET
  TYPE(HOOKS_T),            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local parameters
  CHARACTER(LEN=32)    :: CTMP
  INTEGER(KIND=JPIB_K) :: WRITE_STAT
  LOGICAL              :: UNIT_OPENED

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNIT_NOT_OPENED=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_IOSTATUS_NOT_ZERO=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_TIME=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_LEVEL=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_BITMAP=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_ENSEMBLE=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_ANALYSIS=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_WAVE=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_SATELLITE=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_DATA_REPRESENTATION=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_WRITE_GEOMETRY=10_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Erro handling
  INQUIRE(UNIT=UNIT, OPENED=UNIT_OPENED)
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.UNIT_OPENED, ERRFLAG_UNIT_NOT_OPENED )

  WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET)//'parametrization:'
  PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )


  ! Print "TablesVersion"
  IF ( THIS%TABLES_VERSION .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%TABLES_VERSION
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'tables-version: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print "GeneratingProcessIdentifier"
  IF ( THIS%GENERATING_PROCESS_IDENTIFIER .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%GENERATING_PROCESS_IDENTIFIER
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'generating-process-identifier: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF
  
  IF ( THIS%TYPE_OF_PROCESSED_DATA .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%TYPE_OF_PROCESSED_DATA
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'type-of-processed-data: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  IF ( THIS%ENCODE_STEP_ZERO .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(F11.4)',IOSTAT=WRITE_STAT) THIS%ENCODE_STEP_ZERO
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'encode-step-zero: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print "GeneratingProcessIdentifier"
  IF ( THIS%SINK_TYPE .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(I8)',IOSTAT=WRITE_STAT) THIS%SINK_TYPE
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'sink-type: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF

  ! Print "ValuesScaleFactor"
  IF ( THIS%VALUES_SCALE_FACTOR .NE. UNDEF_PARAM_E ) THEN
    CTMP = REPEAT(' ',32)
    WRITE(CTMP,'(F11.4)',IOSTAT=WRITE_STAT) THIS%VALUES_SCALE_FACTOR
    WRITE(UNIT,'(A)',IOSTAT=WRITE_STAT) REPEAT(' ',OFFSET+2)//'values-scale-factor: '//TRIM(ADJUSTL(CTMP))
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_STAT .NE. 0, ERRFLAG_IOSTATUS_NOT_ZERO )
  ENDIF


  ! Print sub-parametrizations
  PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_TIME)                THIS%TIME%WRITE_TO_YAML( UNIT, OFFSET+2, HOOKS )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_LEVEL)               THIS%LEVELS%WRITE_TO_YAML( UNIT, OFFSET+2, HOOKS )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_BITMAP)              THIS%BITMAP%WRITE_TO_YAML( UNIT, OFFSET+2, HOOKS )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_ENSEMBLE)            THIS%ENSEMBLE%WRITE_TO_YAML( UNIT, OFFSET+2, HOOKS )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_ANALYSIS)            THIS%ANALYSIS%WRITE_TO_YAML( UNIT, OFFSET+2, HOOKS )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_WAVE)                THIS%WAVE%WRITE_TO_YAML( UNIT, OFFSET+2, HOOKS )
  ! PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_SATELLITE)           THIS%SATELLITE%WRITE_TO_YAML( UNIT, OFFSET+2, HOOKS )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_DATA_REPRESENTATION) THIS%DATA_REPRESENTATION%WRITE_TO_YAML( UNIT, OFFSET+2, HOOKS )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_WRITE_GEOMETRY)            THIS%GEOMETRY%WRITE_TO_YAML( UNIT, OFFSET+2, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNIT_NOT_OPENED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unit not opened' )
    CASE(ERRFLAG_IOSTATUS_NOT_ZERO)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'iostat not zero' )
    CASE(ERRFLAG_UNABLE_TO_WRITE_TIME)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to write time' )
    CASE(ERRFLAG_UNABLE_TO_WRITE_LEVEL)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to write level' )
    CASE(ERRFLAG_UNABLE_TO_WRITE_BITMAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to write bitmap' )
    CASE(ERRFLAG_UNABLE_TO_WRITE_ENSEMBLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to write ensemble' )
    CASE(ERRFLAG_UNABLE_TO_WRITE_ANALYSIS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to write analysis' )
    CASE(ERRFLAG_UNABLE_TO_WRITE_WAVE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to write wave' )
    CASE(ERRFLAG_UNABLE_TO_WRITE_SATELLITE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to write satellite' )
    CASE(ERRFLAG_UNABLE_TO_WRITE_DATA_REPRESENTATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to write data representation' )
    CASE(ERRFLAG_UNABLE_TO_WRITE_GEOMETRY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to write geometry' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN

END FUNCTION PARAMETRIZATION_TO_YAML
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


END MODULE PARAMETRIZATION_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME
