<!DOCTYPE html>
<div id="container"></div>
<script src="d3.v7.js"></script>
<script type="text/javascript" src="data.js"></script>
<script type="module">
  // Specify the dimensions of the chart.
  const width = window.innerWidth;
  const height = window.innerHeight;

  // Specify the color scale.
  const color = d3.scaleOrdinal(d3.schemeCategory10);

  // The force simulation mutates links and nodes, so create a copy
  // so that re-evaluating this cell produces the same result.
  const nodeMap = data.nodeMap;

  // const nodes = data.nodes.map(d => ({...d}));
  // const links = data.links.map(d => ({...d}));
  // Construct nodes from nodemap to refer to same object
  const nodes = []
  for (const [key, value] of Object.entries(nodeMap)) {
    value["id"] = key
    value["linkCount"] = 0
    value["sourceLinkCount"] = 0
    nodes.push(value);
  }

  const sourceTargetMap = {}
  const targetSourceMap = {}
  const links = []
  for (const l of data.links) {
    links.push({"source": nodeMap[l.source], "target": nodeMap[l.target]});

    if(!sourceTargetMap[l.source]) {
        sourceTargetMap[l.source] = new Set()
    }
    sourceTargetMap[l.source].add(l.target)

    if(!targetSourceMap[l.target]) {
        targetSourceMap[l.target] = new Set()
    }
    targetSourceMap[l.target].add(l.source)
  }

  function updateLinkCount(links) {
      for (const [key, value] of Object.entries(nodeMap)) {
        value.linkCount = 0;
        value.sourceLinkCount = 0;
      }

      for (const l of links) {
        nodeMap[l.source.id].linkCount += 1
        nodeMap[l.source.id].sourceLinkCount += 1

        console.log(l)
        console.log(l.target)
        nodeMap[l.target.id].linkCount += 1
      }
  }

  updateLinkCount(links);

  //const types = d3.union(d3.map(data.nodes, n => n.type))
  const types = data.types

  //const typeGroupValues = {}
  //Array.from(types).forEach(t => {
  //  let sl = t.split("::");
  //  if (sl.length > 1) {
  //    let g = sl[0];
  //    if(!typeGroupValues[g]) {
  //      typeGroupValues[g] = {}
  //    }
  //    typeGroupValues[g][sl[1]] = undefined
  //    return g;
  //  } else {
  //    let g = undefined;
  //    if(!typeGroupValues[g]) {
  //      typeGroupValues[g] = {}
  //    }
  //    typeGroupValues[g][sl[0]] = undefined
  //    return g;
  //  };
  //})
  const typeGroupValues = data.typeGroups

  const typesColor = {}
  types.forEach( t => typesColor[t] = color(t))

  const valuesForTypes = {}
  const allValuesForTypes = {}
  const selectors = {}
  types.forEach( g => { valuesForTypes[g] = new Set(); allValuesForTypes[g] = new Set(), selectors[g] = new Set(); })
  for (const [key, value] of Object.entries(nodeMap)) {
    allValuesForTypes[value.type].add(key)
    valuesForTypes[value.type].add(key)
    selectors[value.type].add(key)
  }


  let highlightedNodes = new Set()
  let lastHighlightedNode = undefined

  function highlightNode(nId) {
    highlightedNodes.add(nId)
    lastHighlightedNode = nId;
  }

  function unhighlightNode(nId) {
    if(!!nId) {
        highlightedNodes.delete(nId);
        if (nId == lastHighlightedNode) {
            lastHighlightedNode = undefined;
        }
    }
  }

  function setHighligtedNodes(nIds) {
    highlightedNodes = !!nIds ? nIds : new Set();
    lastHighlightedNode = undefined
  }



  const selectorsGroupContainer = document.createElement('div')
  selectorsGroupContainer.style.position = "absolute"
  selectorsGroupContainer.style.display = "flex"
  selectorsGroupContainer.style.justifyContent = "left";
  selectorsGroupContainer.style.flexDirection = "column";
  selectorsGroupContainer.style.maxWidth = "20%";
  selectorsGroupContainer.style.minWidth= "20em";
  selectorsGroupContainer.style.backgroundColor= "rgba(0,0,0,0.1)";

  function* iterTypeGroupValues(typeGroupValues) {
    for (const typeGroup of data.typeGroupOrder) {
        if (Object.keys(typeGroupValues).includes(typeGroup)) {
            yield [typeGroup, typeGroupValues[typeGroup]]
        }
    }
    for (const [typeGroup, typeVals] of Object.entries(typeGroupValues)) {
        if (!data.typeGroupOrder.includes(typeGroup)) {
            yield [typeGroup, typeVals]
        }
    }
  }

  function* iterTypeValues(typeValues) {
    for (const typeValue of data.typeValueOrder) {
        if (typeValues.includes(typeValue)) {
            yield typeValue
        }
    }
    for (const typeValue of typeValues) {
        if (!data.typeValueOrder.includes(typeValue)) {
            yield typeValue
        }
    }
  }


  for (const [typeGroup, typeVals] of iterTypeGroupValues(typeGroupValues)) {
      let space = 0.25
      let getTypeGroupValue = tv => (typeGroup != "") ? `${typeGroup}::${tv}` : tv;

      const selectorsGroupElem1Outer = document.createElement('div')
      selectorsGroupElem1Outer.style.display = "flex"
      selectorsGroupElem1Outer.style.justifyContent = "left";
      selectorsGroupElem1Outer.style.flexDirection = "column";

      //selectorsGroupElem1Outer.style.border = "solid 0.2em white";
      selectorsGroupElem1Outer.style.width = "100%";
      selectorsGroupElem1Outer.style.marginTop = `${space*4}em`

      const selectorsGroupElem1Inner = document.createElement('label')
      selectorsGroupElem1Inner.htmlFor = `checkbox-group-${typeGroup}`;
      selectorsGroupElem1Inner.style.display = "flex"
      selectorsGroupElem1Inner.style.justifyContent = "left";
      selectorsGroupElem1Inner.style.flexDirection = "row";

      selectorsGroupElem1Inner.style.color = "#000"
      selectorsGroupElem1Inner.style.backgroundColor = "#fff"
      selectorsGroupElem1Inner.style.padding = `${space}em`
      //selectorsGroupElem1Inner.style.margin = "0.5em 0 -0.5em 0.5em"
      selectorsGroupElem1Inner.style.borderRadius = `${space}em`
      selectorsGroupElem1Inner.style.margin = `${space}em`

      const selectorsGroupElem2Inner = document.createElement('div')
      selectorsGroupElem2Inner.style.display = "flex"
      selectorsGroupElem2Inner.style.justifyContent = "left";
      selectorsGroupElem2Inner.style.flexDirection = "row";
      selectorsGroupElem2Inner.style.flexWrap = "wrap";


       const typeGroupCheckBox = document.createElement('input')
       typeGroupCheckBox.type = "checkbox"
       typeGroupCheckBox.name = `checkbox-group-${typeGroup}`
       typeGroupCheckBox.value = typeGroup
       typeGroupCheckBox.id = `checkbox-group-${typeGroup}`

       typeGroupCheckBox.checked = typeVals.map(getTypeGroupValue).reduce((acc, t) => acc || (t in selectors), false)

       function setTypeChecked(t) {
            let sel = document.getElementById(`select-${t}`)
            selectors[t] = new Set(Array.from(sel.options).map(o => o.value))
            for (let opt of document.getElementById(`select-${t}`).options) {
                opt.selected = true;
            }
       }

       function setTypeUnchecked(t) {
            delete selectors[t]
            for (let opt of document.getElementById(`select-${t}`).options) {
                opt.selected = false;
            }
       }

       typeGroupCheckBox.addEventListener("change", d => {
            for (const tv of iterTypeValues(typeVals)) {
                let t = getTypeGroupValue(tv)
                document.getElementById(`checkbox-${t}`).checked = d.target.checked;
                if (d.target.checked) {
                    setTypeChecked(t)
                } else {
                    setTypeUnchecked(t)
                }
             }
             update()
       })

      selectorsGroupElem1Inner.append(typeGroupCheckBox)


      let groupLabelText = document.createTextNode(typeGroup || "general");

      selectorsGroupElem1Inner.append(groupLabelText)

      for (const tv of iterTypeValues(typeVals)) {
           let t = getTypeGroupValue(tv)

           const typeContainer =  document.createElement('div')
           typeContainer.style.display = "flex"
           typeContainer.style.justifyContent = "left";
           typeContainer.style.flexDirection = "column";
           //typeContainer.style.padding = "0.5em 0.5em"

           typeContainer.style.marginRight = `${space}em`
           typeContainer.style.marginLeft = `${space}em`
           typeContainer.style.marginBottom = `${space}em`

           const labelContainer =  document.createElement('label')
           labelContainer.htmlFor = `checkbox-${t}`;
           labelContainer.style.display = "flex"
           labelContainer.style.justifyContent = "left";
           labelContainer.style.flexDirection = "row";

           labelContainer.style.color = "#fff"
           labelContainer.style.backgroundColor = typesColor[t]
           labelContainer.style.padding = `${space}em`
           labelContainer.style.marginBottom = `${space}em`
           labelContainer.style.borderRadius= "1.0em"

           let labelText = document.createTextNode(tv || t);


           const checkBox = document.createElement('input')
           checkBox.type = "checkbox"
           checkBox.name = `checkbox-${t}`
           checkBox.value = t
           checkBox.id = `checkbox-${t}`

           checkBox.checked = (t in selectors)

           checkBox.addEventListener("change", d => {
             if (d.target.checked) {
                setTypeChecked(t)
             } else {
                setTypeUnchecked(t)
             }
             update()
           })

           labelContainer.append(checkBox)
           labelContainer.append(labelText)

           typeContainer.append(labelContainer)

           let sel = document.createElement('select')
           sel.name = t
           sel.disabled = !(t in selectors)
           sel.id = `select-${t}`
           sel.multiple = true
           sel.addEventListener("change", d => {
             selectors[d.target.name] = new Set(Array.from(d.target.selectedOptions).map(o => o.value))
             if (selectors[d.target.name].size == 0) {
                delete selectors[t];
             }
             updateSelectorsUI();

             update()
           });
           typeContainer.append(sel)

           selectorsGroupElem2Inner.append(typeContainer)
      }

      selectorsGroupElem1Outer.append(selectorsGroupElem1Inner)
      selectorsGroupElem1Outer.append(selectorsGroupElem2Inner)
      selectorsGroupContainer.append(selectorsGroupElem1Outer);
  }


  const selectorsGroupElem2 = document.createElement('div')
  selectorsGroupElem2.style.display = "flex"
  selectorsGroupElem2.style.justifyContent = "left";
  selectorsGroupElem2.style.flexDirection = "row";
  selectorsGroupElem2.style.flexWrap = "wrap";
  selectorsGroupElem2.style.padding = "1em 0";

  const buttonUnhighlight = document.createElement('input')
  buttonUnhighlight.type = "button"
  buttonUnhighlight.name = "unhighlighted"
  buttonUnhighlight.value = "(un)highlight all"
  buttonUnhighlight.id = `button-unhighlight`
  buttonUnhighlight.addEventListener("click", e => {
    if (highlightedNodes.size == 0) {
        setHighligtedNodes(new Set(Array.from(Object.values(selectors).map(a => Array.from(a)).flat())) )
        update(false)
    } else {
        setHighligtedNodes()
        update(false)
    }
  })

  const buttonSelectHighlighted = document.createElement('input')
  buttonSelectHighlighted.type = "button"
  buttonSelectHighlighted.name = "select-highlighted"
  buttonSelectHighlighted.value = "select highlighted"
  buttonSelectHighlighted.id = `button-select-highlighted`

  const buttonDeselectHighlighted = document.createElement('input')
  buttonDeselectHighlighted.type = "button"
  buttonDeselectHighlighted.name = "deselect-highlighted"
  buttonDeselectHighlighted.value = "deselect highlighted"
  buttonDeselectHighlighted.id = `button-deselect-highlighted`

  function clearSelectors() {
        for (const k in selectors) {
            delete selectors[k];
        }
  }

  function updateSelectorsUI() {
        for (const t of types) {
            let cb = document.getElementById(`checkbox-${t}`)
            let sel = document.getElementById(`select-${t}`)

            if (t in selectors) {
                cb.checked = true
                for (let o of sel.options)  {
                    o.selected = selectors[t].has(o.value)
                }
            } else {
                cb.checked = false
                for (let o of sel.options) {
                    o.selected = false
                }
            }
        }
  }


  function selectHighlighted() {
        for (const id of highlightedNodes) {
            let n = nodeMap[id]

            if(!selectors[n.type]) {
                selectors[n.type] = new Set()
            }
            selectors[n.type].add(id)
        }
        updateSelectorsUI();
        update();
  }

  function deselectHighlighted() {
        for (const id of highlightedNodes) {
            let n = nodeMap[id]

            // if (!selectors[n.type]) {
            //     selectors[n.type] = new Set([...allValuesForTypes[n.type]])
            // }

            if (selectors[n.type]) {
                selectors[n.type].delete(id)

                if (selectors[n.type].size == 0) {
                    delete selectors[n.type];
                }
            }
        }
        console.log(selectors)
        updateSelectorsUI();
        update();
  }


  function expandHighlighted() {
        setHighligtedNodes(d3.union(highlightedNodes, Array.from(highlightedNodes).map(id => Array.from(sourceTargetMap[id] || new Set())).flat()))
        selectHighlighted()
  }

  function reverseExpandHighlighted() {
        let newHighlighted = new Set()

        for (const id of highlightedNodes) {
           if (targetSourceMap[id]) {
               for (const sId of targetSourceMap[id]) {
                 newHighlighted.add(sId)
               }
           }
        }

        setHighligtedNodes(d3.union(highlightedNodes, newHighlighted))
        selectHighlighted()
  }

  buttonSelectHighlighted.addEventListener("click", d => { clearSelectors(); selectHighlighted(); })
  buttonDeselectHighlighted.addEventListener("click", d => { deselectHighlighted(); })

  const buttonExpandHighlighted = document.createElement('input')
  buttonExpandHighlighted.type = "button"
  buttonExpandHighlighted.name = "expand-highlighted"
  buttonExpandHighlighted.value = "expand highlighted"
  buttonExpandHighlighted.id = `button-expand-highlighted`
  buttonExpandHighlighted.addEventListener("click", expandHighlighted)

  const buttonRevExpandHighlighted = document.createElement('input')
  buttonRevExpandHighlighted.type = "button"
  buttonRevExpandHighlighted.name = "reverse-expand-highlighted"
  buttonRevExpandHighlighted.value = "reverse expand highlighted"
  buttonRevExpandHighlighted.id = `reverse-button-expand-highlighted`
  buttonRevExpandHighlighted.addEventListener("click", reverseExpandHighlighted)

  const buttonExpandCommonHighlighted = document.createElement('input')
  buttonExpandCommonHighlighted.type = "button"
  buttonExpandCommonHighlighted.name = "expand-common-highlighted"
  buttonExpandCommonHighlighted.value = "expand common highlighted"
  buttonExpandCommonHighlighted.id = `button-expand-common-highlighted`
  buttonExpandCommonHighlighted.addEventListener("click", expandCommonHighlighted)

  function expandCommonHighlighted() {
        if (highlightedNodes.size > 0) {
            let targets = Array.from(highlightedNodes).map(id => sourceTargetMap[id] || new Set())
            setHighligtedNodes(d3.union(highlightedNodes, (targets.size == 1) ? targets : targets.reduce((common, r) => Array.from(common).filter(v => r.has(v)))))
            selectHighlighted()
        }
  }

  selectorsGroupContainer.append(selectorsGroupElem2);
  selectorsGroupElem2.append(buttonUnhighlight)
  selectorsGroupElem2.append(buttonDeselectHighlighted)
  selectorsGroupElem2.append(buttonSelectHighlighted)
  selectorsGroupElem2.append(buttonExpandHighlighted)
  selectorsGroupElem2.append(buttonRevExpandHighlighted)
  selectorsGroupElem2.append(buttonExpandCommonHighlighted)

  container.append(selectorsGroupContainer);

  function* iterOptionValues(vals) {
        let valFilter = v => v == "None" || v.endsWith("None")
        let firstVals = Array.from(vals).filter(valFilter).sort()
        let otherVals = Array.from(vals).filter(v => !valFilter(v)).sort()

        for (const v of firstVals) {
            yield v
        }
        for (const v of otherVals) {
            yield v
        }
  }

  function updateTypeSelectorOptions() {
    for (const [t, vals] of Object.entries(valuesForTypes)) {
        let sel = document.getElementById(`select-${t}`)

        if(sel) {
            let newChildren = []
            for (const v of iterOptionValues(vals)) {
                let opt = document.createElement("option")
                opt.value = v
                opt.text = v.split("::").slice(-1)
                opt.selected = selectors[t] && selectors[t].has(v)
                newChildren.push(opt)
            }

            sel.replaceChildren(...newChildren);
        }

    }
  }
  updateTypeSelectorOptions();


  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto;")

  let circleStroke = "#fff"
  //let highlightStroke = "#97FEED"
  let highlightStroke = "#9BE8D8"

  let arrowColor = "#999"
  let arrowOpacity = 1.0


  let markerBoxWidth = 10
  let markerBoxHeight = 10
  let markerRefX = 15
  let markerRefY = 3
  // See https://developer.mozilla.org/en-US/docs/Web/SVG/Element/marker
  svg
    .append('defs')
    .append('marker')
    .attr('id', 'arrow')
    .attr('viewBox', [0, 0, markerBoxWidth, markerBoxHeight])
    .attr('refX', markerRefX)
    .attr('refY', markerRefY)
    .attr('markerWidth', markerBoxWidth)
    .attr('markerHeight', markerBoxHeight)
    //.attr('orient', 'auto-start-reverse')
    .attr('orient', 'auto')
    .append('path')
    //.attr('d', d3.line()(arrowPoints))
    .attr("d", "M 0 0 6 3 0 6 1.5 3")
      .attr("fill", arrowColor)
      .attr("fill-opacity", arrowOpacity)

  const zoomGroup = svg.append("g")

  // Add a line for each link, and a circle for each node.
  const link = zoomGroup.append("g")
      .attr("stroke", arrowColor)
      .attr("stroke-opacity", arrowOpacity)
      .attr("class", "links")
      .selectAll()
      .data(links)
      .join(enterLink);

  const node = zoomGroup.append("g")
      .attr("stroke-width", 1.5)
      .attr("class", "nodes")
      .selectAll()
      .data(nodes)
      .join(enterNode);


  function linkDistance(d) {
        switch (d.source.type) {
            case "category":
                return 100
            case "keys::group":
                return 100
            case d.target.type:
                return 100
            default:
                return d.source.type.includes("::") ? 300 : 60 + Math.pow(d.source.linkCount, 1.25);
            }
    }

  function linkStrength(d) {
      switch (d.source.type) {
        case "keys::group":
        case "category":
            return 1.0
        case d.target.type:
            return 0.9
        default:
            return d.source.type.includes("::") ? 0.1 : 0.4;
    }
  }

  function chargeStrength(n) {
      switch (n.type) {
        case "key::":
            return -200;
        default:
            return Math.min(-50, -10 + Math.pow(n.linkCount, 1.25) * -10);
      }
  }

  // Create a simulation with several forces.
  const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links)
        .distance(linkDistance)
        .strength(linkStrength)
        .id(d => d.id)
        )
      .force("charge", d3.forceManyBody().strength(chargeStrength))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .on("tick", ticked);


  function updateLink(l) {
    l
      .style("opacity", d => {
            if (highlightedNodes.has(d.source.id) || highlightedNodes.has(d.target.id)) {
                return 0.9;
            } else {
                return 0.1 + (1.0 / Math.pow(d.source.linkCount, 0.70))
            }
        }
      )
      .attr("stroke", d => {
        return (highlightedNodes.has(d.source.id) || highlightedNodes.has(d.target.id)) ? highlightStroke : arrowColor;
      })
      .attr("stroke-width", d => {
        return (highlightedNodes.has(d.source.id) || highlightedNodes.has(d.target.id)) ? 2.0 : 1.0;
      })
      .attr('marker-end', 'url(#arrow)')
  }

 function enterLink(enter) {
      let l =  enter.append("line").attr("class", "link")
        updateLink(l);

      return l
  }


  function updateNode(n) {
    n.select("circle")
         .attr("stroke",
                n => {
                  return (highlightedNodes.has(n.id)) ? highlightStroke : circleStroke;
              }
         )
         .attr("r",
              n => {
                let highlightMaybe = r => highlightedNodes.has(n.id) ? r + 2.0 : r;
                switch(n.type) {
                    case "category::":
                        return highlightMaybe(14.0);
                    case "keys::group":
                        return highlightMaybe(12.0);
                    default:
                        return n.type.includes("category::") ? highlightMaybe(8.5) : highlightMaybe(7.0);
                }
            }
         )
         .attr("fill", d => typesColor[d.type])

    n.select("title")
          .text(d => d.id.split("::").slice(-1));

    n.select("text")
          .text(d => d.id.includes("key::") ? "" : d.id.split("::").slice(-1));

    n.on("click", n => {
            let id = n.target.__data__.id
            if (highlightedNodes.has(id)) {
                unhighlightNode(id);;
            } else {
                highlightNode(id);;
            }
            update(false)
         })
  }

  function enterNode(enter) {
    let n =  enter.append("g").attr("class", "node")
      n.append("circle");
      n.append("title")
      n.append("text")
        .attr("dx", 12)
        .attr("dy", ".35em")
        .attr('stroke', 'grey')

      // Add a drag behavior.
      n.call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

      updateNode(n);

      return n
  }



  function update(restartSimulation=true) {
      let testNode = (n =>
        (n.type in selectors) && (selectors[n.type].size == 0 ? true : selectors[n.type].has(n.id)))

      let filteredNodes = nodes.filter(testNode);
      let filteredLinks = links.filter(l => testNode(l.source) && testNode(l.target));

      updateLinkCount(filteredLinks);

      simulation.nodes(filteredNodes)
      simulation.force("link").links(filteredLinks)

      if(restartSimulation) {
          simulation.alpha(1).restart();
      }


      d3.select(".nodes").selectAll(".node")
          .data(filteredNodes)
          .join(enterNode, updateNode);

      d3.select(".links").selectAll(".link")
          .data(filteredLinks)
          .join(enterLink, updateLink);

  }


  svg.call(d3.zoom().on("zoom", function (event) {
           zoomGroup.attr("transform", event.transform)
        }))
    // .call(zoom.translateTo, 0, 0);

  // Set the position attributes of links and nodes each time the simulation ticks.
  function ticked() {
    d3.select(".links").selectAll(".link")
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

    d3.select(".nodes").selectAll(".node")
        //.attr("cx", d => d.x)
        //.attr("cy", d => d.y);
        .attr("transform", function(d) {
          return "translate(" + d.x + "," + d.y + ")";
        })
  }

  // Reheat the simulation when drag starts, and fix the subject position.
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  // Update the subject (dragged node) position during drag.
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  // Restore the target alpha so the simulation cools after dragging ends.
  // Unfix the subject position now that it’s no longer being dragged.
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }

  // When this cell is re-run, stop the previous simulation. (This doesn’t
  // really matter since the target alpha is zero and the simulation will
  // stop naturally, but it’s a good practice.)
  // invalidation.then(() => simulation.stop());

  // Append the SVG element.
  container.append(svg.node());
</script>
