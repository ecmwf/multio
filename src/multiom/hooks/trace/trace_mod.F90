! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"


#define PP_FILE_NAME 'trace_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'TRACE_MOD'
MODULE TRACE_MOD

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPTR_K

IMPLICIT NONE

! Default visibility
PRIVATE

! Datatype used by the traces to save the current hook handle
TYPE :: TRACE_HOOK_T
  REAL(KIND=JPTR_K) :: ZHOOK_HANDLE_
END TYPE

! The tracer type
TYPE :: TRACER_T
  PRIVATE
CONTAINS
  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: ENTER_PROCEDURE           => TRACE_ENTER_PROCEDURE
  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: EXIT_PROCEDURE_ON_SUCCESS => TRACE_EXIT_PROCEDURE_ON_SUCCESS
  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: EXIT_PROCEDURE_ON_ERROR   => TRACE_EXIT_PROCEDURE_ON_ERROR
END TYPE

! Explicit interface (same interface used by doctor hook)
INTERFACE
  SUBROUTINE DR_HOOK_DEFAULT8_IF(CDNAME,KSWITCH,PKEY)
    USE :: DATAKINDS_DEF_MOD, ONLY: JPIM_K
    USE :: DATAKINDS_DEF_MOD, ONLY: JPTR_K
  IMPLICIT NONE
    CHARACTER(LEN=*),     INTENT(IN)    :: CDNAME
    INTEGER(KIND=JPIM_K), INTENT(IN)    :: KSWITCH
    REAL(KIND=JPTR_K),    INTENT(INOUT) :: PKEY
  END SUBROUTINE DR_HOOK_DEFAULT8_IF
END INTERFACE

! Pointer to the tracer handler
PROCEDURE(DR_HOOK_DEFAULT8_IF), POINTER :: DR_HOOK => NULL()
LOGICAL :: LHOOK_ = .FALSE.


! Whitelist of public symbols (types)
PUBLIC :: TRACER_T
PUBLIC :: TRACE_HOOK_T

! Whitelist of public symbols (procedures)
PUBLIC :: OM_SET_DR_HOOK

CONTAINS



#define PP_PROCEDURE_TYPE 'SUBROUTINE'
#define PP_PROCEDURE_NAME 'OM_SET_DR_HOOK'
PP_THREAD_SAFE SUBROUTINE OM_SET_DR_HOOK( LHOOK, DR_HOOK_PROCEDURE )

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K

IMPLICIT NONE

  ! Dummy arguments
  LOGICAL,            INTENT(IN) :: LHOOK
  PROCEDURE(DR_HOOK_DEFAULT8_IF) :: DR_HOOK_PROCEDURE

! Initialize the local static variables
!$omp single
  LHOOK_  = LHOOK
  DR_HOOK => DR_HOOK_PROCEDURE
!$omp end single

  ! Return the function result
  RETURN

END SUBROUTINE OM_SET_DR_HOOK
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE




#define PP_PROCEDURE_TYPE 'SUBROUTINE'
#define PP_PROCEDURE_NAME 'TRACE_ENTER_PROCEDURE'
PP_THREAD_SAFE SUBROUTINE TRACE_ENTER_PROCEDURE( THIS, TRACER, FNAME, SECTION_TYPE, &
& SECTION_NAME, PROC_TYPE, PROC_NAME, LINE )

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIM_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K

IMPLICIT NONE

  ! Dummy arguments
  CLASS(TRACER_T),      INTENT(INOUT) :: THIS
  TYPE(TRACE_HOOK_T),   INTENT(INOUT) :: TRACER
  CHARACTER(LEN=*),     INTENT(IN)    :: FNAME
  CHARACTER(LEN=*),     INTENT(IN)    :: SECTION_TYPE
  CHARACTER(LEN=*),     INTENT(IN)    :: SECTION_NAME
  CHARACTER(LEN=*),     INTENT(IN)    :: PROC_TYPE
  CHARACTER(LEN=*),     INTENT(IN)    :: PROC_NAME
  INTEGER(KIND=JPIM_K), INTENT(IN)    :: LINE

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  IF ( ASSOCIATED(DR_HOOK) .AND. LHOOK_ ) THEN
    CALL DR_HOOK( TRIM(SECTION_NAME)//'::'//TRIM(PROC_NAME), 0, TRACER%ZHOOK_HANDLE_ )
  ENDIF

  RETURN

END SUBROUTINE TRACE_ENTER_PROCEDURE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'SUBROUTINE'
#define PP_PROCEDURE_NAME 'TRACE_EXIT_PROCEDURE_ON_SUCCESS'
PP_THREAD_SAFE SUBROUTINE TRACE_EXIT_PROCEDURE_ON_SUCCESS( THIS, TRACER, FNAME, &
& SECTION_TYPE, SECTION_NAME, PROC_TYPE, PROC_NAME, LINE )

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIM_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K

IMPLICIT NONE

  ! Dummy arguments
  CLASS(TRACER_T),      INTENT(INOUT) :: THIS
  TYPE(TRACE_HOOK_T),   INTENT(INOUT) :: TRACER
  CHARACTER(LEN=*),     INTENT(IN)    :: FNAME
  CHARACTER(LEN=*),     INTENT(IN)    :: SECTION_TYPE
  CHARACTER(LEN=*),     INTENT(IN)    :: SECTION_NAME
  CHARACTER(LEN=*),     INTENT(IN)    :: PROC_TYPE
  CHARACTER(LEN=*),     INTENT(IN)    :: PROC_NAME
  INTEGER(KIND=JPIM_K), INTENT(IN)    :: LINE

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  IF ( ASSOCIATED(DR_HOOK) .AND. LHOOK_ ) THEN
    CALL DR_HOOK( TRIM(SECTION_NAME)//'::'//TRIM(PROC_NAME), 1, TRACER%ZHOOK_HANDLE_ )
  ENDIF

  RETURN

END SUBROUTINE TRACE_EXIT_PROCEDURE_ON_SUCCESS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'SUBROUTINE'
#define PP_PROCEDURE_NAME 'TRACE_EXIT_PROCEDURE_ON_ERROR'
PP_THREAD_SAFE SUBROUTINE TRACE_EXIT_PROCEDURE_ON_ERROR( THIS, TRACER, FNAME, &
& SECTION_TYPE, SECTION_NAME, PROC_TYPE, PROC_NAME, LINE )

  ! Symbolds imported from intrinsic modules
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIM_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K

IMPLICIT NONE

  ! Dummy arguments
  CLASS(TRACER_T),      INTENT(INOUT) :: THIS
  TYPE(TRACE_HOOK_T),   INTENT(INOUT) :: TRACER
  CHARACTER(LEN=*),     INTENT(IN)    :: FNAME
  CHARACTER(LEN=*),     INTENT(IN)    :: SECTION_TYPE
  CHARACTER(LEN=*),     INTENT(IN)    :: SECTION_NAME
  CHARACTER(LEN=*),     INTENT(IN)    :: PROC_TYPE
  CHARACTER(LEN=*),     INTENT(IN)    :: PROC_NAME
  INTEGER(KIND=JPIM_K), INTENT(IN)    :: LINE

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET
!$omp critical(ERROR_HANDLER)
  WRITE(ERROR_UNIT,*) 'ERROR: ', TRIM(SECTION_NAME)//'::'//TRIM(PROC_NAME), ' failed at line ', LINE
!$omp end critical(ERROR_HANDLER)

  RETURN

END SUBROUTINE TRACE_EXIT_PROCEDURE_ON_ERROR
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



END MODULE TRACE_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME
