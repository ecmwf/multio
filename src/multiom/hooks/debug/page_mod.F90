MODULE PAGE_MANAGER_MOD
  IMPLICIT NONE

  ! CONSTANTS FOR PAGE AND LINE LENGTH
  INTEGER, PARAMETER :: PAGE_LENGTH_T = 50     ! NUMBER OF LINES PER PAGE
  INTEGER, PARAMETER :: LINE_LEN_T = 80        ! MAXIMUM NUMBER OF CHARACTERS PER LINE

  ! DEFINE A PAGE TYPE: AN ARRAY OF PAGE_LENGTH_T LINES, EACH LINE_LEN_T CHARACTERS LONG
  TYPE :: PAGE_T
    CHARACTER(LEN=LINE_LEN_T), DIMENSION(PAGE_LENGTH_T) :: LINES
    INTEGER :: CURRENT_LINE = 1          ! KEEP TRACK OF THE CURRENT LINE TO WRITE TO
    INTEGER :: CURRENT_COLUMN = 0        ! KEEP TRACK OF THE CURRENT COLUMN IN THE LINE
    TYPE(PAGE_T), POINTER :: NEXT => NULL() ! POINTER TO THE NEXT PAGE
  END TYPE PAGE_T

  ! DEFINE THE PAGE MANAGER CLASS
  TYPE :: PAGE_MANAGER_T
    TYPE(PAGE_T), POINTER :: HEAD => NULL()    ! POINTER TO THE FIRST PAGE
    TYPE(PAGE_T), POINTER :: CURRENT_PAGE => NULL() ! POINTER TO THE CURRENT PAGE
  CONTAINS
    PROCEDURE :: INIT             ! INITIALIZES THE PAGE MANAGER
    PROCEDURE :: FREE             ! FREES THE PAGE MANAGER
    PROCEDURE :: WRITE_MSG        ! WRITES A MESSAGE TO THE PAGE
    PROCEDURE :: PRINT_PAGE       ! PRINTS ALL PAGES
  END TYPE PAGE_MANAGER_T

CONTAINS

SUBROUTINE INIT(THIS)
  CLASS(PAGE_MANAGER_T), INTENT(INOUT) :: THIS
  ALLOCATE(THIS%HEAD)
  THIS%CURRENT_PAGE => THIS%HEAD
  THIS%CURRENT_PAGE%CURRENT_LINE = 1
  THIS%CURRENT_PAGE%CURRENT_COLUMN = 0
END SUBROUTINE INIT

SUBROUTINE FREE(THIS)
  CLASS(PAGE_MANAGER_T), INTENT(INOUT) :: THIS
  TYPE(PAGE_T), POINTER :: TEMP_PAGE, CURRENT_PAGE

  CURRENT_PAGE => THIS%HEAD
  DO WHILE (ASSOCIATED(CURRENT_PAGE))
    TEMP_PAGE => CURRENT_PAGE%NEXT
    DEALLOCATE(CURRENT_PAGE)
    CURRENT_PAGE => TEMP_PAGE
  END DO
  THIS%HEAD => NULL()
  THIS%CURRENT_PAGE => NULL()
END SUBROUTINE FREE

SUBROUTINE WRITE_MSG(THIS, MESSAGE, ADVANCE)
  CLASS(PAGE_MANAGER_T), INTENT(INOUT) :: THIS
  CHARACTER(LEN=*), INTENT(IN) :: MESSAGE
  LOGICAL, INTENT(IN), OPTIONAL :: ADVANCE
  LOGICAL :: ADVANCE_SET
  INTEGER :: MSG_LEN, REMAINING_LEN, SPACE_POS
  CHARACTER(LEN=LINE_LEN_T) :: LINE_CHUNK
  CHARACTER(LEN=LEN_TRIM(MESSAGE)+2) :: REMAINING_MSG
  CHARACTER(LEN=1) :: BLANK_CHAR = ' '

  ! DEFAULT VALUE FOR ADVANCE IS TRUE
  ADVANCE_SET = .TRUE.
  IF (PRESENT(ADVANCE)) THEN
    ADVANCE_SET = ADVANCE
  END IF

  ! INITIALIZE VARIABLES
  IF ( ADVANCE_SET ) THEN
    MSG_LEN = LEN_TRIM(MESSAGE)
    REMAINING_MSG = MESSAGE
  ELSE
    MSG_LEN = LEN_TRIM(MESSAGE)+1
    REMAINING_MSG = TRIM(MESSAGE)//' '
  ENDIF

  ! LOOP UNTIL ALL OF THE MESSAGE IS WRITTEN
  DO WHILE (MSG_LEN > 0)
    REMAINING_LEN = LINE_LEN_T - THIS%CURRENT_PAGE%CURRENT_COLUMN

    ! IF THE REMAINING MESSAGE FITS IN THE CURRENT LINE
    IF (MSG_LEN <= REMAINING_LEN) THEN
      ! APPEND THE MESSAGE TO THE CURRENT LINE STARTING AT THE CURRENT COLUMN
      THIS%CURRENT_PAGE%LINES(THIS%CURRENT_PAGE%CURRENT_LINE)(THIS%CURRENT_PAGE%CURRENT_COLUMN+1:) = &
        ADJUSTL(REMAINING_MSG(1:MSG_LEN))

      ! UPDATE CURRENT COLUMN POSITION
      THIS%CURRENT_PAGE%CURRENT_COLUMN = THIS%CURRENT_PAGE%CURRENT_COLUMN + MSG_LEN

      ! IF ADVANCE IS TRUE, MOVE TO THE NEXT LINE AND RESET CURRENT COLUMN
      IF (ADVANCE_SET) THEN
        IF (THIS%CURRENT_PAGE%CURRENT_LINE .EQ. PAGE_LENGTH_T) THEN
          CALL ADD_PAGE(THIS)
        ELSE
          THIS%CURRENT_PAGE%CURRENT_LINE = THIS%CURRENT_PAGE%CURRENT_LINE + 1
          THIS%CURRENT_PAGE%CURRENT_COLUMN = 0
        END IF
      END IF
      EXIT
    ELSE
      ! FIND A GOOD PLACE TO SPLIT (AT THE LAST SPACE WITHIN THE LIMIT)
      SPACE_POS = INDEX(ADJUSTL(REMAINING_MSG(1:REMAINING_LEN)), BLANK_CHAR, BACK=.TRUE.)

      ! IF NO SPACE IS FOUND, SPLIT AT THE LINE LENGTH
      IF (SPACE_POS == 0) THEN
        IF (THIS%CURRENT_PAGE%CURRENT_LINE < PAGE_LENGTH_T) THEN
          THIS%CURRENT_PAGE%CURRENT_LINE = THIS%CURRENT_PAGE%CURRENT_LINE + 1
        ELSE
          CALL ADD_PAGE(THIS)
        END IF
        THIS%CURRENT_PAGE%CURRENT_COLUMN = 0
        REMAINING_LEN = LINE_LEN_T
        SPACE_POS = INDEX(ADJUSTL(REMAINING_MSG(1:REMAINING_LEN)), BLANK_CHAR, BACK=.TRUE.)
        IF ( SPACE_POS .EQ. 0) SPACE_POS = REMAINING_LEN
      ENDIF

      ! SPLIT THE MESSAGE
      LINE_CHUNK = ADJUSTL(REMAINING_MSG(1:SPACE_POS))
      THIS%CURRENT_PAGE%LINES(THIS%CURRENT_PAGE%CURRENT_LINE)(THIS%CURRENT_PAGE%CURRENT_COLUMN+1:) = LINE_CHUNK

      ! UPDATE REMAINING MESSAGE
      REMAINING_MSG = REMAINING_MSG(SPACE_POS+1:)
      IF ( ADVANCE_SET ) THEN
        MSG_LEN = LEN_TRIM(REMAINING_MSG)
      ELSE
        MSG_LEN = LEN_TRIM(REMAINING_MSG)+1
      ENDIF

      ! MOVE TO THE NEXT LINE AND RESET CURRENT COLUMN
      IF (THIS%CURRENT_PAGE%CURRENT_LINE < PAGE_LENGTH_T) THEN
        THIS%CURRENT_PAGE%CURRENT_LINE = THIS%CURRENT_PAGE%CURRENT_LINE + 1
      ELSE
        CALL ADD_PAGE(THIS)
      END IF
      THIS%CURRENT_PAGE%CURRENT_COLUMN = 0
    END IF
  END DO
END SUBROUTINE WRITE_MSG

SUBROUTINE ADD_PAGE(THIS)
  CLASS(PAGE_MANAGER_T), INTENT(INOUT) :: THIS
  TYPE(PAGE_T), POINTER :: NEW_PAGE
  INTEGER :: I
  ! ALLOCATE A NEW PAGE
  ALLOCATE(NEW_PAGE)
  NEW_PAGE%CURRENT_LINE = 1
  NEW_PAGE%CURRENT_COLUMN = 0
  NEW_PAGE%NEXT => NULL()

  DO I = 1, PAGE_LENGTH_T
    NEW_PAGE%LINES(I) = REPEAT(' ', LINE_LEN_T)
  END DO

  ! LINK THE NEW PAGE TO THE CURRENT ONE
  THIS%CURRENT_PAGE%NEXT => NEW_PAGE
  THIS%CURRENT_PAGE => NEW_PAGE
END SUBROUTINE ADD_PAGE

SUBROUTINE PRINT_PAGE(THIS)
  CLASS(PAGE_MANAGER_T), INTENT(IN) :: THIS
  TYPE(PAGE_T), POINTER :: CURRENT_PAGE
  INTEGER :: I

  ! START FROM THE FIRST PAGE
  CURRENT_PAGE => THIS%HEAD
  DO WHILE (ASSOCIATED(CURRENT_PAGE))
    ! PRINT ALL LINES OF THE CURRENT PAGE
    DO I = 1, CURRENT_PAGE%CURRENT_LINE
      IF (LEN_TRIM(CURRENT_PAGE%LINES(I)) > 0) THEN
        PRINT *, TRIM(CURRENT_PAGE%LINES(I))
      END IF
    END DO

    ! MOVE TO THE NEXT PAGE
    CURRENT_PAGE => CURRENT_PAGE%NEXT
  END DO
END SUBROUTINE PRINT_PAGE

END MODULE PAGE_MANAGER_MOD

PROGRAM TestPageManager
  USE page_manager_mod
  IMPLICIT NONE

  TYPE(page_manager_t) :: page_manager
  CHARACTER(LEN=256) :: long_message
  CHARACTER(LEN=1024) :: llong_message
  CHARACTER(LEN=80) :: short_message
  INTEGER :: I

  ! Initialize the page manager
  CALL page_manager%init()

  ! Define messages
  long_message = 'This is a very long message that will be split over multiple '//&
&                'lines because it exceeds the maximum line length.'
  short_message = 'This is a short message.'

  llong_message='Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do '//&
& 'eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim '//&
& 'veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo '//&
& 'consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum '//&
& 'dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, '//&
& 'sunt in culpa qui officia deserunt mollit anim id est laborum.'

  ! Write the long message with advance = TRUE (default)
  CALL page_manager%write_msg(long_message, advance=.FALSE.)

  ! Write the short message without advancing (keeps writing on the current line)
  CALL page_manager%write_msg(short_message, advance=.FALSE.)
  CALL page_manager%write_msg(long_message, advance=.TRUE.)

  DO I = 1, 1000
    CALL page_manager%write_msg( llong_message, advance=.FALSE.)
  END DO

  CALL page_manager%print_page()

  ! Free the page manager
  CALL page_manager%free()

END PROGRAM TestPageManager