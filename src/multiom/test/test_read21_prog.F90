! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"

#define PP_FILE_NAME 'test_read21_prog.F90'
#define PP_SECTION_TYPE 'PROGRAM'
#define PP_SECTION_NAME 'TEST_READ21_PROG'
#define PP_PROCEDURE_TYPE 'PROGRAM'
#define PP_PROCEDURE_NAME 'MAIN'
PROGRAM TEST_READ21_PROG

  !> Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIM_K
  USE :: HOOKS_MOD, ONLY: HOOKS_T

  USE :: FILTER_OPTIONS_MOD,         ONLY: FILTER_OPTIONS_T
  USE :: GRIB_ENCODER_OPTIONS_MOD,   ONLY: GRIB_ENCODER_OPTIONS_T
  USE :: MAPPING_OPTIONS_MOD,        ONLY: MAPPING_OPTIONS_T
  USE :: CACHE_UTILS_MOD,            ONLY: CACHE_OPTIONS_T

  USE :: PARAMETRIZATION_MOD,        ONLY: PARAMETRIZATION_T
  USE :: FORTRAN_MESSAGE_MOD,        ONLY: FORTRAN_MESSAGE_T
  USE :: METADATA_BASE_MOD,          ONLY: METADATA_BASE_A
  USE :: METADATA_FACTORY_MOD,       ONLY: MAKE_METADATA
  USE :: METADATA_FACTORY_MOD,       ONLY: DESTROY_METADATA
  USE :: METADATA_LIST_MOD,          ONLY: METADATA_LIST_T
  USE :: MULTIOM_CACHED_ENCODER_MOD, ONLY: MULTIOM_CACHED_ENCODERS_T

  USE :: MULTIOM_DEBUG_MOD, ONLY: DEBUG_POINT_COLLECTION_T

  !> Symbbols imported from external library
  USE :: GRIB_API, ONLY: GRIB_SET_SAMPLES_PATH
  USE :: GRIB_API, ONLY: GRIB_SUCCESS
  USE :: GRIB_API, ONLY: GRIB_GET_ERROR_STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Test encodr object
  TYPE(HOOKS_T) :: HOOKS
  LOGICAL :: IS_EMPTY
  CHARACTER(LEN=256) :: MAPPING_FNAME
  CHARACTER(LEN=256) :: ENCODER_FNAME
  CHARACTER(LEN=256) :: DEBUG_FNAME
  CHARACTER(LEN=256) :: TEST_NAME
  CHARACTER(LEN=256) :: SAMPLES_PATH
  INTEGER(KIND=JPIM_K) :: KRET
  LOGICAL :: FEXIST
  INTEGER(KIND=JPIB_K) :: ID
  INTEGER(KIND=JPIB_K) :: N_SAMPLES
  INTEGER(KIND=JPIB_K) :: RET
  INTEGER(KIND=JPIB_K) :: LENGTH
  INTEGER(KIND=JPIB_K) :: UNIT
  INTEGER(KIND=JPIB_K) :: OFFSET
  INTEGER(KIND=JPIB_K) :: WRITE_ERROR
  CLASS(METADATA_BASE_A), POINTER :: METADATA
  CLASS(METADATA_BASE_A), POINTER :: MD
  TYPE(METADATA_LIST_T) :: METADATA_LIST
  TYPE(MULTIOM_CACHED_ENCODERS_T) :: MULTIO_ENCODER
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  ! Message parameters
  TYPE(FORTRAN_MESSAGE_T) :: MSG
  TYPE(PARAMETRIZATION_T) :: PAR
  TYPE(DEBUG_POINT_COLLECTION_T) :: DEBUG_POINTS
  CHARACTER(LEN=256) :: MAPPING_TAG
  CHARACTER(LEN=256) :: MAPPING_NAME
  CHARACTER(LEN=256) :: ENCODER_TAG
  CHARACTER(LEN=256) :: ENCODER_NAME

  ! Options
  TYPE(CACHE_OPTIONS_T)        :: CACHE_OPTIONS
  TYPE(GRIB_ENCODER_OPTIONS_T) :: ENCODER_OPTIONS
  TYPE(MAPPING_OPTIONS_T)      :: MAPPING_OPTIONS
  TYPE(FILTER_OPTIONS_T)       :: FILTER_OPTIONS

  ! Error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_INITIALIZE_ENCODER = 1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_FREE_ENCODER = 2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_LOADING_LOCAL_SAMPLE = 3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_FREE_METADATA = 4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ENCODING_RULE_PRINT_ERROR = 5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_SET_SAMPLES_PATH = 6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_LOAD_MSGPAR = 7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_METADATA_LIST_FREE = 8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_FREE_METADATA_LIST = 9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_DEALLOCATE_METADATA = 10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_CHECK_LIST = 11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ENCODER_ENCODE = 12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_TEST_CASES = 13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_LOAD_TEST_CASES = 14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_WRITE_LOG = 15_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()


  ! Get the first command-line argument (index starts from 1)
  MAPPING_FNAME = REPEAT(' ', 256)
  ENCODER_FNAME = REPEAT(' ', 256)
  IF ( COMMAND_ARGUMENT_COUNT() .EQ. 4 ) THEN
    ! Get sample path
    CALL GET_COMMAND_ARGUMENT(1, SAMPLES_PATH, LENGTH, RET )
    CALL GRIB_SET_SAMPLES_PATH( TRIM(SAMPLES_PATH), STATUS=KRET )
    PP_DEBUG_CRITICAL_COND_THROW( KRET.NE.GRIB_SUCCESS, ERRFLAG_UNABLE_TO_SET_SAMPLES_PATH )
    ! Get encoder rules
    CALL GET_COMMAND_ARGUMENT(2, ENCODER_FNAME, LENGTH, RET )
    IF (RET .NE. 0) THEN
      ENCODER_FNAME = 'encoder-rules.yaml'
    END IF
    ! Get mapping rules
    CALL GET_COMMAND_ARGUMENT(3, MAPPING_FNAME, LENGTH, RET )
    IF (RET .NE. 0) THEN
      MAPPING_FNAME = 'mapping-rules.yaml'
    END IF
    ! Get mapping rules
    CALL GET_COMMAND_ARGUMENT(4, DEBUG_FNAME, LENGTH, RET )
    IF (RET .NE. 0) THEN
      DEBUG_FNAME = 'test-cases.yaml'
    END IF
  ELSE
    DEBUG_FNAME   = 'test-cases.yaml'
    ENCODER_FNAME = 'encoder-rules.yaml'
    MAPPING_FNAME = 'mapping-rules.yaml'
  END IF

  !> Set the unit and offset
  UNIT = 6
  OFFSET = 1
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Load teh debug points
  PP_TRYCALL(ERRFLAG_LOAD_TEST_CASES) DEBUG_POINTS%INIT( DEBUG_FNAME, HOOKS )

  !> Open the configuration file
  PP_TRYCALL( ERRFLAG_LOADING_LOCAL_SAMPLE ) MAKE_METADATA( METADATA, 'log', 'sample', HOOKS )

  !> Create the encoder
  PP_TRYCALL(ERRFLAG_UNABLE_INITIALIZE_ENCODER) MULTIO_ENCODER%INIT( &
  &   MAPPING_FNAME, ENCODER_FNAME, METADATA, &
  &   CACHE_OPTIONS, ENCODER_OPTIONS, MAPPING_OPTIONS, FILTER_OPTIONS, &
  &   HOOKS )

  !> Print the encoder
  PP_TRYCALL(ERRFLAG_ENCODING_RULE_PRINT_ERROR) MULTIO_ENCODER%PRINT( UNIT, OFFSET, HOOKS )

  !> Get the number of samples
  PP_TRYCALL( ERRFLAG_LOADING_LOCAL_SAMPLE ) DEBUG_POINTS%SIZE( N_SAMPLES, HOOKS )

  !> Loop over the samples
  LoopOverSamples: DO ID = 1, N_SAMPLES

    !> Load the message parameters
    PP_TRYCALL(ERRFLAG_UNABLE_TO_LOAD_MSGPAR) DEBUG_POINTS%GET( ID, TEST_NAME, MSG, PAR, HOOKS )

    !> Logging
    WRITE(6_JPIB_K,*,IOSTAT=WRITE_ERROR) 'Processing sample: ', TEST_NAME
    PP_DEBUG_CRITICAL_COND_THROW( WRITE_ERROR .NE. 0, ERRFLAG_UNABLE_WRITE_LOG )
    PP_TRYCALL(ERRFLAG_UNABLE_WRITE_LOG) MSG%PRINT( 6_JPIB_K, HOOKS )

    STOP 0

    !> Initialize the metadata list
    PP_TRYCALL(ERRFLAG_UNABLE_FREE_METADATA_LIST) METADATA_LIST%INIT( HOOKS )

    !> Encode the message
    PP_TRYCALL(ERRFLAG_ENCODER_ENCODE) MULTIO_ENCODER%ENCODE( MSG, PAR, METADATA_LIST, HOOKS )

    !> Loop over the encoding rules
    PP_TRYCALL(ERRFLAG_UNABLE_CHECK_LIST) METADATA_LIST%IS_EMPTY( IS_EMPTY, HOOKS )
    LoopOverEncodingRules: DO WHILE ( .NOT.IS_EMPTY )

      !> Get the encoding rule
      PP_TRYCALL(ERRFLAG_ENCODING_RULE_PRINT_ERROR) METADATA_LIST%POP( MSG, PAR, &
&        MAPPING_TAG, MAPPING_NAME, ENCODER_TAG, ENCODER_NAME, MD, HOOKS )

      !> TODO: Do something with the encoded metadata

      !> Free the encoded metadata
      PP_TRYCALL(ERRFLAG_UNABLE_DEALLOCATE_METADATA) DESTROY_METADATA( MD, HOOKS )

      !> Increment the counter
      PP_TRYCALL(ERRFLAG_UNABLE_CHECK_LIST) METADATA_LIST%IS_EMPTY( IS_EMPTY, HOOKS )

    ENDDO LoopOverEncodingRules

    !> Free the metadata list
    PP_TRYCALL(ERRFLAG_METADATA_LIST_FREE) METADATA_LIST%FREE( HOOKS )

    !> Deallocate all the rules
    PP_TRYCALL(ERRFLAG_UNABLE_FREE_ENCODER) MULTIO_ENCODER%FREE( HOOKS )

  ENDDO LoopOverSamples

  ! Destroy metadata
  PP_TRYCALL(ERRFLAG_UNABLE_FREE_METADATA_LIST) DESTROY_METADATA( METADATA, HOOKS )

  !> Free the debug points
  PP_TRYCALL(ERRFLAG_FREE_TEST_CASES) DEBUG_POINTS%FREE( HOOKS )

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  !> Exit point (on success)
  STOP 0

! Error handler
PP_ERROR_HANDLER

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_UNABLE_TO_SET_SAMPLES_PATH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to set the samples path' )
    CASE (ERRFLAG_UNABLE_INITIALIZE_ENCODER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to initialize encoder' )
    CASE (ERRFLAG_UNABLE_FREE_ENCODER)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free encoder' )
    CASE (ERRFLAG_LOADING_LOCAL_SAMPLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to load the local sample' )
    CASE (ERRFLAG_UNABLE_FREE_METADATA)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free metadata' )
    CASE (ERRFLAG_ENCODING_RULE_PRINT_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to print the encoding rule' )
    CASE (ERRFLAG_UNABLE_TO_LOAD_MSGPAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to load the message parameters' )
    CASE (ERRFLAG_METADATA_LIST_FREE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free the metadata list' )
    CASE (ERRFLAG_UNABLE_FREE_METADATA_LIST)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free the metadata list' )
    CASE (ERRFLAG_UNABLE_DEALLOCATE_METADATA)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to deallocate the metadata' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error message: ' // TRIM(ERRMSG) )
        DEALLOCATE( ERRMSG, STAT=DEALLOC_STATUS )
      END IF
    CASE (ERRFLAG_UNABLE_CHECK_LIST)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check the list' )
    CASE (ERRFLAG_ENCODER_ENCODE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to encode the message' )
    CASE (ERRFLAG_FREE_TEST_CASES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free the test cases' )
    CASE (ERRFLAG_LOAD_TEST_CASES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to load the test cases' )
    CASE (ERRFLAG_UNABLE_WRITE_LOG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to write the log' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( 6_JPIB_K )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  STOP 1

END PROGRAM TEST_READ21_PROG
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME