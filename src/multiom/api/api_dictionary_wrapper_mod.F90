! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"


#define PP_FILE_NAME 'api_dictionary_wrapper_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'API_DICTIONARY_WRAPPER_MOD'
MODULE API_DICTIONARY_WRAPPER_MOD

IMPLICIT NONE

!> Default visibility of the module
PRIVATE


! Whitelist of public symbols (dictionaries management)
PUBLIC :: MULTIO_GRIB2_INIT_OPTIONS
PUBLIC :: MULTIO_GRIB2_DICT_CREATE
PUBLIC :: MULTIO_GRIB2_DICT_DESTROY
PUBLIC :: MULTIO_GRIB2_DICT_SET
PUBLIC :: MULTIO_GRIB2_DICT_GET
PUBLIC :: MULTIO_GRIB2_DICT_HAS
PUBLIC :: MULTIO_GRIB2_DICT_ITERATE

CONTAINS


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_INIT_OPTIONS'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_INIT_OPTIONS( DICT ) &
 BIND(C,NAME='multio_grib2_init_options') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), INTENT(INOUT) :: DICT

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

  ! TODO: Add error handling code here

  RETURN

END FUNCTION MULTIO_GRIB2_INIT_OPTIONS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_CREATE'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_CREATE( MULTIO_GRIB2, DICT_TYPE, LEN ) &
 BIND(C,NAME='multio_grib2_dict_create_f') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LOC
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,       ONLY: JPIB_K
  USE :: HOOKS_MOD,               ONLY: HOOKS_T
  USE :: MAP_INT64_MARS_DICT_MOD, ONLY: MAP_FUNCTION_INT64_MARS_DICT_IF
  USE :: MAP_INT64_PAR_DICT_MOD,  ONLY: MAP_FUNCTION_INT64_PAR_DICT_IF
  USE :: API_SHARED_DATA_MOD,     ONLY: SHARED_MARS_DICT_MAP
  USE :: API_SHARED_DATA_MOD,     ONLY: SHARED_PAR_DICT_MAP
  USE :: API_SHARED_DATA_MOD,     ONLY: FREE_MARS_MESSAGE
  USE :: API_SHARED_DATA_MOD,     ONLY: FREE_PARAMETRIZATION
  USE :: FORTRAN_MESSAGE_MOD,     ONLY: FORTRAN_MESSAGE_T
  USE :: PARAMETRIZATION_MOD,     ONLY: PARAMETRIZATION_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR),                INTENT(INOUT) :: MULTIO_GRIB2
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: DICT_TYPE
  INTEGER(KIND=C_INT), VALUE, INTENT(IN)    :: LEN

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  LOGICAL :: INITIALIZED
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_MULTIO_GRIB2
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: SIZE
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: MAX_DICT_HANDLE
  TYPE(HOOKS_T) :: HOOKS
  CHARACTER(LEN=1,KIND=C_CHAR), DIMENSION(:), POINTER :: DICT_TYPE_C
  CHARACTER(LEN=32) :: DICT_TYPE_NAME

  TYPE(FORTRAN_MESSAGE_T), POINTER :: MESSAGE
  PROCEDURE(MAP_FUNCTION_INT64_MARS_DICT_IF), POINTER :: MESSAGE_DESTRUCTOR
  TYPE(PARAMETRIZATION_T), POINTER :: PARAMETRIZATION
  PROCEDURE(MAP_FUNCTION_INT64_PAR_DICT_IF), POINTER :: PARAMETRIZATION_DESTRUCTOR

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOC_FAILURE=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ADD_DICTIONARY=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_INIT_MAP=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SIZE=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_MAXIMUM=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_LENGTH=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_ALREADY_ASSOCIATED=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTYPE_NOT_ASSOCIATED=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TOCHECK_INITIALIZATION_STATUS=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNKNOWN_DICTIONARY_TYPE=11_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( C_ASSOCIATED(MULTIO_GRIB2),   ERRFLAG_DICTIONARY_ALREADY_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT_TYPE), ERRFLAG_DICTYPE_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( LEN .LE. 0, ERRFLAG_INVALID_LENGTH )

  !> Get the size of the dictionary type
  CALL C_F_POINTER( DICT_TYPE, DICT_TYPE_C, [LEN] )

  ! Copy the dictionary type to a fortran string
  DICT_TYPE_NAME = REPEAT(' ', 32)
  DO I = 1, LEN
    DICT_TYPE_NAME(I:I) = DICT_TYPE_C(I)
  END DO

  !TODO: Convert to lowercase

  SELECT CASE( TRIM(DICT_TYPE_NAME) )

  CASE ('mars', 'm', 'mars-dict', 'mars_dict')

    !> Get the dictionary handle from the c pointer
    ALLOCATE( F_MULTIO_GRIB2(2), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_UNABLE_TOCHECK_INITIALIZATION_STATUS) SHARED_MARS_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )

    !> Conditionally initialized the dictionarys map
!$omp single
    IF ( .NOT. INITIALIZED ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_INIT_MAP) SHARED_MARS_DICT_MAP%INIT( HOOKS )
    ENDIF
!$omp end single

!$omp critical(API_DICTIONARY_MAP_INSERT)
    !> Get the size of the dictionary map
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_MARS_DICT_MAP%SIZE( SIZE, HOOKS )

    IF ( SIZE .EQ. 0_JPIB_K ) THEN
      F_MULTIO_GRIB2(1) = 10_C_LONG_LONG
      F_MULTIO_GRIB2(2) = 1_C_LONG_LONG
    ELSE
      !> Check if the dictionary is already in the dictionarys map
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAXIMUM) SHARED_MARS_DICT_MAP%MAX( MAX_DICT_HANDLE, HOOKS )

      !> Increment the dictionary handle
      F_MULTIO_GRIB2(1) = 10_C_LONG_LONG
      F_MULTIO_GRIB2(2) = MAX_DICT_HANDLE(2) + 1_C_LONG_LONG
    ENDIF

    !> Allocate the mars dictionary
    ALLOCATE( MESSAGE, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    MESSAGE_DESTRUCTOR => FREE_MARS_MESSAGE
    PP_TRYCALL(ERRFLAG_UNABLE_TO_ADD_DICTIONARY) SHARED_MARS_DICT_MAP%INSERT( F_MULTIO_GRIB2, MESSAGE, MESSAGE_DESTRUCTOR, HOOKS )
!$omp end critical(API_DICTIONARY_MAP_INSERT)

    !> Get the location of the dictionary
    MULTIO_GRIB2 = C_LOC( F_MULTIO_GRIB2 )

  CASE ('parametrization', 'p', 'par', 'param', 'parametrization-dict', 'parametrization_dict', 'par-dict', 'par_dict', 'param-dict', 'param_dict')


    !> Get the dictionary handle from the c pointer
    ALLOCATE( F_MULTIO_GRIB2(2), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_UNABLE_TOCHECK_INITIALIZATION_STATUS) SHARED_PAR_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )

    !> Conditionally initialized the dictionarys map
!$omp single
    IF ( .NOT. INITIALIZED ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_INIT_MAP) SHARED_PAR_DICT_MAP%INIT( HOOKS )
    ENDIF
!$omp end single

!$omp critical(API_DICTIONARY_MAP_INSERT)
    !> Get the size of the dictionary map
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_PAR_DICT_MAP%SIZE( SIZE, HOOKS )

    IF ( SIZE .EQ. 0_JPIB_K ) THEN
      F_MULTIO_GRIB2(1) = 20_C_LONG_LONG
      F_MULTIO_GRIB2(2) = 1_C_LONG_LONG
    ELSE
      !> Check if the dictionary is already in the dictionarys map
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAXIMUM) SHARED_PAR_DICT_MAP%MAX( MAX_DICT_HANDLE, HOOKS )

      !> Increment the dictionary handle
      F_MULTIO_GRIB2(1) = 20_C_LONG_LONG
      F_MULTIO_GRIB2(2) = MAX_DICT_HANDLE(2) + 1_C_LONG_LONG
    ENDIF

    !> Allocate the mars dictionary
    ALLOCATE( PARAMETRIZATION, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOC_FAILURE )

    PARAMETRIZATION_DESTRUCTOR => FREE_PARAMETRIZATION
    PP_TRYCALL(ERRFLAG_UNABLE_TO_ADD_DICTIONARY) SHARED_PAR_DICT_MAP%INSERT( F_MULTIO_GRIB2, PARAMETRIZATION, PARAMETRIZATION_DESTRUCTOR, HOOKS )
!$omp end critical(API_DICTIONARY_MAP_INSERT)

    !> Get the location of the dictionary
    MULTIO_GRIB2 = C_LOC( F_MULTIO_GRIB2 )

  ! CASE ('options_dict')

  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNKNOWN_DICTIONARY_TYPE )
  END SELECT


  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_ALREADY_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary already associated' )
    CASE (ERRFLAG_DICTYPE_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary type not associated' )
    CASE (ERRFLAG_INVALID_LENGTH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Invalid length for "dic_type"' )
    CASE (ERRFLAG_ALLOC_FAILURE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Allocation failure' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG, STAT=ALLOC_STATUS)
      END IF
    CASE (ERRFLAG_UNABLE_TO_INIT_MAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to initialize the map' )
    CASE (ERRFLAG_UNABLE_TO_GET_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get the size of the map' )
    CASE (ERRFLAG_UNABLE_TO_GET_MAXIMUM)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get the maximum of the map' )
    CASE (ERRFLAG_UNABLE_TO_ADD_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to add the dictionary to the map' )
    CASE (ERRFLAG_UNABLE_TOCHECK_INITIALIZATION_STATUS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check the initialization status of the map' )
    CASE (ERRFLAG_UNKNOWN_DICTIONARY_TYPE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown dictionary type' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_CREATE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE






#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_DESTROY'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_DESTROY( MULTIO_GRIB2 ) &
 BIND(C,NAME='multio_grib2_dict_destroy') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: API_SHARED_DATA_MOD, ONLY: SHARED_MARS_DICT_MAP
  USE :: API_SHARED_DATA_MOD, ONLY: SHARED_PAR_DICT_MAP

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE, INTENT(IN) :: MULTIO_GRIB2

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  TYPE(C_PTR), POINTER, DIMENSION(:) :: TMP
  LOGICAL :: INITIALIZED
  LOGICAL :: MAP_HAS_DICTIONARY
  LOGICAL :: DICTIONARY_REMOVED
  INTEGER(KIND=JPIB_K) :: DEALLOC_STAT
  INTEGER(KIND=JPIB_K) :: MAP_SIZE
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_MULTIO_GRIB2
  TYPE(HOOKS_T) :: HOOKS

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAP_NOT_INITIALIZED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_DICTIONARY=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_REMOVE_DICTIONARY=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MAP_LIST=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_KEY_NOT_ASSOCIATED=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_FAILURE=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_FREE_MAP=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SIZE=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE=10_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(MULTIO_GRIB2), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  ! WRITE(*,*) 'MULTIO_GRIB2 0 '
  TMP => NULL()
  CALL C_F_POINTER( MULTIO_GRIB2, TMP, [1] )
  ! WRITE(*,*) 'MULTIO_GRIB2 1 '

  !> Get th fortran handle from the c handle
  F_MULTIO_GRIB2 => NULL()
  CALL C_F_POINTER( TMP(1), F_MULTIO_GRIB2, [2] )
  ! WRITE(*,*) 'F_MULTIO_GRIB2(1): ', F_MULTIO_GRIB2(1)

  !> Check the allocation status of the fortran handle
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_MULTIO_GRIB2), ERRFLAG_KEY_NOT_ASSOCIATED )

  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_MULTIO_GRIB2(1) )

  CASE ( 10_C_LONG_LONG )

!$omp critical(API_DICTIONARY_MAP_REMOVE)

    !> Print the mars dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_MARS_DICT_MAP%LIST( 6_JPIB_K, 'MARS_DICTIONARY_MAP: ', HOOKS )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_MAP_NOT_INITIALIZED) SHARED_MARS_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. INITIALIZED, ERRFLAG_MAP_NOT_INITIALIZED )

    !> Check if the handle is associated to an dictionary
    PP_TRYCALL(ERRFLAG_MATCH_DICTIONARY) SHARED_MARS_DICT_MAP%HAS( F_MULTIO_GRIB2, MAP_HAS_DICTIONARY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. MAP_HAS_DICTIONARY, ERRFLAG_MATCH_DICTIONARY )

    !> Remove the dictionary from the map
    PP_TRYCALL(ERRFLAG_REMOVE_DICTIONARY) SHARED_MARS_DICT_MAP%REMOVE( F_MULTIO_GRIB2, DICTIONARY_REMOVED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. DICTIONARY_REMOVED, ERRFLAG_REMOVE_DICTIONARY )

    !> Print the dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_ESHARED_MARS_DICT_MAPNCODER_MAP%LIST( 6_JPIB_K, 'MARS_DICTIONARY_MAP: ', HOOKS )

    !> Get the map size
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_MARS_DICT_MAP%SIZE( MAP_SIZE, HOOKS )

    !> To avoid the need of init/exit API, every time the map is empty we deallocate the map
    IF ( MAP_SIZE .EQ. 0_JPIB_K ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE_MAP) SHARED_MARS_DICT_MAP%FREE( HOOKS )
    ENDIF
!$omp end critical(API_DICTIONARY_MAP_REMOVE)

  CASE ( 20_C_LONG_LONG )


!$omp critical(API_DICTIONARY_MAP_REMOVE)

    !> Print the parametrization dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_PAR_DICT_MAP%LIST( 6_JPIB_K, 'PARAMETRIZATION_DICTIONARY_MAP: ', HOOKS )

    !> Check if the dictionary is already in the dictionarys map
    PP_TRYCALL(ERRFLAG_MAP_NOT_INITIALIZED) SHARED_PAR_DICT_MAP%INITIALIZED( INITIALIZED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. INITIALIZED, ERRFLAG_MAP_NOT_INITIALIZED )

    !> Check if the handle is associated to an dictionary
    PP_TRYCALL(ERRFLAG_MATCH_DICTIONARY) SHARED_PAR_DICT_MAP%HAS( F_MULTIO_GRIB2, MAP_HAS_DICTIONARY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. MAP_HAS_DICTIONARY, ERRFLAG_MATCH_DICTIONARY )

    !> Remove the dictionary from the map
    PP_TRYCALL(ERRFLAG_REMOVE_DICTIONARY) SHARED_PAR_DICT_MAP%REMOVE( F_MULTIO_GRIB2, DICTIONARY_REMOVED, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. DICTIONARY_REMOVED, ERRFLAG_REMOVE_DICTIONARY )

    !> Print the dictionary map
    !> NOTE: To be uncommented for debugging the API
    ! PP_TRYCALL(ERRFLAG_MAP_LIST) SHARED_PAR_DICT_MAP%LIST( 6_JPIB_K, 'PARAMETRIZATION_DICTIONARY_MAP: ', HOOKS )

    !> Get the map size
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SIZE) SHARED_PAR_DICT_MAP%SIZE( MAP_SIZE, HOOKS )

    !> To avoid the need of init/exit API, every time the map is empty we deallocate the map
    IF ( MAP_SIZE .EQ. 0_JPIB_K ) THEN
      PP_TRYCALL(ERRFLAG_UNABLE_TO_FREE_MAP) SHARED_PAR_DICT_MAP%FREE( HOOKS )
    ENDIF
!$omp end critical(API_DICTIONARY_MAP_REMOVE)

  CASE DEFAULT
    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )
  END SELECT

  ! Reset the input pointer
  TMP(1) = C_NULL_PTR

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_KEY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Key not associated' )
    CASE (ERRFLAG_MAP_NOT_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Map not initialized' )
    CASE (ERRFLAG_MATCH_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to match the dictionary' )
    CASE (ERRFLAG_REMOVE_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to remove the dictionary' )
    CASE (ERRFLAG_MAP_LIST)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to list the map' )
    CASE (ERRFLAG_DEALLOC_FAILURE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Key deallocation failure' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG, STAT=DEALLOC_STAT)
      ENDIF
    CASE (ERRFLAG_UNABLE_TO_FREE_MAP)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to free the map' )
    CASE (ERRFLAG_UNABLE_TO_GET_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get the size of the map' )
    CASE (ERRFLAG_WRONG_HANDLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong handle (handle is not from an dictionary)' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_DESTROY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_SET'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_SET( DICT, KEY, KLEN, VALUE, VLEN ) &
 BIND(C,NAME='multio_grib2_dict_set_f') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPRD_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_MARS_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_PAR_DICTIONARY
  USE :: FORTRAN_MESSAGE_MOD, ONLY: FORTRAN_MESSAGE_T
  USE :: PARAMETRIZATION_MOD, ONLY: PARAMETRIZATION_T
  USE :: GENERAL_UTILS_MOD,   ONLY: TOLOWER
  USE :: ENUMERATORS_MOD,     ONLY: CSTREAM2ISTREAM
  USE :: ENUMERATORS_MOD,     ONLY: CTYPE2ITYPE
  USE :: ENUMERATORS_MOD,     ONLY: CCLASS2ICLASS
  USE :: ENUMERATORS_MOD,     ONLY: CLEVTYPE2ILEVTYPE
  USE :: ENUMERATORS_MOD,     ONLY: CORIGIN2IORIGIN
  USE :: ENUMERATORS_MOD,     ONLY: CINT2IINT
  USE :: ENUMERATORS_MOD,     ONLY: CFLOAT2IFLOAT
  USE :: ENUMERATORS_MOD,     ONLY: CREPRES2IREPRES
  USE :: ENUMERATORS_MOD,     ONLY: CPACKING2IPACKING
  USE :: ENUMERATORS_MOD,     ONLY: CMODEL2IMODEL
  USE :: ENUMERATORS_MOD,     ONLY: CPARAMTYPE2IPARAMTYPE
  USE :: CONFIGURATION_UTILS_MOD,   ONLY: STRING_TO_REAL_ARRAY
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_NAME2ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_SET_VALUE_FROM_STRING
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_NAME2ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_SET_VALUE_FROM_STRING


  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR),         VALUE, INTENT(IN) :: DICT
  TYPE(C_PTR),         VALUE, INTENT(IN) :: KEY
  INTEGER(KIND=C_INT), VALUE, INTENT(IN) :: KLEN
  TYPE(C_PTR),         VALUE, INTENT(IN) :: VALUE
  INTEGER(KIND=C_INT), VALUE, INTENT(IN) :: VLEN

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: ITERATOR
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_DICT
  TYPE(FORTRAN_MESSAGE_T), POINTER :: MARS_DICT
  TYPE(PARAMETRIZATION_T), POINTER :: PAR_DICT
  CHARACTER(LEN=1,KIND=C_CHAR), DIMENSION(:), POINTER :: C_TMP_KEY
  CHARACTER(LEN=1,KIND=C_CHAR), DIMENSION(:), POINTER :: C_TMP_VAL
  CHARACTER(LEN=KLEN) :: F_KEY
  CHARACTER(LEN=KLEN) :: F_KEY_LOW
  CHARACTER(LEN=VLEN) :: F_VAL
  INTEGER(KIND=JPIB_K):: ITEMP
  REAL(KIND=JPRD_K), DIMENSION(:), ALLOCATABLE :: F_ARR
  REAL(KIND=JPRD_K) :: FTEMP
  TYPE(HOOKS_T) :: HOOKS
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_KEY_NOT_ASSOCIATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUE_NOT_ASSOCIATED=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_MARS_DICTIONARY=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_PAR_DICTIONARY=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_MARS_KEY=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONVERT_MARS_TO_ENUM=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_PARAMETRIZATION_KEY=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONVERT_PARAMETRIZATION_TO_ENUM=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOC_FAILURE=13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_FAILURE=14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_TO_MARS_ITERATOR=15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_SET_MARS=16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_TO_PAR_ITERATOR=17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_SET_PAR=18_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(KEY),  ERRFLAG_KEY_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(VALUE), ERRFLAG_VALUE_NOT_ASSOCIATED )

  !> Get the size of the dictionary type
  CALL C_F_POINTER( KEY,   C_TMP_KEY, [KLEN] )
  CALL C_F_POINTER( VALUE, C_TMP_VAL, [VLEN] )

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(C_TMP_KEY), ERRFLAG_KEY_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(C_TMP_VAL), ERRFLAG_VALUE_NOT_ASSOCIATED )

  ! Copy the key to a fortran string
  F_KEY = REPEAT(' ', KLEN)
  DO I = 1, KLEN
    F_KEY(I:I) = C_TMP_KEY(I)
  ENDDO
  C_TMP_KEY => NULL()

  ! Copy the key to a fortran string
  F_VAL = REPEAT(' ', VLEN)
  DO I = 1, VLEN
    F_VAL(I:I) = C_TMP_VAL(I)
  ENDDO
  C_TMP_VAL => NULL()


  !> Get th fortran handle from the c handle
  F_DICT => NULL()
  CALL C_F_POINTER( DICT, F_DICT, [2] )

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_DICT), ERRFLAG_KEY_NOT_ASSOCIATED )

  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_DICT(1) )

  CASE ( 10_C_LONG_LONG )

    !> Check the allocation status of the fortran handle
    PP_TRYCALL(ERRFLAG_EXTRACT_MARS_DICTIONARY) EXTRACT_MARS_DICTIONARY( F_DICT, MARS_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_MARS_ITERATOR) MARS_DICTIONARY_NAME2ITERATOR( MARS_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_MARS) MARS_DICTIONARY_SET_VALUE_FROM_STRING( MARS_DICT, ITERATOR, F_VAL, HOOKS )

  CASE ( 20_C_LONG_LONG )

    PP_TRYCALL(ERRFLAG_EXTRACT_PAR_DICTIONARY) EXTRACT_PAR_DICTIONARY( F_DICT, PAR_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_PAR_ITERATOR) PAR_DICTIONARY_NAME2ITERATOR( PAR_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_SET_PAR) PAR_DICTIONARY_SET_VALUE_FROM_STRING( PAR_DICT, ITERATOR, F_VAL, HOOKS )

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )

  END SELECT

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_KEY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Key not associated' )
    CASE (ERRFLAG_VALUE_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Value not associated' )
    CASE (ERRFLAG_WRONG_HANDLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong handle (handle is not from an dictionary)' )
    CASE (ERRFLAG_EXTRACT_MARS_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the mars dictionary' )
    CASE (ERRFLAG_EXTRACT_PAR_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the parametrization dictionary' )
    CASE (ERRFLAG_UNABLE_TO_CONVERT_LC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to transform key to lower case' )
    CASE (ERRFLAG_NO_MARS_KEY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Passed key is no mars key' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key: ' // TRIM(F_KEY) )
    CASE (ERRFLAG_CONVERT_MARS_TO_ENUM)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Can not covert value for mars key '// TRIM(F_KEY_LOW) // ' to enum' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'value: ' // TRIM(F_VAL) )
    CASE (ERRFLAG_NO_PARAMETRIZATION_KEY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Passed key is no parametrization key' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key: ' // TRIM(F_KEY) )
    CASE (ERRFLAG_CONVERT_PARAMETRIZATION_TO_ENUM)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Can not covert value for parametrization key '// TRIM(F_KEY_LOW) // ' to enum' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'value: ' // TRIM(F_VAL) )
    CASE (ERRFLAG_UNABLE_TO_SET_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to set parametrization key' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key: ' // TRIM(F_KEY) )
    CASE (ERRFLAG_ALLOC_FAILURE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Allocation failure' )
    CASE (ERRFLAG_DEALLOC_FAILURE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Deallocation failure' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_SET
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_GET'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_GET( DICT, KEY, KLEN, VALUE ) &
 BIND(C,NAME='multio_grib2_dict_get_f') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LOC
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPRD_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_MARS_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_PAR_DICTIONARY
  USE :: FORTRAN_MESSAGE_MOD, ONLY: FORTRAN_MESSAGE_T
  USE :: PARAMETRIZATION_MOD, ONLY: PARAMETRIZATION_T
  USE :: GENERAL_UTILS_MOD,   ONLY: TOLOWER
  USE :: API_GENERAL_UTILS_MOD,   ONLY: CONVERT_TO_C_STRING
  USE :: ENUMERATORS_MOD,     ONLY: ISTREAM2CSTREAM
  USE :: ENUMERATORS_MOD,     ONLY: ITYPE2CTYPE
  USE :: ENUMERATORS_MOD,     ONLY: ICLASS2CCLASS
  USE :: ENUMERATORS_MOD,     ONLY: ILEVTYPE2CLEVTYPE
  USE :: ENUMERATORS_MOD,     ONLY: IORIGIN2CORIGIN
  USE :: ENUMERATORS_MOD,     ONLY: IINT2CINT
  USE :: ENUMERATORS_MOD,     ONLY: IFLOAT2CFLOAT
  USE :: ENUMERATORS_MOD,     ONLY: IREPRES2CREPRES
  USE :: ENUMERATORS_MOD,     ONLY: IPACKING2CPACKING
  USE :: ENUMERATORS_MOD,     ONLY: IMODEL2CMODEL
  USE :: ENUMERATORS_MOD,     ONLY: IPARAMTYPE2CPARAMTYPE
  USE :: LOG_UTILS_MOD,       ONLY: TO_STRING
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_NAME2ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_GET_VALUE_AS_STRING
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_NAME2ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_GET_VALUE_AS_STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: DICT
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: KEY
  INTEGER(KIND=C_INT), VALUE, INTENT(IN)    :: KLEN
  TYPE(C_PTR),                INTENT(INOUT) :: VALUE

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  LOGICAL :: LHAS
  INTEGER(KIND=JPIB_K) :: ITERATOR
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_DICT
  TYPE(FORTRAN_MESSAGE_T), POINTER :: MARS_DICT
  TYPE(PARAMETRIZATION_T), POINTER :: PAR_DICT
  CHARACTER(LEN=1,KIND=C_CHAR), DIMENSION(:), POINTER :: C_TMP_KEY
  CHARACTER(LEN=KLEN) :: F_KEY
  CHARACTER(LEN=KLEN) :: F_KEY_LOW
  CHARACTER(LEN=64) :: F_VAL
  CHARACTER(LEN=:), ALLOCATABLE :: F_VAL_ALLOC
  INTEGER(KIND=JPIB_K):: ITEMP
  REAL(KIND=JPRD_K) :: FTEMP
  TYPE(HOOKS_T) :: HOOKS
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS


  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_KEY_NOT_ASSOCIATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_MARS_DICTIONARY=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_PAR_DICTIONARY=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_LC=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONVERT_ENUM_STRING=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_MARS_KEY=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_PARAMETRIZATION_KEY=10_JPIB_K

  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONVERT_TO_C_STRING=13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_STR=14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_TO_MARS_ITERATOR=15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_MARS=16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_TO_PAR_ITERATOR=17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_PAR=18_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(KEY),  ERRFLAG_KEY_NOT_ASSOCIATED )

  !> Get the size of the dictionary type
  CALL C_F_POINTER( KEY,   C_TMP_KEY, [KLEN] )

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(C_TMP_KEY), ERRFLAG_KEY_NOT_ASSOCIATED )

  ! Copy the key to a fortran string
  F_KEY = REPEAT(' ', KLEN)
  DO I = 1, KLEN
    F_KEY(I:I) = C_TMP_KEY(I)
  ENDDO
  C_TMP_KEY => NULL()

  !> Get th fortran handle from the c handle
  F_DICT => NULL()
  CALL C_F_POINTER( DICT, F_DICT, [2] )

  !> Check the allocation status of the fortran handle
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_DICT), ERRFLAG_KEY_NOT_ASSOCIATED )

  F_VAL=REPEAT(' ', LEN(F_VAL))

  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_DICT(1) )

  CASE ( 10_C_LONG_LONG )

    PP_TRYCALL(ERRFLAG_EXTRACT_MARS_DICTIONARY) EXTRACT_MARS_DICTIONARY( F_DICT, MARS_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_MARS_ITERATOR) MARS_DICTIONARY_NAME2ITERATOR( MARS_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MARS) MARS_DICTIONARY_GET_VALUE_AS_STRING( MARS_DICT, ITERATOR, F_VAL, LHAS, HOOKS )
    PP_TRYCALL(ERRFLAG_CONVERT_TO_C_STRING) CONVERT_TO_C_STRING(F_VAL, VALUE, HOOKS)

  CASE ( 20_C_LONG_LONG )

    PP_TRYCALL(ERRFLAG_EXTRACT_PAR_DICTIONARY) EXTRACT_PAR_DICTIONARY( F_DICT, PAR_DICT, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_PAR_ITERATOR) PAR_DICTIONARY_NAME2ITERATOR( PAR_DICT, F_KEY, ITERATOR, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR) PAR_DICTIONARY_GET_VALUE_AS_STRING( PAR_DICT, ITERATOR, VALUE, LHAS, HOOKS )

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )

  END SELECT



  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_KEY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Key not associated' )
    CASE (ERRFLAG_WRONG_HANDLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong handle (handle is not from an dictionary)' )
    CASE (ERRFLAG_EXTRACT_MARS_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the mars dictionary' )
    CASE (ERRFLAG_EXTRACT_PAR_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the parametrization dictionary' )
    CASE (ERRFLAG_CONVERT_ENUM_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert value to string' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key: ' // F_KEY )
    CASE (ERRFLAG_NO_MARS_KEY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Passed key is no valid MARS key' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key: ' // F_KEY )
    CASE (ERRFLAG_NO_PARAMETRIZATION_KEY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Passed key is no valid parametrization key' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key: ' // F_KEY )
    CASE (ERRFLAG_UNABLE_TO_GET_PAR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Error extracting parametrization key' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key: ' // F_KEY )
    CASE (ERRFLAG_CONVERT_TO_C_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Can not copy to cstring' )
    CASE (ERRFLAG_DEALLOC_STR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Can not deallocate string' )
    CASE (ERRFLAG_UNABLE_TO_CONVERT_TO_MARS_ITERATOR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Can not convert key to mars iterator' )
    CASE (ERRFLAG_UNABLE_TO_GET_MARS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Can not get value from mars dictionary' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_GET
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_HAS'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_HAS( DICT, KEY, KLEN, HAS ) &
 BIND(C,NAME='multio_grib2_dict_has_f') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,   ONLY: JPIB_K
  USE :: HOOKS_MOD,           ONLY: HOOKS_T
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_MARS_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_PAR_DICTIONARY
  USE :: FORTRAN_MESSAGE_MOD, ONLY: FORTRAN_MESSAGE_T
  USE :: PARAMETRIZATION_MOD, ONLY: PARAMETRIZATION_T
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_NAME2ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_HAS
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_NAME2ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_HAS

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: DICT
  TYPE(C_PTR), VALUE,         INTENT(IN)    :: KEY
  INTEGER(KIND=C_INT), VALUE, INTENT(IN)    :: KLEN
  INTEGER(KIND=C_INT),        INTENT(INOUT) :: HAS

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  LOGICAL :: LHAS
  INTEGER(KIND=JPIB_K) :: ITERATOR
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_DICT
  TYPE(FORTRAN_MESSAGE_T), POINTER :: MARS_DICT
  TYPE(PARAMETRIZATION_T), POINTER :: PAR_DICT
  CHARACTER(LEN=1,KIND=C_CHAR), DIMENSION(:), POINTER :: C_TMP_KEY
  CHARACTER(LEN=KLEN) :: F_KEY
  TYPE(HOOKS_T) :: HOOKS

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_KEY_NOT_ASSOCIATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_MARS_DICTIONARY=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_PAR_DICTIONARY=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CHECK_STATUS=8_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(KEY),  ERRFLAG_KEY_NOT_ASSOCIATED )

  !> Get the size of the dictionary type
  CALL C_F_POINTER( KEY, C_TMP_KEY, [KLEN] )

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(C_TMP_KEY), ERRFLAG_KEY_NOT_ASSOCIATED )

  ! Copy the key to a fortran string
  F_KEY = REPEAT(' ', KLEN)
  DO I = 1, KLEN
    F_KEY(I:I) = C_TMP_KEY(I)
  ENDDO
  C_TMP_KEY => NULL()

  !> Get th fortran handle from the c handle
  F_DICT => NULL()
  CALL C_F_POINTER( DICT, F_DICT, [2] )

  !> Check the allocation status of the fortran handle
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_DICT), ERRFLAG_KEY_NOT_ASSOCIATED )

  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_DICT(1) )

  CASE ( 10_C_LONG_LONG )

    PP_TRYCALL(ERRFLAG_EXTRACT_MARS_DICTIONARY) EXTRACT_MARS_DICTIONARY( F_DICT, MARS_DICT, HOOKS )

    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) MARS_DICTIONARY_NAME2ITERATOR( MARS_DICT, F_KEY, ITERATOR, HOOKS )

    PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_STATUS) MARS_DICTIONARY_HAS( MARS_DICT, ITERATOR, LHAS, HOOKS )

    IF ( LHAS ) THEN
      HAS = 1_C_INT
    ELSE
      HAS = 0_C_INT
    END IF

  CASE ( 20_C_LONG_LONG )

    PP_TRYCALL(ERRFLAG_EXTRACT_PAR_DICTIONARY) EXTRACT_PAR_DICTIONARY( F_DICT, PAR_DICT, HOOKS )

    PP_TRYCALL(ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR) PAR_DICTIONARY_NAME2ITERATOR( PAR_DICT, F_KEY, ITERATOR, HOOKS )

    PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_STATUS) PAR_DICTIONARY_HAS( PAR_DICT, ITERATOR, LHAS, HOOKS )

    IF ( LHAS ) THEN
      HAS = 1_C_INT
    ELSE
      HAS = 0_C_INT
    END IF

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )

  END SELECT

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_KEY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Key not associated' )
    CASE (ERRFLAG_WRONG_HANDLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong handle (handle is not from an dictionary)' )
    CASE (ERRFLAG_EXTRACT_MARS_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the mars dictionary' )
    CASE (ERRFLAG_EXTRACT_PAR_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the parametrization dictionary' )
    CASE (ERRFLAG_UNABLE_TO_CONVERT_TO_ITERATOR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to convert key to iterator' )
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key: ' // F_KEY )
    CASE (ERRFLAG_UNABLE_TO_CHECK_STATUS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to check status' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_HAS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_ITERATE'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_ITERATE( DICT, IT, KEY, VALUE ) &
 BIND(C,NAME='multio_grib2_dict_iterate') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LOC
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_LONG_LONG
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_MARS_DICTIONARY
  USE :: API_SHARED_DATA_MOD, ONLY: EXTRACT_PAR_DICTIONARY
  USE :: FORTRAN_MESSAGE_MOD, ONLY: FORTRAN_MESSAGE_T
  USE :: PARAMETRIZATION_MOD, ONLY: PARAMETRIZATION_T
  USE :: GENERAL_UTILS_MOD,   ONLY: TOLOWER
  USE :: API_GENERAL_UTILS_MOD,   ONLY: CONVERT_TO_C_STRING
  USE :: API_GENERAL_UTILS_MOD,   ONLY: ALLOCATE_ITERATOR
  USE :: API_GENERAL_UTILS_MOD,   ONLY: DEALLOCATE_ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_MAX_ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_INIT_ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_GET_NEXT_ITERATOR
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_GET_KEY_AS_STRING
  USE :: API_MARS_DICTIONARY_UTILS_MOD, ONLY: MARS_DICTIONARY_GET_VALUE_AS_STRING
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_MAX_ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_INIT_ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_GET_NEXT_ITERATOR
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_GET_KEY_AS_STRING
  USE :: API_PAR_DICTIONARY_UTILS_MOD, ONLY: PAR_DICTIONARY_GET_VALUE_AS_STRING


  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE, INTENT(IN)    :: DICT
  TYPE(C_PTR),        INTENT(INOUT) :: IT
  TYPE(C_PTR),        INTENT(INOUT) :: KEY
  TYPE(C_PTR),        INTENT(INOUT) :: VALUE

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  INTEGER(KIND=C_LONG_LONG), POINTER, DIMENSION(:) :: F_DICT
  TYPE(FORTRAN_MESSAGE_T), POINTER :: MARS_DICT
  TYPE(PARAMETRIZATION_T), POINTER :: PAR_DICT
  INTEGER(KIND=C_INT), POINTER, DIMENSION(:) :: F_ITERATOR
  INTEGER(KIND=JPIB_K) :: MARS_ITERATOR_SIZE
  INTEGER(KIND=JPIB_K) :: PAR_ITERATOR_SIZE
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: ITERATOR
  CHARACTER(LEN=64) :: F_KEY
  CHARACTER(LEN=64) :: F_VAL
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  LOGICAL :: END_OF_ITERATORS
  LOGICAL :: HAS
  TYPE(HOOKS_T) :: HOOKS

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DICTIONARY_NOT_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOC_FAILURE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_HANDLE=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_MARS_DICTIONARY=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_EXTRACT_PAR_DICTIONARY=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_NEXT_IT=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_MARS_KEY=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_MARS_VAL=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONVERT_TO_C_STRING=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_STR=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_MAX_ITERATOR=12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INITIALIZE_ITERATOR=13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_MARS=14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_PAR=16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_PAR_KEY=17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_PAR_VAL=18_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! WRITE(*,*) ' + ENTER ITERATE'

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.C_ASSOCIATED(DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  !> Handle the case of null iterator passed
  ! IF ( .NOT.C_ASSOCIATED(IT) ) THEN
  !   F_ITERATOR => NULL()
  !   PP_TRYCALL(ERRFLAG_ALLOC_FAILURE) ALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
  !   F_ITERATOR(1) = 0_C_INT
  !   IT = C_LOC(F_ITERATOR)
  ! ELSE
  !   CALL C_F_POINTER( IT, F_ITERATOR, [1] )
  ! ENDIF

  !> Get th fortran handle from the c handle
  F_DICT => NULL()
  CALL C_F_POINTER( DICT, F_DICT, [2] )

  !> Check the allocation status of the fortran handle
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(F_DICT), ERRFLAG_DICTIONARY_NOT_ASSOCIATED )

  F_KEY=REPEAT(' ', LEN(F_KEY))
  F_VAL=REPEAT(' ', LEN(F_VAL))


  !> Depending on the dictionary type we have to deallocate the dictionary
  SELECT CASE ( F_DICT(1) )

  CASE ( 10_C_LONG_LONG )

    PP_TRYCALL(ERRFLAG_EXTRACT_MARS_DICTIONARY) EXTRACT_MARS_DICTIONARY( F_DICT, MARS_DICT, HOOKS )

    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAX_ITERATOR) MARS_DICTIONARY_MAX_ITERATOR( MARS_DICT, MARS_ITERATOR_SIZE, HOOKS )
    IF ( .NOT.C_ASSOCIATED(IT) ) THEN
      F_ITERATOR => NULL()
      PP_TRYCALL(ERRFLAG_ALLOC_FAILURE) ALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      ITERATOR = F_ITERATOR(1)
      PP_TRYCALL(ERRFLAG_INITIALIZE_ITERATOR) MARS_DICTIONARY_INIT_ITERATOR( MARS_DICT, ITERATOR, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
      IT = C_LOC(F_ITERATOR)
      END_OF_ITERATORS = .FALSE.
      ! WRITE(*,*) 'ALLOCATE F-ITERATOR: ', F_ITERATOR
    ELSE
      CALL C_F_POINTER( IT, F_ITERATOR, [1] )
      ITERATOR = INT( F_ITERATOR(1), KIND=C_INT )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_NEXT_IT) MARS_DICTIONARY_GET_NEXT_ITERATOR( MARS_DICT, ITERATOR, END_OF_ITERATORS, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
      ! WRITE(*,*) 'ACCESS F-ITERATOR: ', F_ITERATOR
    ENDIF


    ! If the iterator is out of bounds, the deallocate it
    IF ( END_OF_ITERATORS ) THEN
      ! WRITE(*,*) 'FREE KV F-ITERATOR: ', F_ITERATOR
      F_ITERATOR(1) = 0_C_INT
      PP_TRYCALL(ERRFLAG_DEALLOC_STR) DEALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      IT    = C_NULL_PTR
      KEY   = C_NULL_PTR
      VALUE = C_NULL_PTR

    ELSE

      ! WRITE(*,*) 'GET KV F-ITERATOR: ', F_ITERATOR
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MARS_KEY) MARS_DICTIONARY_GET_KEY_AS_STRING( MARS_DICT, ITERATOR, F_KEY, HOOKS )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MARS_VAL) MARS_DICTIONARY_GET_VALUE_AS_STRING( MARS_DICT, ITERATOR, F_VAL, HAS, HOOKS )
      ! WRITE(*,*) 'HAS: ', HAS
      PP_TRYCALL(ERRFLAG_CONVERT_TO_C_STRING) CONVERT_TO_C_STRING( F_KEY, KEY, HOOKS )
      PP_TRYCALL(ERRFLAG_CONVERT_TO_C_STRING) CONVERT_TO_C_STRING( F_VAL, VALUE, HOOKS )

    ENDIF

  CASE ( 20_C_LONG_LONG )

    PP_TRYCALL(ERRFLAG_EXTRACT_PAR_DICTIONARY) EXTRACT_PAR_DICTIONARY( F_DICT, PAR_DICT, HOOKS )

    PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_MAX_ITERATOR) PAR_DICTIONARY_MAX_ITERATOR( PAR_DICT, PAR_ITERATOR_SIZE, HOOKS )
    IF ( .NOT.C_ASSOCIATED(IT) ) THEN
      F_ITERATOR => NULL()
      PP_TRYCALL(ERRFLAG_ALLOC_FAILURE) ALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      ITERATOR = F_ITERATOR(1)
      PP_TRYCALL(ERRFLAG_INITIALIZE_ITERATOR) PAR_DICTIONARY_INIT_ITERATOR( PAR_DICT, ITERATOR, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
      IT = C_LOC(F_ITERATOR)
      END_OF_ITERATORS = .FALSE.
      ! WRITE(*,*) 'ALLOCATE F-ITERATOR: ', F_ITERATOR
    ELSE
      CALL C_F_POINTER( IT, F_ITERATOR, [1] )
      ITERATOR = INT( F_ITERATOR(1), KIND=C_INT )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_NEXT_IT) PAR_DICTIONARY_GET_NEXT_ITERATOR( PAR_DICT, ITERATOR, END_OF_ITERATORS, HOOKS )
      F_ITERATOR(1) = INT(ITERATOR,KIND=C_INT)
      ! WRITE(*,*) 'ACCESS F-ITERATOR: ', F_ITERATOR
    ENDIF


    ! If the iterator is out of bounds, the deallocate it
    IF ( END_OF_ITERATORS ) THEN
      ! WRITE(*,*) 'FREE KV F-ITERATOR: ', F_ITERATOR
      F_ITERATOR(1) = 0_C_INT
      PP_TRYCALL(ERRFLAG_DEALLOC_STR) DEALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
      IT    = C_NULL_PTR
      KEY   = C_NULL_PTR
      VALUE = C_NULL_PTR

    ELSE

      ! WRITE(*,*) 'GET KV F-ITERATOR: ', F_ITERATOR
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR_KEY) PAR_DICTIONARY_GET_KEY_AS_STRING( PAR_DICT, ITERATOR, F_KEY, HOOKS )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_PAR_VAL) PAR_DICTIONARY_GET_VALUE_AS_STRING( PAR_DICT, ITERATOR, VALUE, HAS, HOOKS )
      ! WRITE(*,*) 'HAS: ', HAS
      PP_TRYCALL(ERRFLAG_CONVERT_TO_C_STRING) CONVERT_TO_C_STRING( F_KEY, KEY, HOOKS )

    ENDIF

  CASE DEFAULT

    PP_DEBUG_CRITICAL_THROW( ERRFLAG_WRONG_HANDLE )

  END SELECT

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DICTIONARY_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Dictionary not associated' )
    CASE (ERRFLAG_WRONG_HANDLE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Wrong handle (handle is not from an dictionary)' )
    CASE (ERRFLAG_EXTRACT_MARS_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the mars dictionary' )
    CASE (ERRFLAG_EXTRACT_PAR_DICTIONARY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to extract the parametrization dictionary' )
    CASE (ERRFLAG_UNABLE_TO_GET_NEXT_IT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get next iterator' )
    CASE (ERRFLAG_UNABLE_TO_GET_MARS_KEY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get mars key' )
    CASE (ERRFLAG_UNABLE_TO_GET_MARS_VAL)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to get mars value' )
    CASE (ERRFLAG_CONVERT_TO_C_STRING)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Can not copy to cstring' )
    CASE (ERRFLAG_DEALLOC_STR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Can not deallocate string' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_ITERATE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'MULTIO_GRIB2_DICT_DESTROY_ITERATEOR'
PP_THREAD_SAFE FUNCTION MULTIO_GRIB2_DICT_DESTROY_ITERATEOR( DICT, IT ) &
 BIND(C,NAME='multio_grib2_dict_destroy_iterator') RESULT(RET)

  !> Symbols imported from intrinsic modules.
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_PTR
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_ASSOCIATED
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_F_POINTER
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: ERROR_UNIT

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,     ONLY: JPIB_K
  USE :: HOOKS_MOD,             ONLY: HOOKS_T
  USE :: API_GENERAL_UTILS_MOD, ONLY: DEALLOCATE_ITERATOR


  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  TYPE(C_PTR), VALUE, INTENT(IN)    :: DICT
  TYPE(C_PTR),        INTENT(INOUT) :: IT

  !> Function result
  INTEGER(KIND=C_INT) :: RET

  !> Local variables
  INTEGER(KIND=C_INT), POINTER, DIMENSION(:) :: F_ITERATOR
  TYPE(HOOKS_T) :: HOOKS

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_ITERATOR=1_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization of the hooks
  CALL HOOKS%DEBUG_HOOK_%INIT( )

  ! If needed free memory for the iterator
  IF ( C_ASSOCIATED(IT) ) THEN
    CALL C_F_POINTER( IT, F_ITERATOR, [1] )
    PP_TRYCALL(ERRFLAG_DEALLOC_ITERATOR) DEALLOCATE_ITERATOR( F_ITERATOR, HOOKS )
    IT = C_NULL_PTR
  ENDIF

  !> Be sure we don't have any memory leaks
  CALL HOOKS%DEBUG_HOOK_%FREE( )


  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DEALLOC_ITERATOR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unable to deallocate dictionary iterator' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'Unknown error' )
    END SELECT

    ! Print the error stack
    ! NOTE: This is important when c is calling this function. Is opens the error_unit
    WRITE(ERROR_UNIT,*) ' PRINT ERROR STACK FROM: "'//__FILE__//'":', __LINE__
    CALL HOOKS%DEBUG_HOOK_%PRINT_ERROR_STACK( ERROR_UNIT )

    ! Free the error stack
    CALL HOOKS%DEBUG_HOOK_%FREE( )

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  RETURN

END FUNCTION MULTIO_GRIB2_DICT_DESTROY_ITERATEOR
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



END MODULE API_DICTIONARY_WRAPPER_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME
