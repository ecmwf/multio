! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"


#define PP_FILE_NAME 'encoding_rules_tree_loader_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'ENCODING_RULES_TREE_LOADER_MOD'
MODULE ENCODING_RULES_TREE_LOADER_MOD

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: ENCODING_RULES_LINEAR_LOADER_MOD, ONLY: ENCODING_RULES_LINEAR_LOADER_T
  USE :: FILTER_BASE_MOD, ONLY: FILTER_BASE_A

IMPLICIT NONE

! Default visibility
PRIVATE

!> Filter container used to store generic filter objects
TYPE :: FILTER_CONTAINER_T
  CLASS(FILTER_BASE_A), POINTER :: FILTER => NULL()
END TYPE

! Class that contains all the encoding rules organized in a tree structure
TYPE :: ENCODING_RULES_TREE_LOADER_T

  ! Default visibility
  PRIVATE

  ! Initialization status
  LOGICAL :: INITIALIZED = .FALSE.

  ! Size of the rules loader
  INTEGER(KIND=JPIB_K) :: SIZE_ = 0_JPIB_K

  ! Children nodes
  TYPE(ENCODING_RULES_TREE_LOADER_NODE_T), POINTER :: HEAD => NULL()

 CONTAINS

  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: INIT  => ENCODING_RULES_TREE_LOADER_INIT
  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: COUNT_MATCHES  => ENCODING_RULES_TREE_LOADER_COUNT_MATCHES
  PROCEDURE, PRIVATE, NON_OVERRIDABLE, PASS :: MATCH_SINGLE => ENCODING_RULES_TREE_LOADER_MATCH_SINGLE
  PROCEDURE, PRIVATE, NON_OVERRIDABLE, PASS :: MATCH_MULTIPLE => ENCODING_RULES_TREE_LOADER_MATCH_MULTIPLE
  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: FREE  => ENCODING_RULES_TREE_LOADER_FREE
  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: SIZE  => ENCODING_RULES_TREE_LOADER_SIZE
  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: PRINT  => ENCODING_RULES_TREE_LOADER_PRINT
  GENERIC, PUBLIC :: MATCH => MATCH_SINGLE, MATCH_MULTIPLE

END TYPE


! Node in the tree structure of encoding rules
TYPE :: ENCODING_RULES_TREE_LOADER_NODE_T

  ! Default visibility
  PRIVATE

  ! Filter options
  INTEGER(KIND=JPIB_K) :: LEVEL = 0_JPIB_K
  CHARACTER(LEN=32) :: KEY = REPEAT(' ',32)
  INTEGER(KIND=JPIB_K) :: IKEY = 0_JPIB_K

  ! Operation and selector (array 2xN, first line operation ID [has/lacks/match/ignore], second line selector [value if needed])
  INTEGER(KIND=JPIB_K), POINTER, DIMENSION(:,:) :: CONDITION

  ! Encoding rule contains (payload)
  TYPE(ENCODING_RULES_LINEAR_LOADER_T), POINTER :: RULES_COLLECTION => NULL()

  ! Children nodes
  TYPE(FILTER_CONTAINER_T), DIMENSION(:), POINTER :: FILTERS => NULL()
  TYPE(ENCODING_RULES_TREE_LOADER_NODE_T), DIMENSION(:), POINTER :: CHILDREN => NULL()

CONTAINS

  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: INIT_CFG  => ENCODING_RULES_TREE_LOADER_NODE_INIT_CFG
  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: INIT_RULES => ENCODING_RULES_TREE_LOADER_NODE_INIT_RULES
  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: COUNT_MATCHES  => ENCODING_RULES_TREE_LOADER_NODE_COUNT_MATCHES

  PROCEDURE, PRIVATE, NON_OVERRIDABLE, PASS :: MATCH_SINGLE => ENCODING_RULES_TREE_LOADER_NODE_MATCH_SINGLE
  PROCEDURE, PRIVATE, NON_OVERRIDABLE, PASS :: MATCH_MULTIPLE => ENCODING_RULES_TREE_LOADER_NODE_MATCH_MULTIPLE
  GENERIC, PUBLIC :: MATCH => MATCH_SINGLE, MATCH_MULTIPLE

  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: FREE  => ENCODING_RULES_TREE_LOADER_NODE_FREE
  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: PRINT  => ENCODING_RULES_TREE_LOADER_NODE_PRINT
  PROCEDURE, PUBLIC, NON_OVERRIDABLE, PASS :: SIZE  => ENCODING_RULES_TREE_LOADER_NODE_SIZE

  PROCEDURE, PRIVATE, NON_OVERRIDABLE, PASS :: READ_OPERATION => ENCODING_RULES_TREE_LOADER_NODE_READ_OPERATION

END TYPE

! Whitelist of public symbols
PUBLIC :: ENCODING_RULES_TREE_LOADER_T

CONTAINS

#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_INIT'
PP_THREAD_SAFE FUNCTION ENCODING_RULES_TREE_LOADER_INIT( THIS, CFG, FILTER_OPT, ENCODER_OPT, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T
  USE :: FILTER_OPTIONS_MOD,       ONLY: FILTER_OPTIONS_T

  ! Symbols imported from other libraries
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATION

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_T), INTENT(INOUT) :: THIS
  TYPE(YAML_CONFIGURATION_T),          INTENT(IN)    :: CFG
  TYPE(FILTER_OPTIONS_T),              INTENT(IN)    :: FILTER_OPT
  TYPE(GRIB_ENCODER_OPTIONS_T),        INTENT(IN)    :: ENCODER_OPT
  TYPE(HOOKS_T),                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  TYPE(YAML_CONFIGURATION_T) :: ENCODING_RULES_CONFIGURATION
  LOGICAL :: HAS_NESTED_RULES
  LOGICAL :: HAS_ENCODING_RULES
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: LEVEL
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  CHARACTER(LEN=32) :: CTMP

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULES_ALREADY_INITIALIZED=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULES_ALREADY_ASSOCIATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_ENCODING_RULES=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_TWO_ENCODING_RULES=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_SUBCFG=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DELETE_CONFIGURATIONS=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCHES_ALLOCATION_ERROR=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULES_INITIALIZE=8_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( THIS%INITIALIZED, ERRFLAG_RULES_ALREADY_INITIALIZED )
  PP_DEBUG_CRITICAL_COND_THROW( ASSOCIATED(THIS%HEAD), ERRFLAG_RULES_ALREADY_ASSOCIATED )

  !> Read the encoder configuration
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CFG, 'nested-rules', HAS_NESTED_RULES, HOOKS )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CFG, 'encoding-rules', HAS_ENCODING_RULES, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( (.NOT.HAS_NESTED_RULES.AND..NOT.HAS_ENCODING_RULES), ERRFLAG_NO_ENCODING_RULES )
  PP_DEBUG_CRITICAL_COND_THROW( (HAS_NESTED_RULES.AND.HAS_ENCODING_RULES), ERRFLAG_TWO_ENCODING_RULES )

  !> Allocate nested rules
  ALLOCATE( THIS%HEAD, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_MATCHES_ALLOCATION_ERROR )

  !> Initialization of the nested rules
  LEVEL = 0_JPIB_K

  ! Construct the rules tree
  IF ( HAS_NESTED_RULES ) THEN
    PP_TRYCALL(ERRFLAG_RULES_INITIALIZE) THIS%HEAD%INIT_CFG( CFG, FILTER_OPT, ENCODER_OPT, THIS%SIZE_, LEVEL, HOOKS )
  ELSEIF ( HAS_ENCODING_RULES ) THEN
    PP_TRYCALL(ERRFLAG_RULES_INITIALIZE) THIS%HEAD%INIT_RULES( CFG, FILTER_OPT, ENCODER_OPT, THIS%SIZE_, LEVEL, HOOKS )
  ENDIF

  ! Debugging
  CTMP=REPEAT(' ',LEN(CTMP))
  WRITE(CTMP,*) THIS%SIZE_
  PP_LOG_DEVELOP_STR(  'Rules tree size: '//TRIM(ADJUSTL(CTMP)) )

  ! Set the initialization flag
  THIS%INITIALIZED = .TRUE.

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_RULES_ALREADY_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'rules already initialized' )
    CASE(ERRFLAG_RULES_ALREADY_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'rules already associated' )
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read configuration' )
    CASE(ERRFLAG_NO_ENCODING_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'no encoding rules found' )
    CASE(ERRFLAG_UNABLE_TO_READ_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read subconfigurations' )
    CASE(ERRFLAG_DELETE_CONFIGURATIONS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to delete configurations' )
    CASE(ERRFLAG_MATCHES_ALLOCATION_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'allocation error' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=ALLOC_STATUS)
      ENDIF
    CASE(ERRFLAG_RULES_INITIALIZE)
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to initialize rules' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_INIT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_COUNT_MATCHES'
PP_THREAD_SAFE FUNCTION ENCODING_RULES_TREE_LOADER_COUNT_MATCHES( THIS, MSG, PAR, NUM_MATCHES, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: PARAMETRIZATION_MOD,      ONLY: PARAMETRIZATION_T
  USE :: FORTRAN_MESSAGE_MOD,      ONLY: FORTRAN_MESSAGE_T
  USE :: CACHED_ENCODER_MOD,       ONLY: CACHED_ENCODER_T
  USE :: METADATA_BASE_MOD,        ONLY: METADATA_BASE_A
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_T), INTENT(IN)    :: THIS
  TYPE(PARAMETRIZATION_T),             INTENT(IN)    :: PAR
  TYPE(FORTRAN_MESSAGE_T),             INTENT(IN)    :: MSG
  INTEGER(KIND=JPIB_K),                INTENT(OUT)   :: NUM_MATCHES
  TYPE(HOOKS_T),                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULES_NOT_INITIALIZED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCHES_NOT_ASSOCIATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_RULES=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.THIS%INITIALIZED, ERRFLAG_RULES_NOT_INITIALIZED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(THIS%HEAD), ERRFLAG_MATCHES_NOT_ASSOCIATED )

  !> Match the rules
  PP_TRYCALL(ERRFLAG_MATCH_RULES) THIS%HEAD%COUNT_MATCHES( MSG, PAR, NUM_MATCHES, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_RULES_NOT_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'rules not initialized' )
    CASE(ERRFLAG_MATCHES_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'matches not associated' )
    CASE(ERRFLAG_MATCH_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to match rules' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_COUNT_MATCHES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_SIZE'
PP_THREAD_SAFE FUNCTION ENCODING_RULES_TREE_LOADER_SIZE( THIS, SZ, MAX_SZ, NLEVELS, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),                INTENT(OUT)   :: SZ
  INTEGER(KIND=JPIB_K),                INTENT(OUT)   :: MAX_SZ
  INTEGER(KIND=JPIB_K),                INTENT(OUT)   :: NLEVELS
  TYPE(HOOKS_T),                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULES_NOT_INITIALIZED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCHES_NOT_ASSOCIATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_RULES=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.THIS%INITIALIZED, ERRFLAG_RULES_NOT_INITIALIZED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(THIS%HEAD), ERRFLAG_MATCHES_NOT_ASSOCIATED )

  !> Match the rules
  SZ = 0_JPIB_K
  MAX_SZ = 0_JPIB_K
  NLEVELS = 0_JPIB_K
  PP_TRYCALL(ERRFLAG_MATCH_RULES) THIS%HEAD%SIZE( SZ, MAX_SZ, NLEVELS, HOOKS )

  ! MIVAL - TODO: To be removed
  ! WRITE(*,*) 'SIZE: ', THIS%SIZE_

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_RULES_NOT_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'rules not initialized' )
    CASE(ERRFLAG_MATCHES_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'matches not associated' )
    CASE(ERRFLAG_MATCH_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to match rules' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_SIZE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_MATCH_SINGLE'
PP_THREAD_SAFE FUNCTION ENCODING_RULES_TREE_LOADER_MATCH_SINGLE( THIS, MSG, PAR, RULE, OPT, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: PARAMETRIZATION_MOD,      ONLY: PARAMETRIZATION_T
  USE :: FORTRAN_MESSAGE_MOD,      ONLY: FORTRAN_MESSAGE_T
  USE :: ENCODING_RULE_MOD,        ONLY: ENCODING_RULE_T
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_T), INTENT(IN)    :: THIS
  TYPE(PARAMETRIZATION_T),             INTENT(IN)    :: PAR
  TYPE(FORTRAN_MESSAGE_T),             INTENT(IN)    :: MSG
  TYPE(ENCODING_RULE_T), POINTER,      INTENT(OUT)   :: RULE
  TYPE(GRIB_ENCODER_OPTIONS_T),        INTENT(IN)    :: OPT
  TYPE(HOOKS_T),                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULES_NOT_INITIALIZED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCHES_NOT_ASSOCIATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_RULES=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.THIS%INITIALIZED, ERRFLAG_RULES_NOT_INITIALIZED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(THIS%HEAD), ERRFLAG_MATCHES_NOT_ASSOCIATED )

  !> Match the rules
  PP_TRYCALL(ERRFLAG_MATCH_RULES) THIS%HEAD%MATCH_SINGLE( MSG, PAR, RULE, OPT, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_RULES_NOT_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'rules not initialized' )
    CASE(ERRFLAG_MATCHES_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'matches not associated' )
    CASE(ERRFLAG_MATCH_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to match rules' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_MATCH_SINGLE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_MATCH_MULTIPLE'
PP_THREAD_SAFE FUNCTION ENCODING_RULES_TREE_LOADER_MATCH_MULTIPLE( THIS, MSG, PAR, RULES, IRULE, OPT, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: PARAMETRIZATION_MOD,      ONLY: PARAMETRIZATION_T
  USE :: FORTRAN_MESSAGE_MOD,      ONLY: FORTRAN_MESSAGE_T
  USE :: ENCODING_RULE_MOD,        ONLY: ENCODING_RULE_CONTAINER_T
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_T),                    INTENT(IN)    :: THIS
  TYPE(PARAMETRIZATION_T),                                INTENT(IN)    :: PAR
  TYPE(FORTRAN_MESSAGE_T),                                INTENT(IN)    :: MSG
  TYPE(ENCODING_RULE_CONTAINER_T), DIMENSION(:), POINTER, INTENT(INOUT) :: RULES
  INTEGER(KIND=JPIB_K),                                  INTENT(OUT)   :: IRULE
  TYPE(GRIB_ENCODER_OPTIONS_T),                           INTENT(IN)    :: OPT
  TYPE(HOOKS_T),                                          INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: NUM_MATCHES
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULES_NOT_INITIALIZED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCHES_NOT_ASSOCIATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCH_RULES=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_ALLOCATE=4_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.THIS%INITIALIZED, ERRFLAG_RULES_NOT_INITIALIZED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(THIS%HEAD), ERRFLAG_MATCHES_NOT_ASSOCIATED )

  IF ( .NOT. ASSOCIATED(RULES) ) THEN

    !> If the output rules are not associated, allocate them to the correct size.
    !> This requires an overhead due to the count of the number of matches.

    !> Count the number of matches
    PP_TRYCALL(ERRFLAG_MATCH_RULES) THIS%HEAD%COUNT_MATCHES( MSG, PAR, NUM_MATCHES, HOOKS )

    !> Allocate the rules
    ALLOCATE( RULES(NUM_MATCHES), STAT=ALLOC_STATUS )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_UNABLE_TO_ALLOCATE )

    DO I = 1, SIZE(RULES)
      RULES(I)%RULE_ => NULL()
    END DO

  ELSE
    !> If the output rules are already associated, set the pointer to NULL. If the number of
    !> matches is bigger than the size of the rules, an error is raised.
    !> This branch assumes the output array is bigger or equal to the number of matching rules.

    DO I = 1, SIZE(RULES)
      RULES(I)%RULE_ => NULL()
    END DO
  ENDIF


  !> Match the rules
  IRULE = 0_JPIB_K
  PP_TRYCALL(ERRFLAG_MATCH_RULES) THIS%HEAD%MATCH( MSG, PAR, RULES, IRULE, OPT, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_RULES_NOT_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'rules not initialized' )
    CASE(ERRFLAG_MATCHES_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'matches not associated' )
    CASE(ERRFLAG_MATCH_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to match rules' )
    CASE(ERRFLAG_UNABLE_TO_ALLOCATE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to allocate encoders' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=ALLOC_STATUS)
      ENDIF
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_MATCH_MULTIPLE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_FREE'
PP_THREAD_SAFE FUNCTION ENCODING_RULES_TREE_LOADER_FREE( THIS, OPT, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_T), INTENT(INOUT) :: THIS
  TYPE(GRIB_ENCODER_OPTIONS_T),        INTENT(IN)    :: OPT
  TYPE(HOOKS_T),                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: DEALLOC_STAT
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULES_NOT_INITIALIZED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_MATCHES_NOT_ASSOCIATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_RULES=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOCATE_RULES=4_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.THIS%INITIALIZED, ERRFLAG_RULES_NOT_INITIALIZED )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(THIS%HEAD), ERRFLAG_MATCHES_NOT_ASSOCIATED )

  ! Free rules
  PP_TRYCALL(ERRFLAG_FREE_RULES) THIS%HEAD%FREE( OPT, HOOKS)

  ! Deallocate the rules
  DEALLOCATE( THIS%HEAD, STAT=DEALLOC_STAT, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STAT .NE. 0, ERRFLAG_DEALLOCATE_RULES )

  ! Reset internal state
  THIS%INITIALIZED = .FALSE.
  THIS%SIZE_ = 0_JPIB_K

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_RULES_NOT_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'rules not initialized' )
    CASE(ERRFLAG_MATCHES_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'matches not associated' )
    CASE(ERRFLAG_FREE_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to free rules' )
    CASE(ERRFLAG_DEALLOCATE_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to deallocate rules' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=DEALLOC_STAT)
      ENDIF
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_FREE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_PRINT'
PP_THREAD_SAFE FUNCTION ENCODING_RULES_TREE_LOADER_PRINT( THIS, UNIT, OFFSET, OPT, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),                INTENT(IN)    :: UNIT
  INTEGER(KIND=JPIB_K),                INTENT(IN)    :: OFFSET
  TYPE(GRIB_ENCODER_OPTIONS_T),        INTENT(IN)    :: OPT
  TYPE(HOOKS_T),                       INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULES_NOT_INITIALIZED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_PRINT=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  IF ( ASSOCIATED(THIS%HEAD) ) THEN
    PP_TRYCALL(ERRFLAG_UNABLE_TO_PRINT) THIS%HEAD%PRINT( UNIT, OFFSET, OPT, HOOKS )
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_RULES_NOT_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'rules not initialized' )
    CASE(ERRFLAG_UNABLE_TO_PRINT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to print rules' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_PRINT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE














































#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_NODE_INIT_CFG'
RECURSIVE FUNCTION ENCODING_RULES_TREE_LOADER_NODE_INIT_CFG( THIS, CFG, &
&               FILTER_OPT, ENCODER_OPT, SIZE, NESTING_LEVEL, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T
  USE :: FILTER_OPTIONS_MOD,       ONLY: FILTER_OPTIONS_T
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: CMSGINTFLDS2IMSGINTFLDS

  ! Symbols imported from other libraries
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATIONS_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_STRING
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATIONS
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATIONS_SIZE
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_CONFIGURATION_BY_ID
  USE :: YAML_CORE_UTILS_MOD, ONLY: FUN_C2I_IF

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_NODE_T), INTENT(INOUT) :: THIS
  TYPE(YAML_CONFIGURATION_T),               INTENT(IN)    :: CFG
  TYPE(FILTER_OPTIONS_T),                   INTENT(IN)    :: FILTER_OPT
  TYPE(GRIB_ENCODER_OPTIONS_T),             INTENT(IN)    :: ENCODER_OPT
  INTEGER(KIND=JPIB_K),                     INTENT(INOUT) :: SIZE
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: NESTING_LEVEL
  TYPE(HOOKS_T),                            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: NUMBER_OF_OPERATIONS
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: I
  LOGICAL :: HAS_KEY
  LOGICAL :: HAS_OP
  LOGICAL :: HAS_OPERATION
  LOGICAL :: HAS_NESTED_RULES
  LOGICAL :: HAS_ENCODING_RULES
  CHARACTER(LEN=:), ALLOCATABLE :: COP
  CHARACTER(LEN=:), ALLOCATABLE :: KEY
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG
  TYPE(YAML_CONFIGURATIONS_T) :: OPERATIONS
  TYPE(YAML_CONFIGURATION_T) :: OPERATION
  TYPE(YAML_CONFIGURATION_T) :: NESTED_RULES

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NESTED_RULES_NOT_PRESENT=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_SUBCONFIGURATION=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_RULE_NODE=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_KEY=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_KEY_NOT_ALLOCATED=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_KEY_TOO_LONG=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALIDATE_KEY=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_SUBCFG=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_NUMBER_OF_OPERATIONS=12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOCATE_CONDITION=13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOCATE_CHILDREN=14_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG_BY_ID=15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OPERATION_EXPECTED=16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULE_EXPECTED=17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_TWO_RULES=18_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_OPERATION=19_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_NESTED_RULES=20_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_RULES=21_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OPERATION_DEALLOCATION_ERROR=22_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DELETE_SUBCFG=23_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOCATE_FILTERS=24_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_DELETE_SUBCONFIGURATION=25_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Recheck if the nested rules are present
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CFG, 'nested-rules', HAS_NESTED_RULES, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. HAS_NESTED_RULES, ERRFLAG_NESTED_RULES_NOT_PRESENT )

  !> Get the nested rules
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_SUBCONFIGURATION) YAML_GET_SUBCONFIGURATION( CFG, 'nested-rules', NESTED_RULES, HOOKS )

  ! Read the key
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( NESTED_RULES, 'key', HAS_KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. HAS_KEY, ERRFLAG_INVALID_RULE_NODE )
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( NESTED_RULES, 'operations', HAS_OP, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. HAS_OP, ERRFLAG_INVALID_RULE_NODE )

  ! Read the key
  THIS%KEY = REPEAT(' ',32)
  PP_TRYCALL(ERRFLAG_READ_KEY) YAML_READ_STRING( NESTED_RULES, 'key', KEY, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(KEY), ERRFLAG_KEY_NOT_ALLOCATED )
  PP_DEBUG_CRITICAL_COND_THROW( LEN_TRIM(KEY) .GT. 32, ERRFLAG_KEY_TOO_LONG )

  ! Check key (verify that it is a valid key and get an iterator for it)
  THIS%KEY = TRIM(ADJUSTL(KEY))
  PP_TRYCALL(ERRFLAG_VALIDATE_KEY) CMSGINTFLDS2IMSGINTFLDS( KEY, THIS%IKEY, HOOKS )

  ! Logging info
  IF (ENCODER_OPT%LOG_RULES_TREE) THEN
    WRITE(*,'(A,I8)') REPEAT(' ',NESTING_LEVEL*2)//'ENCODING_RULES_TREE_LOADER_NODE_INIT :: '//TRIM(ADJUSTL(KEY))//' :: ', THIS%IKEY
  ENDIF

  ! Deallocate key
  IF ( ALLOCATED(KEY) ) THEN
    DEALLOCATE(KEY, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_DEALLOC )
  ENDIF

  ! Read the operations
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_SUBCFG) YAML_GET_SUBCONFIGURATIONS( NESTED_RULES, 'operations', OPERATIONS, HOOKS )

  ! Read the operation size
  PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE) YAML_GET_CONFIGURATIONS_SIZE( OPERATIONS, NUMBER_OF_OPERATIONS, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( NUMBER_OF_OPERATIONS .LE. 0, ERRFLAG_WRONG_NUMBER_OF_OPERATIONS )

  ! Allocate the operations
  ALLOCATE( THIS%CONDITION(2,NUMBER_OF_OPERATIONS), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOCATE_CONDITION )

  ALLOCATE( THIS%FILTERS(NUMBER_OF_OPERATIONS), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOCATE_FILTERS )

  ALLOCATE( THIS%CHILDREN(NUMBER_OF_OPERATIONS), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOCATE_CHILDREN )

  !> Loop over sections
  DO I = 1, NUMBER_OF_OPERATIONS

    !> Get section configuration by ID
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG_BY_ID) YAML_GET_CONFIGURATION_BY_ID( OPERATIONS, I, OPERATION, HOOKS )

    !> Check keys
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( OPERATION, 'operation', HAS_OPERATION, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( OPERATION, 'nested-rules', HAS_NESTED_RULES, HOOKS )
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( OPERATION, 'encoding-rules', HAS_ENCODING_RULES, HOOKS )

    !> Error handling
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. HAS_OPERATION, ERRFLAG_OPERATION_EXPECTED )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. HAS_NESTED_RULES .AND. .NOT. HAS_ENCODING_RULES, ERRFLAG_RULE_EXPECTED )
    PP_DEBUG_CRITICAL_COND_THROW( HAS_NESTED_RULES .AND. HAS_ENCODING_RULES, ERRFLAG_TWO_RULES )

    !> Read the operation
    PP_TRYCALL(ERRFLAG_READ_OPERATION) THIS%READ_OPERATION( I, OPERATION, FILTER_OPT, ENCODER_OPT, NESTING_LEVEL, HOOKS )

    IF ( HAS_NESTED_RULES ) THEN
      PP_TRYCALL(ERRFLAG_READ_NESTED_RULES) THIS%CHILDREN(I)%INIT_CFG( OPERATION, FILTER_OPT, ENCODER_OPT, SIZE, NESTING_LEVEL+1, HOOKS )
    ELSEIF ( HAS_ENCODING_RULES ) THEN
      PP_TRYCALL(ERRFLAG_READ_RULES) THIS%CHILDREN(I)%INIT_RULES( OPERATION, FILTER_OPT, ENCODER_OPT, SIZE, NESTING_LEVEL+1, HOOKS )
    ENDIF

    !> Deallocate section configuration
    PP_TRYCALL( ERRFLAG_OPERATION_DEALLOCATION_ERROR ) YAML_DELETE_CONFIGURATION( OPERATION, HOOKS )

  ENDDO

  !> Delete nested rules
  PP_TRYCALL(ERRFLAG_UNABLE_TO_DELETE_SUBCONFIGURATION) YAML_DELETE_CONFIGURATIONS( OPERATIONS, HOOKS )

  !> Delete nested rules
  PP_TRYCALL(ERRFLAG_UNABLE_TO_DELETE_SUBCONFIGURATION) YAML_DELETE_CONFIGURATION( NESTED_RULES, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read configuration' )
    CASE(ERRFLAG_NESTED_RULES_NOT_PRESENT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'nested rules not present' )
    CASE(ERRFLAG_UNABLE_TO_READ_SUBCONFIGURATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read subconfiguration' )
    CASE(ERRFLAG_INVALID_RULE_NODE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid rule node' )
    CASE(ERRFLAG_READ_KEY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read key' )
    CASE(ERRFLAG_KEY_NOT_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key not allocated' )
    CASE(ERRFLAG_KEY_TOO_LONG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key too long' )
    CASE(ERRFLAG_VALIDATE_KEY)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'validate key' )
    CASE(ERRFLAG_DEALLOC)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'deallocation error' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=DEALLOC_STATUS)
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_READ_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read subconfiguration' )
    CASE(ERRFLAG_UNABLE_TO_GET_SUBCFG_SIZE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to get subconfiguration size' )
    CASE(ERRFLAG_WRONG_NUMBER_OF_OPERATIONS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'wrong number of operations' )
    CASE(ERRFLAG_ALLOCATE_CONDITION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to allocate condition' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=ALLOC_STATUS)
      ENDIF
    CASE(ERRFLAG_ALLOCATE_CHILDREN)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to allocate children' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=ALLOC_STATUS)
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_READ_CFG_BY_ID)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read configuration by ID' )
    CASE(ERRFLAG_OPERATION_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'operation expected' )
    CASE(ERRFLAG_RULE_EXPECTED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'rule expected' )
    CASE(ERRFLAG_TWO_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'two rules' )
    CASE(ERRFLAG_READ_OPERATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read operation' )
    CASE(ERRFLAG_READ_NESTED_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read nested rules' )
    CASE(ERRFLAG_READ_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read rules' )
    CASE(ERRFLAG_OPERATION_DEALLOCATION_ERROR)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'operation deallocation error' )
    CASE (ERRFLAG_ALLOCATE_FILTERS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to allocate filters' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=ALLOC_STATUS)
      ENDIF
    CASE(ERRFLAG_UNABLE_TO_DELETE_SUBCFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to delete subconfiguration' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_NODE_INIT_CFG
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_NODE_INIT_RULES'
RECURSIVE FUNCTION ENCODING_RULES_TREE_LOADER_NODE_INIT_RULES( THIS, CFG, &
&              FILTER_OPT, ENCODER_OPT, SIZE, NESTING_LEVEL, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T
  USE :: FILTER_OPTIONS_MOD,       ONLY: FILTER_OPTIONS_T

  ! Symbols imported from other libraries
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_NODE_T), INTENT(INOUT) :: THIS
  TYPE(YAML_CONFIGURATION_T),               INTENT(IN)    :: CFG
  TYPE(FILTER_OPTIONS_T),                   INTENT(IN)    :: FILTER_OPT
  TYPE(GRIB_ENCODER_OPTIONS_T),             INTENT(IN)    :: ENCODER_OPT
  INTEGER(KIND=JPIB_K),                     INTENT(INOUT) :: SIZE
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: NESTING_LEVEL
  TYPE(HOOKS_T),                            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: RULES_SIZE
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  ! Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_RULES_ALREADY_INITIALIZED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOCATE_RULES=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_READ_RULES=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( ASSOCIATED(THIS%RULES_COLLECTION), ERRFLAG_RULES_ALREADY_INITIALIZED )

  !> Allocate the rules
  ALLOCATE( THIS%RULES_COLLECTION, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS .NE. 0, ERRFLAG_ALLOCATE_RULES )

  !> Initialize the rules
  PP_TRYCALL(ERRFLAG_UNABLE_READ_RULES) THIS%RULES_COLLECTION%INIT( CFG, FILTER_OPT, ENCODER_OPT, HOOKS, NESTING_LEVEL=NESTING_LEVEL+1 )

  !> Read the rules size
  PP_TRYCALL(ERRFLAG_UNABLE_READ_RULES) THIS%RULES_COLLECTION%SIZE( RULES_SIZE, HOOKS )

  !> Update the size
  SIZE = SIZE + RULES_SIZE

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_RULES_ALREADY_INITIALIZED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'rules already initialized' )
    CASE(ERRFLAG_ALLOCATE_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to allocate rules' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=ALLOC_STATUS)
      ENDIF
    CASE(ERRFLAG_UNABLE_READ_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read rules' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_NODE_INIT_RULES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_NODE_READ_OPERATION'
RECURSIVE FUNCTION ENCODING_RULES_TREE_LOADER_NODE_READ_OPERATION( THIS, ID, CFG, FILTER_OPT, ENCODER_OPT, NESTING_LEVEL, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T
  USE :: ENUMERATORS_MOD,   ONLY: FLT_INT_COP2IOP
  USE :: ENUMERATORS_MOD,   ONLY: FLT_INT_MATCH_E
  USE :: ENUMERATORS_MOD,   ONLY: FLT_INT_IGNORE_E
  USE :: ENUMERATORS_MOD,   ONLY: FLT_INT_HAS_E
  USE :: ENUMERATORS_MOD,   ONLY: FLT_INT_LACKS_E
  USE :: ENUMERATORS_MOD,   ONLY: UNDEF_PARAM_E
  USE :: ENUMERATORS_MOD,   ONLY: CREPRES2IREPRES
  USE :: ENUMERATORS_MOD,   ONLY: CPACKING2IPACKING
  USE :: ENUMERATORS_MOD,   ONLY: CLEVTYPE2ILEVTYPE
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_REPRES_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_PACKING_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_LEVTYPE_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_CHEM_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_NUMBER_E
  USE :: FORTRAN_MESSAGE_ENUMERATORS_MOD, ONLY: MSGINTFLD_ANOFFSET_E
  USE :: FILTER_FACTORY_MOD, ONLY: MAKE_FILTER
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T
  USE :: FILTER_OPTIONS_MOD, ONLY: FILTER_OPTIONS_T

  ! Symbols imported from other libraries
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_T
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_CONFIGURATION_HAS_KEY
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_GET_SUBCONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_DELETE_CONFIGURATION
  USE :: YAML_CORE_UTILS_MOD, ONLY: YAML_READ_STRING

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_NODE_T), INTENT(INOUT) :: THIS
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: ID
  TYPE(YAML_CONFIGURATION_T),               INTENT(IN)    :: CFG
  TYPE(FILTER_OPTIONS_T),                   INTENT(IN)    :: FILTER_OPT
  TYPE(GRIB_ENCODER_OPTIONS_T),             INTENT(IN)    :: ENCODER_OPT
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: NESTING_LEVEL
  TYPE(HOOKS_T),                            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL :: HAS_OPERATION
  LOGICAL :: HAS_VALUE
  INTEGER(KIND=JPIB_K) :: IOP
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  LOGICAL, DIMENSION(4) :: CONDITIONS
  CHARACTER(LEN=:), ALLOCATABLE :: OPERATION
  CHARACTER(LEN=:), ALLOCATABLE :: VALUE

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_CFG=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OPERATION_NOT_PRESENT=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_READ_OPERATION=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_KEY_NOT_ALLOCATED=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_KEY_TOO_LONG=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_OPERATION=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNEXPECTED_KEYWORD=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONDITION_NOT_ASSOCIATED=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CONDITIONS_ID_OUT_OF_BOUNDS=9_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FILTERS_NOT_ASSOCIATED=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FILTERS_ID_OUT_OF_BOUNDS=11_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CREATE_FILTERS=12_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )


  !> Recheck if the nested rules are present
  PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CFG, 'operation', HAS_OPERATION, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT. HAS_OPERATION, ERRFLAG_OPERATION_NOT_PRESENT )

  !> Read the operation
  PP_TRYCALL(ERRFLAG_READ_OPERATION) YAML_READ_STRING( CFG, 'operation', OPERATION, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(OPERATION), ERRFLAG_KEY_NOT_ALLOCATED )
  PP_DEBUG_CRITICAL_COND_THROW( LEN_TRIM(OPERATION) .GT. 32, ERRFLAG_KEY_TOO_LONG )
  IF (ENCODER_OPT%LOG_RULES_TREE) THEN
    WRITE(*,*) REPEAT(' ',NESTING_LEVEL*2)//'opertion: ', OPERATION
  ENDIF
  !> Convert operation to enumerator
  PP_TRYCALL(ERRFLAG_READ_OPERATION) FLT_INT_COP2IOP( OPERATION, IOP, HOOKS )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(THIS%CONDITION), ERRFLAG_CONDITION_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( ID.LT.1, ERRFLAG_CONDITIONS_ID_OUT_OF_BOUNDS )
  PP_DEBUG_CRITICAL_COND_THROW( ID.GT.SIZE(THIS%CONDITION,2), ERRFLAG_CONDITIONS_ID_OUT_OF_BOUNDS )

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(THIS%FILTERS), ERRFLAG_FILTERS_NOT_ASSOCIATED )
  PP_DEBUG_CRITICAL_COND_THROW( ID.LT.1, ERRFLAG_FILTERS_ID_OUT_OF_BOUNDS )
  PP_DEBUG_CRITICAL_COND_THROW( ID.GT.SIZE(THIS%FILTERS), ERRFLAG_FILTERS_ID_OUT_OF_BOUNDS )

  !> Validate operation
  CONDITIONS(1) = IOP.NE.FLT_INT_IGNORE_E
  CONDITIONS(2) = IOP.NE.FLT_INT_MATCH_E
  CONDITIONS(3) = IOP.NE.FLT_INT_HAS_E
  CONDITIONS(4) = IOP.NE.FLT_INT_LACKS_E

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( ALL( CONDITIONS ), ERRFLAG_INVALID_OPERATION )

  ! Save the operation
  THIS%CONDITION(1,ID) = IOP
  THIS%CONDITION(2,ID) = UNDEF_PARAM_E

  ! Read the value if needed for the operation
  IF ( IOP.EQ.FLT_INT_IGNORE_E .OR. IOP.EQ.FLT_INT_MATCH_E ) THEN

    !> Recheck if the nested rules are present
    PP_TRYCALL(ERRFLAG_UNABLE_TO_READ_CFG) YAML_CONFIGURATION_HAS_KEY( CFG, 'value', HAS_VALUE, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT. HAS_VALUE, ERRFLAG_OPERATION_NOT_PRESENT )

    !> Read the value
    PP_TRYCALL(ERRFLAG_READ_OPERATION) YAML_READ_STRING( CFG, 'value', VALUE, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(VALUE), ERRFLAG_KEY_NOT_ALLOCATED )
    PP_DEBUG_CRITICAL_COND_THROW( LEN_TRIM(VALUE) .GT. 32, ERRFLAG_KEY_TOO_LONG )
    IF (ENCODER_OPT%LOG_RULES_TREE) THEN
      WRITE(*,'(A)') REPEAT(' ',NESTING_LEVEL*2)//'  value: '//TRIM(ADJUSTL(VALUE))
    ENDIF

    ! Depending on the operation, convert the value to the corresponding enumerator
    SELECT CASE (THIS%IKEY)
    CASE (MSGINTFLD_REPRES_E)
      PP_TRYCALL(ERRFLAG_READ_OPERATION) CREPRES2IREPRES( VALUE, THIS%CONDITION(2,ID), HOOKS )
    CASE (MSGINTFLD_PACKING_E)
      PP_TRYCALL(ERRFLAG_READ_OPERATION) CPACKING2IPACKING( VALUE, THIS%CONDITION(2,ID), HOOKS )
    CASE (MSGINTFLD_LEVTYPE_E)
      PP_TRYCALL(ERRFLAG_READ_OPERATION) CLEVTYPE2ILEVTYPE( VALUE, THIS%CONDITION(2,ID), HOOKS )
    CASE DEFAULT
      PP_DEBUG_CRITICAL_THROW( ERRFLAG_UNEXPECTED_KEYWORD )
    END SELECT
  ENDIF

  !> Create the filter
  PP_TRYCALL(ERRFLAG_CREATE_FILTERS) MAKE_FILTER( THIS%FILTERS(ID)%FILTER, TRIM(ADJUSTL(THIS%KEY)), CFG, FILTER_OPT, HOOKS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_READ_CFG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read configuration' )
    CASE(ERRFLAG_OPERATION_NOT_PRESENT)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'operation not present' )
    CASE(ERRFLAG_READ_OPERATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to read operation' )
    CASE(ERRFLAG_KEY_NOT_ALLOCATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key not allocated' )
    CASE(ERRFLAG_KEY_TOO_LONG)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'key too long' )
    CASE(ERRFLAG_INVALID_OPERATION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid operation' )
      IF ( ALLOCATED(OPERATION) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'Operation name: '//TRIM(ADJUSTL(OPERATION)) )
        DEALLOCATE(OPERATION, STAT=DEALLOC_STATUS)
      ENDIF
    CASE(ERRFLAG_UNEXPECTED_KEYWORD)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unexpected keyword' )
    CASE(ERRFLAG_CONDITION_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'condition not associated' )
    CASE(ERRFLAG_CONDITIONS_ID_OUT_OF_BOUNDS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'conditions ID out of bounds' )
    CASE(ERRFLAG_FILTERS_NOT_ASSOCIATED)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'filters not associated' )
    CASE(ERRFLAG_FILTERS_ID_OUT_OF_BOUNDS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'filters ID out of bounds' )
    CASE(ERRFLAG_CREATE_FILTERS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to create filters' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_NODE_READ_OPERATION
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_NODE_COUNT_MATCHES'
RECURSIVE FUNCTION ENCODING_RULES_TREE_LOADER_NODE_COUNT_MATCHES( THIS, MSG, PAR, NUM_MATCHES, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: PARAMETRIZATION_MOD,      ONLY: PARAMETRIZATION_T
  USE :: FORTRAN_MESSAGE_MOD,      ONLY: FORTRAN_MESSAGE_T
  USE :: CACHED_ENCODER_MOD,       ONLY: CACHED_ENCODER_T
  USE :: METADATA_BASE_MOD,        ONLY: METADATA_BASE_A

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_NODE_T), INTENT(IN)    :: THIS
  TYPE(PARAMETRIZATION_T),                  INTENT(IN)    :: PAR
  TYPE(FORTRAN_MESSAGE_T),                  INTENT(IN)    :: MSG
  INTEGER(KIND=JPIB_K),                     INTENT(INOUT) :: NUM_MATCHES
  TYPE(HOOKS_T),                            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL, DIMENSION(2) :: CONDITIONS
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: TMP
  LOGICAL :: LMATCH

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_COUNT_MATCHES=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_NODE=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Error handling
  CONDITIONS(1) = ASSOCIATED(THIS%FILTERS)
  CONDITIONS(2) = ASSOCIATED(THIS%RULES_COLLECTION)

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( ALL( CONDITIONS ), ERRFLAG_INVALID_NODE )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ANY( CONDITIONS ), ERRFLAG_INVALID_NODE )

  !> Check filters (if internal node)
  IF ( CONDITIONS(1) ) THEN
    DO I = 1, SIZE(THIS%FILTERS)
      PP_TRYCALL(ERRFLAG_UNABLE_TO_COUNT_MATCHES) THIS%FILTERS(I)%FILTER%MATCH( MSG, PAR, LMATCH, HOOKS )
      IF ( LMATCH ) THEN
        ! Recursive call to the children
        PP_TRYCALL(ERRFLAG_UNABLE_TO_COUNT_MATCHES) THIS%CHILDREN(I)%COUNT_MATCHES( MSG, PAR, NUM_MATCHES, HOOKS )
      ENDIF
    ENDDO
  ELSEIF ( CONDITIONS(2) ) THEN
    ! Count the number of matches in the rules collections
    PP_TRYCALL(ERRFLAG_UNABLE_TO_COUNT_MATCHES) THIS%RULES_COLLECTION%COUNT_MATCHES( MSG, PAR, TMP, HOOKS )

    ! Update the total number of matches
    NUM_MATCHES = NUM_MATCHES + TMP
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_COUNT_MATCHES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to count matches' )
    CASE(ERRFLAG_INVALID_NODE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid node' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_NODE_COUNT_MATCHES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_NODE_SIZE'
RECURSIVE FUNCTION ENCODING_RULES_TREE_LOADER_NODE_SIZE( THIS, SZ, MAX_SZ, NLEVELS, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: PARAMETRIZATION_MOD,      ONLY: PARAMETRIZATION_T
  USE :: FORTRAN_MESSAGE_MOD,      ONLY: FORTRAN_MESSAGE_T
  USE :: CACHED_ENCODER_MOD,       ONLY: CACHED_ENCODER_T
  USE :: METADATA_BASE_MOD,        ONLY: METADATA_BASE_A

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_NODE_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),                     INTENT(INOUT) :: SZ
  INTEGER(KIND=JPIB_K),                     INTENT(INOUT) :: MAX_SZ
  INTEGER(KIND=JPIB_K),                     INTENT(INOUT) :: NLEVELS
  TYPE(HOOKS_T),                            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL, DIMENSION(2) :: CONDITIONS
  INTEGER(KIND=JPIB_K) :: TMP
  INTEGER(KIND=JPIB_K) :: MAX_LEVELS
  INTEGER(KIND=JPIB_K) :: NUM_NESTED_LEVELS
  INTEGER(KIND=JPIB_K) :: I
  LOGICAL :: LMATCH

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_COUNT_MATCHES=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_NODE=2_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Error handling
  CONDITIONS(1) = ASSOCIATED(THIS%FILTERS)
  CONDITIONS(2) = ASSOCIATED(THIS%RULES_COLLECTION)

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( ALL( CONDITIONS ), ERRFLAG_INVALID_NODE )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ANY( CONDITIONS ), ERRFLAG_INVALID_NODE )

  !> Check filters (if internal node)
  IF ( CONDITIONS(1) ) THEN

    MAX_LEVELS = 0_JPIB_K
    DO I = 1, SIZE(THIS%FILTERS)

      ! Initialize the nested levels
      NUM_NESTED_LEVELS = 0_JPIB_K

      ! Recursive call to the children
      PP_TRYCALL(ERRFLAG_UNABLE_TO_COUNT_MATCHES) THIS%CHILDREN(I)%SIZE( SZ, TMP, NUM_NESTED_LEVELS, HOOKS )

      ! Update the maximum number of nested levels
      IF ( NUM_NESTED_LEVELS .GT. MAX_LEVELS ) THEN
        MAX_LEVELS = NUM_NESTED_LEVELS
      ENDIF

      ! Update the max size
      IF ( MAX_SZ .LT. TMP ) THEN
        MAX_SZ = TMP
      ENDIF

    ENDDO

    ! Update the number of nested levels
    NLEVELS = NLEVELS + MAX_LEVELS + 1_JPIB_K

  ELSEIF ( CONDITIONS(2) ) THEN
    ! Count the number of matches in the rules collections
    PP_TRYCALL(ERRFLAG_UNABLE_TO_COUNT_MATCHES) THIS%RULES_COLLECTION%SIZE( TMP, HOOKS )

    ! Update the size
    SZ = SZ + TMP
    MAX_SZ = TMP

    ! Update the number of nested levels
    NLEVELS = NLEVELS + 1_JPIB_K

  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_COUNT_MATCHES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to count matches' )
    CASE(ERRFLAG_INVALID_NODE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid node' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_NODE_SIZE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_NODE_PRINT'
RECURSIVE FUNCTION ENCODING_RULES_TREE_LOADER_NODE_PRINT( THIS, UNIT, OFFSET, OPT, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: PARAMETRIZATION_MOD,      ONLY: PARAMETRIZATION_T
  USE :: FORTRAN_MESSAGE_MOD,      ONLY: FORTRAN_MESSAGE_T
  USE :: CACHED_ENCODER_MOD,       ONLY: CACHED_ENCODER_T
  USE :: METADATA_BASE_MOD,        ONLY: METADATA_BASE_A
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_NODE_T), INTENT(IN)    :: THIS
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: UNIT
  INTEGER(KIND=JPIB_K),                     INTENT(IN)    :: OFFSET
  TYPE(GRIB_ENCODER_OPTIONS_T),             INTENT(IN)    :: OPT
  TYPE(HOOKS_T),                            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL, DIMENSION(2) :: CONDITIONS
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: TMP
  LOGICAL :: LMATCH

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_PRINT_FILTERS=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_PRINT_NESTED_RULES=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_PRINT_RULES=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DIMENSION_MISMATCH=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_NODE=5_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Error handling
  CONDITIONS(1) = ASSOCIATED(THIS%FILTERS).AND.ASSOCIATED(THIS%CHILDREN)
  CONDITIONS(2) = ASSOCIATED(THIS%RULES_COLLECTION)

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( ALL( CONDITIONS ), ERRFLAG_INVALID_NODE )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ANY( CONDITIONS ), ERRFLAG_INVALID_NODE )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(THIS%FILTERS).NE.SIZE(THIS%CHILDREN), ERRFLAG_DIMENSION_MISMATCH )

  !> Check filters (if internal node)
  IF ( CONDITIONS(1) ) THEN

    DO I = 1, SIZE(THIS%CHILDREN)
      PP_TRYCALL(ERRFLAG_UNABLE_TO_PRINT_FILTERS) THIS%FILTERS(I)%FILTER%PRINT( UNIT, OFFSET+2, HOOKS )
      PP_TRYCALL(ERRFLAG_UNABLE_TO_PRINT_NESTED_RULES) THIS%CHILDREN(I)%PRINT( UNIT, OFFSET+2, OPT, HOOKS )
    ENDDO

  ELSEIF ( CONDITIONS(2) ) THEN

    ! Count the number of matches in the rules collections
    PP_TRYCALL(ERRFLAG_UNABLE_TO_PRINT_RULES) THIS%RULES_COLLECTION%PRINT( UNIT, OFFSET, OPT, HOOKS )

  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_PRINT_FILTERS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to print filters' )
    CASE(ERRFLAG_UNABLE_TO_PRINT_NESTED_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to print nested rules' )
    CASE(ERRFLAG_UNABLE_TO_PRINT_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to print rules' )
    CASE(ERRFLAG_DIMENSION_MISMATCH)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'dimension mismatch' )
    CASE(ERRFLAG_INVALID_NODE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid node' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_NODE_PRINT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_NODE_MATCH_SINGLE'
RECURSIVE FUNCTION ENCODING_RULES_TREE_LOADER_NODE_MATCH_SINGLE( THIS, MSG, PAR, RULE, OPT, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: PARAMETRIZATION_MOD,      ONLY: PARAMETRIZATION_T
  USE :: FORTRAN_MESSAGE_MOD,      ONLY: FORTRAN_MESSAGE_T
  USE :: ENCODING_RULE_MOD,        ONLY: ENCODING_RULE_T
  USE :: METADATA_BASE_MOD,        ONLY: METADATA_BASE_A
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_NODE_T), INTENT(IN)    :: THIS
  TYPE(FORTRAN_MESSAGE_T),                  INTENT(IN)    :: MSG
  TYPE(PARAMETRIZATION_T),                  INTENT(IN)    :: PAR
  TYPE(ENCODING_RULE_T), POINTER,           INTENT(INOUT) :: RULE
  TYPE(GRIB_ENCODER_OPTIONS_T),             INTENT(IN)    :: OPT
  TYPE(HOOKS_T),                            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL, DIMENSION(2) :: CONDITIONS
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: TMP
  LOGICAL :: LMATCH

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CHECK_MATCHES=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_ENCODERS=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_NODE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_MATCHES_RULE=4_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )


  !> Error handling
  CONDITIONS(1) = ASSOCIATED(THIS%FILTERS)
  CONDITIONS(2) = ASSOCIATED(THIS%RULES_COLLECTION)

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( ALL( CONDITIONS ), ERRFLAG_INVALID_NODE )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ANY( CONDITIONS ), ERRFLAG_INVALID_NODE )

  !> Check filters (if internal node)
  IF ( CONDITIONS(1) ) THEN
    DO I = 1, SIZE(THIS%FILTERS)
      PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_MATCHES) THIS%FILTERS(I)%FILTER%MATCH( MSG, PAR, LMATCH, HOOKS )
      IF ( LMATCH ) THEN
        ! Recursive call to the children
        PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_ENCODERS) THIS%CHILDREN(I)%MATCH_SINGLE( MSG, PAR, RULE, OPT, HOOKS )
      ENDIF
    ENDDO
  ELSEIF ( CONDITIONS(2) ) THEN

    ! MIVAL: Count the number of matches in the rules collections
    ! Count the number of matches in the rules collections
    PP_TRYCALL(ERRFLAG_UNABLE_MATCHES_RULE) THIS%RULES_COLLECTION%MATCH( MSG, PAR, RULE, OPT, HOOKS )

  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_CHECK_MATCHES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to check filter for the i-th children' )
    CASE(ERRFLAG_UNABLE_TO_GET_ENCODERS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to call nested match' )
    CASE(ERRFLAG_INVALID_NODE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid node: unexpected pointer state' )
    CASE(ERRFLAG_UNABLE_MATCHES_RULE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to match rules' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_NODE_MATCH_SINGLE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE





#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_NODE_MATCH_MULTIPLE'
RECURSIVE FUNCTION ENCODING_RULES_TREE_LOADER_NODE_MATCH_MULTIPLE( THIS, MSG, PAR, RULES, IRULE, OPT, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: PARAMETRIZATION_MOD,      ONLY: PARAMETRIZATION_T
  USE :: FORTRAN_MESSAGE_MOD,      ONLY: FORTRAN_MESSAGE_T
  USE :: ENCODING_RULE_MOD,        ONLY: ENCODING_RULE_CONTAINER_T
  USE :: METADATA_BASE_MOD,        ONLY: METADATA_BASE_A
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_NODE_T),               INTENT(IN)    :: THIS
  TYPE(FORTRAN_MESSAGE_T),                                INTENT(IN)    :: MSG
  TYPE(PARAMETRIZATION_T),                                INTENT(IN)    :: PAR
  TYPE(ENCODING_RULE_CONTAINER_T), DIMENSION(:), POINTER, INTENT(INOUT) :: RULES
  INTEGER(KINd=JPIB_K),                                   INTENT(INOUT) :: IRULE
  TYPE(GRIB_ENCODER_OPTIONS_T),                           INTENT(IN)    :: OPT
  TYPE(HOOKS_T),                                          INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  LOGICAL, DIMENSION(2) :: CONDITIONS
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: TMP
  LOGICAL :: LMATCH

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_CHECK_MATCHES=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_GET_ENCODERS=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_NODE=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_MATCH_RULES=4_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  !> Error handling
  CONDITIONS(1) = ASSOCIATED(THIS%FILTERS)
  CONDITIONS(2) = ASSOCIATED(THIS%RULES_COLLECTION)

  !> Error handling
  PP_DEBUG_CRITICAL_COND_THROW( ALL( CONDITIONS ), ERRFLAG_INVALID_NODE )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ANY( CONDITIONS ), ERRFLAG_INVALID_NODE )

  !> Check filters (if internal node)
  IF ( CONDITIONS(1) ) THEN
    DO I = 1, SIZE(THIS%FILTERS)
      PP_TRYCALL(ERRFLAG_UNABLE_TO_CHECK_MATCHES) THIS%FILTERS(I)%FILTER%MATCH( MSG, PAR, LMATCH, HOOKS )
      IF ( LMATCH ) THEN
        ! Recursive call to the children
        PP_TRYCALL(ERRFLAG_UNABLE_TO_GET_ENCODERS) THIS%CHILDREN(I)%MATCH_MULTIPLE( MSG, PAR, RULES, IRULE, OPT, HOOKS )
      ENDIF
    ENDDO
  ELSEIF ( CONDITIONS(2) ) THEN

    ! MIVAL: Count the number of matches in the rules collections
    ! Count the number of matches in the rules collections
    PP_TRYCALL(ERRFLAG_UNABLE_TO_MATCH_RULES) THIS%RULES_COLLECTION%MATCH( MSG, PAR, RULES, IRULE, OPT, HOOKS )

  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_UNABLE_TO_CHECK_MATCHES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to check matches' )
    CASE(ERRFLAG_UNABLE_TO_GET_ENCODERS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to get encoders' )
    CASE(ERRFLAG_INVALID_NODE)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'invalid node' )
    CASE(ERRFLAG_UNABLE_TO_MATCH_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to match rules' )
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_NODE_MATCH_MULTIPLE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'ENCODING_RULES_TREE_LOADER_NODE_FREE'
RECURSIVE FUNCTION ENCODING_RULES_TREE_LOADER_NODE_FREE( THIS, OPT, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD,        ONLY: JPIB_K
  USE :: HOOKS_MOD,                ONLY: HOOKS_T
  USE :: GRIB_ENCODER_OPTIONS_MOD, ONLY: GRIB_ENCODER_OPTIONS_T
  USE :: FILTER_FACTORY_MOD,       ONLY: DESTROY_FILTER

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  !> Dummy arguments
  CLASS(ENCODING_RULES_TREE_LOADER_NODE_T), INTENT(INOUT) :: THIS
  TYPE(GRIB_ENCODER_OPTIONS_T),             INTENT(IN)    :: OPT
  TYPE(HOOKS_T),                            INTENT(INOUT) :: HOOKS

  !> Function result
  INTEGER(KIND=JPIB_K) :: RET

  !> Local variables
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  !> Local error flags
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_NESTED_RULES=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_NESTED_RULES=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_RULES_COLLECTION=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_RULES_COLLECTION=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_CONDITION=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FREE_FILTERS=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_FILTERS=7_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Recursive call to free nested rules
  IF ( ASSOCIATED(THIS%CHILDREN) ) THEN

    !> Free nested rules
    DO I = 1, SIZE(THIS%CHILDREN)
      PP_TRYCALL(ERRFLAG_FREE_NESTED_RULES) THIS%CHILDREN(I)%FREE( OPT, HOOKS )
    ENDDO

    !> Deallocate nested rules
    DEALLOCATE(THIS%CHILDREN, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_DEALLOC_NESTED_RULES )

  ENDIF

  !> Deallocate the filters
  IF ( ASSOCIATED(THIS%FILTERS) ) THEN

    !> Free filters
    DO I = 1, SIZE(THIS%FILTERS)
      IF ( ASSOCIATED(THIS%FILTERS(I)%FILTER) ) THEN
        PP_TRYCALL(ERRFLAG_FREE_FILTERS) DESTROY_FILTER( THIS%FILTERS(I)%FILTER, HOOKS )
      ENDIF
    ENDDO

    !> Deallocate nested rules
    DEALLOCATE(THIS%FILTERS, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_DEALLOC_FILTERS )

  ENDIF


  !> Deallocate conditions
  IF ( ASSOCIATED(THIS%CONDITION) ) THEN

    !> Deallocate the rules
    DEALLOCATE(THIS%CONDITION, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_DEALLOC_CONDITION )

  ENDIF

  !> Deallocate rules
  IF ( ASSOCIATED(THIS%RULES_COLLECTION) ) THEN

    !> Free the encoding rules
    PP_TRYCALL(ERRFLAG_FREE_RULES_COLLECTION) THIS%RULES_COLLECTION%FREE( OPT, HOOKS )

    !> Deallocate the rules
    DEALLOCATE(THIS%RULES_COLLECTION, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG)
    PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS .NE. 0, ERRFLAG_DEALLOC_RULES_COLLECTION )

  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point (On success)
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    PP_DEBUG_PUSH_FRAME()

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_FREE_RULES_COLLECTION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to free rules collection' )
    CASE(ERRFLAG_DEALLOC_RULES_COLLECTION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to deallocate rules collection' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=DEALLOC_STATUS)
      ENDIF
    CASE(ERRFLAG_FREE_NESTED_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to free nested rules' )
    CASE(ERRFLAG_DEALLOC_NESTED_RULES)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to deallocate nested rules' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=DEALLOC_STATUS)
      ENDIF
    CASE(ERRFLAG_DEALLOC_CONDITION)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to deallocate condition' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=DEALLOC_STATUS)
      ENDIF
    CASE(ERRFLAG_FREE_FILTERS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to free filters' )
    CASE(ERRFLAG_DEALLOC_FILTERS)
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unable to deallocate filters' )
      IF ( ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_PUSH_MSG_TO_FRAME( 'error message: ' // TRIM(ERRMSG) )
        DEALLOCATE(ERRMSG,STAT=DEALLOC_STATUS)
      ENDIF
    CASE DEFAULT
      PP_DEBUG_PUSH_MSG_TO_FRAME( 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point (on error)
  RETURN


END FUNCTION ENCODING_RULES_TREE_LOADER_NODE_FREE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE

END MODULE ENCODING_RULES_TREE_LOADER_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME